

<!DOCTYPE html>
<html lang="en">
	<head>
		
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<meta name="description" content="A 3D game engine written in Go!">
		<meta name="author" content="The Azul3D Authors">
		
			<title>Azul3D</title>
		
		<link rel="shortcut icon" href="/content/favicon.png"> 

		
		<link rel="stylesheet" type="text/css" href="/content/reset.css">

		
		<link href='http://fonts.googleapis.com/css?family=Audiowide' rel='stylesheet' type='text/css'>
		<link href='http://fonts.googleapis.com/css?family=Cutive+Mono' rel='stylesheet' type='text/css'>

		
		<link href='/content/dejavusans_book/stylesheet.css' rel='stylesheet' type='text/css'>

		
		<link href='/content/brandico/brandico.css' rel='stylesheet' type='text/css'>

		
		

		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

		
		<link rel="stylesheet" type="text/css" href="/content/stylesheet.css">
		<link rel="stylesheet" type="text/css" href="/content/mq.css">
	</head>
	<body>


<div id="top"></div>






































<div id="toparea">
	<div id="logo">
		<a href="/"><span class="biohazard">☣</span>
		<span>Azul3D</span></a>
	</div>

	<div id="shortbar">
		<a href="https://github.com/azul3d" target="_blank"><i class="icon-github menuIcon"></i><div class="title">GitHub</div></a>
		<a href="https://twitter.com/hashtag/azul3d" target="_blank"><i class="icon-twitter-bird menuIcon"></i><div class="title">Twitter</div></a>
		<a href="https://www.facebook.com/pages/Azul3D/651643168254798" target="_blank"><i class="icon-facebook menuIcon"></i><div class="title">Facebook</div></a>
		<a href="https://groups.google.com/forum/#!forum/azul3d" target="_blank" class="mail"><i class="menuIcon mailIcon">✉</i><div class="title">Mailing List</div></a>
	</div>
</div>

<div id="navigation">
	<h1>Navigation</h1>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/">Home</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/news">News</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/packages.html">Packages</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/doc">Doc</a> | <a href="/doc/faq.html">FAQ</a></span></span>
	</span>
</div>


<div id="content-container">
	<div id="content" class="pkg-content">






<h1 class="hdr pkg hdr-general">Package lmath</h1>
<span class="section pkg general">
	
		<p><em>In Development</em></p>
	
	<span class="pkg import">import "azul3d.org/lmath.dev"</span>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#versions">Versions</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#overview">Overview</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#index">Index</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#package-files">Package Files</a></span></span>
	</span>
	
		<h2>WARNING!</h2>
		<span class="sub">
			
				<p>This version is the in-development -- <em><strong>unstable</strong></em> -- version of this package. Backwards incompatible changes will be made to this package in the future and as such <em>you should not use this version</em>! Please use the latest release <a href="/lmath.v1">here</a>.</p>
			
		</span>
	

	
</span>



<h1 id="versions" class="hdr pkg hdr-versions"><a href="#versions" title="permalink">»</a>&nbsp;Versions <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg versions">
	
		<p>You are viewing an older version of this package (dev).</p>
	
	<p>Other versions of this package are available as follows. <em>Dev</em> is the in-development version of this package and should not generally be used (see <a href="/doc/versioning.html#development-versions">here</a> for more details).</p>
	<span class="list">
		
			
			
			
				
					<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="lmath.v1" title="azul3d.org/lmath.v1">v1</a> (latest version)</span></span>
				
			
		
			
			
			
				<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="lmath.dev" title="azul3d.org/lmath.dev">dev</a> (in development)</span></span>
			
		
	</span>
</span>



<h1 id="overview" class="hdr pkg hdr-overview"><a href="#overview" title="permalink">»</a>&nbsp;Overview <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg overview">
	<p>
Package lmath implements a 3D linear math library.
</p>

</span>


<h1 id="index" class="hdr pkg hdr-index"><a href="#index" title="permalink">»</a>&nbsp;Index <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg index">
	<span class="list">
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#constants">Constants</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#variables">Variables</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#AlmostEqual">func AlmostEqual(x, y, absTol float64) bool</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Clamp">func Clamp(v, min, max float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Degrees">func Degrees(radians float64) (degrees float64)</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Equal">func Equal(a, b float64) bool</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Lerp">func Lerp(a, b, t float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Radians">func Radians(degrees float64) (radians float64)</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rounded">func Rounded(v float64) float64</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys">type CoordSys</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.Back">func (c CoordSys) Back() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.ConvertMat3">func (c CoordSys) ConvertMat3(to CoordSys) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.ConvertMat4">func (c CoordSys) ConvertMat4(to CoordSys) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.Down">func (c CoordSys) Down() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.Forward">func (c CoordSys) Forward() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.Left">func (c CoordSys) Left() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.LeftHanded">func (c CoordSys) LeftHanded() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.Right">func (c CoordSys) Right() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.RightFrontUp">func (c CoordSys) RightFrontUp(right, forward, up float64) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.RightHanded">func (c CoordSys) RightHanded() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordSys.Up">func (c CoordSys) Up() Vec3</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3">type Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3Compose">func Mat3Compose(scale, shear, hpr Vec3, cs CoordSys) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3FromAxisAngle">func Mat3FromAxisAngle(axis Vec3, angle float64, cs CoordSys) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3FromScaleShear">func Mat3FromScaleShear(scale, shear Vec3, cs CoordSys) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3FromTranslation">func Mat3FromTranslation(translation Vec2) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Matrix3">func Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22 float64) Mat3</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Add">func (a Mat3) Add(b Mat3) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.AddScalar">func (a Mat3) AddScalar(s float64) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.AlmostEquals">func (a Mat3) AlmostEquals(b Mat3, epsilon float64) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Col">func (a Mat3) Col(column int) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.ColVec2">func (a Mat3) ColVec2(column int) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Decompose">func (a Mat3) Decompose(cs CoordSys) (scale, shear, hpr Vec3)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Determinant">func (a Mat3) Determinant() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.DivScalar">func (a Mat3) DivScalar(s float64) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Equals">func (a Mat3) Equals(b Mat3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Inverse">func (a Mat3) Inverse() (result Mat3, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.InverseTransposed">func (a Mat3) InverseTransposed() (result Mat3, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.IsNaN">func (a Mat3) IsNaN() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Mul">func (a Mat3) Mul(b Mat3) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.MulQuat">func (a Mat3) MulQuat(b Quat) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.MulScalar">func (a Mat3) MulScalar(s float64) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Row">func (a Mat3) Row(row int) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.RowVec2">func (a Mat3) RowVec2(row int) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.SetCol">func (a Mat3) SetCol(column int, values Vec3) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.SetColVec2">func (a Mat3) SetColVec2(column int, values Vec2) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.SetRow">func (a Mat3) SetRow(row int, values Vec3) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.SetRowVec2">func (a Mat3) SetRowVec2(row int, values Vec2) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.String">func (a Mat3) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Sub">func (a Mat3) Sub(b Mat3) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.SubScalar">func (a Mat3) SubScalar(s float64) Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat3.Transposed">func (a Mat3) Transposed() Mat3</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4">type Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4FromAxisAngle">func Mat4FromAxisAngle(axis Vec3, angle float64, cs CoordSys) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4FromFrustum">func Mat4FromFrustum(left, right, bottom, top, near, far float64) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4FromScale">func Mat4FromScale(scale Vec3) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4FromScaleShear">func Mat4FromScaleShear(scale, shear Vec3, cs CoordSys) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4FromTranslation">func Mat4FromTranslation(translation Vec3) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4Ortho">func Mat4Ortho(left, right, bottom, top, near, far float64) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4Perspective">func Mat4Perspective(fovY, aspectRatio, near, far float64) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4UnOrtho">func Mat4UnOrtho(left, right, bottom, top, near, far float64) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Matrix4">func Matrix4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33 float64) Mat4</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Add">func (a Mat4) Add(b Mat4) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.AddScalar">func (a Mat4) AddScalar(s float64) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.AffineInverse">func (a Mat4) AffineInverse() (out Mat4, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.AlmostEquals">func (a Mat4) AlmostEquals(b Mat4, epsilon float64) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Col">func (a Mat4) Col(column int) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.ColVec3">func (a Mat4) ColVec3(column int) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.DivScalar">func (a Mat4) DivScalar(s float64) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Equals">func (a Mat4) Equals(b Mat4) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Inverse">func (a Mat4) Inverse() (result Mat4, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.IsNaN">func (a Mat4) IsNaN() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Mul">func (a Mat4) Mul(b Mat4) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.MulQuat">func (a Mat4) MulQuat(b Quat) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.MulScalar">func (a Mat4) MulScalar(s float64) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Project">func (a Mat4) Project(p3 Vec3) (p2 Vec2, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Row">func (a Mat4) Row(row int) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.RowVec3">func (a Mat4) RowVec3(row int) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.SetCol">func (a Mat4) SetCol(column int, values Vec4) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.SetColVec3">func (a Mat4) SetColVec3(column int, values Vec3) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.SetRow">func (a Mat4) SetRow(row int, values Vec4) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.SetRowVec3">func (a Mat4) SetRowVec3(row int, values Vec3) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.SetTranslation">func (a Mat4) SetTranslation(t Vec3) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.SetUpperMat3">func (a Mat4) SetUpperMat3(b Mat3) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.String">func (a Mat4) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Sub">func (a Mat4) Sub(b Mat4) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.SubScalar">func (a Mat4) SubScalar(s float64) Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Translation">func (a Mat4) Translation() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Transposed">func (a Mat4) Transposed() Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.UpperMat3">func (a Mat4) UpperMat3() Mat3</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat">type Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#QuatFromAxisAngle">func QuatFromAxisAngle(axis Vec3, angle float64) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#QuatFromHpr">func QuatFromHpr(hpr Vec3, cs CoordSys) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#QuatFromMat3">func QuatFromMat3(m Mat3) Quat</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Add">func (a Quat) Add(b Quat) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.AddScalar">func (a Quat) AddScalar(b float64) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.AlmostEquals">func (a Quat) AlmostEquals(b Quat, epsilon float64) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Angle">func (a Quat) Angle() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.AngleQuat">func (a Quat) AngleQuat(cs CoordSys, b Quat) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Axis">func (a Quat) Axis() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Clamp">func (a Quat) Clamp(min, max float64) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Conjugate">func (a Quat) Conjugate() Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Div">func (a Quat) Div(b Quat) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.DivScalar">func (a Quat) DivScalar(b float64) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Dot">func (a Quat) Dot(b Quat) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Equals">func (a Quat) Equals(b Quat) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.ExtractToMat3">func (a Quat) ExtractToMat3() Mat3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.ExtractToMat4">func (a Quat) ExtractToMat4() Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Forward">func (a Quat) Forward(cs CoordSys) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Hpr">func (a Quat) Hpr(cs CoordSys) (hpr Vec3)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Inverse">func (a Quat) Inverse() Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.IsNaN">func (a Quat) IsNaN() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Length">func (a Quat) Length() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.LengthSq">func (a Quat) LengthSq() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Lerp">func (a Quat) Lerp(b Quat, t float64) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Max">func (a Quat) Max(b Quat) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Min">func (a Quat) Min(b Quat) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Mul">func (a Quat) Mul(b Quat) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.MulScalar">func (a Quat) MulScalar(b float64) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Normalized">func (a Quat) Normalized() Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Right">func (a Quat) Right(cs CoordSys) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.String">func (a Quat) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Sub">func (a Quat) Sub(b Quat) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.SubScalar">func (a Quat) SubScalar(b float64) Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.TransformVec3">func (a Quat) TransformVec3(v Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.TransformVec4">func (a Quat) TransformVec4(v Vec4) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Up">func (a Quat) Up(cs CoordSys) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Quat.Vec4">func (a Quat) Vec4() Vec4</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3">type Rect3</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Add">func (r Rect3) Add(p Vec3) Rect3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.AlmostEmpty">func (r Rect3) AlmostEmpty(epsilon float64) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.AlmostEquals">func (r Rect3) AlmostEquals(s Rect3, epsilon float64) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Area">func (r Rect3) Area() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Canon">func (r Rect3) Canon() Rect3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Center">func (r Rect3) Center() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Closest">func (r Rect3) Closest(p Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Contains">func (r Rect3) Contains(p Vec3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Corners">func (r Rect3) Corners() [8]Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Empty">func (r Rect3) Empty() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Equals">func (r Rect3) Equals(s Rect3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Furthest">func (r Rect3) Furthest(p Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.In">func (r Rect3) In(s Rect3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.InSphere">func (r Rect3) InSphere(s Sphere) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Inset">func (r Rect3) Inset(n float64) Rect3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Intersect">func (r Rect3) Intersect(s Rect3) (largest Rect3, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Overlaps">func (r Rect3) Overlaps(s Rect3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Size">func (r Rect3) Size() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.SqDistToPoint">func (r Rect3) SqDistToPoint(p Vec3) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.String">func (r Rect3) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Sub">func (r Rect3) Sub(p Vec3) Rect3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Rect3.Union">func (r Rect3) Union(s Rect3) Rect3</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Sphere">type Sphere</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Sphere.Contains">func (s Sphere) Contains(p Vec3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Sphere.In">func (s Sphere) In(b Sphere) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Sphere.InRect3">func (s Sphere) InRect3(r Rect3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Sphere.Overlaps">func (s Sphere) Overlaps(b Sphere) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Sphere.OverlapsRect3">func (s Sphere) OverlapsRect3(r Rect3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Sphere.Rect3">func (s Sphere) Rect3() Rect3</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2">type Vec2</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Add">func (a Vec2) Add(b Vec2) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.AddScalar">func (a Vec2) AddScalar(b float64) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.AlmostEquals">func (a Vec2) AlmostEquals(b Vec2, epsilon float64) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Angle">func (a Vec2) Angle(b Vec2) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.AnyGreater">func (a Vec2) AnyGreater(b Vec2) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.AnyLess">func (a Vec2) AnyLess(b Vec2) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Clamp">func (a Vec2) Clamp(min, max float64) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Degrees">func (a Vec2) Degrees() Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Div">func (a Vec2) Div(b Vec2) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.DivScalar">func (a Vec2) DivScalar(b float64) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Dot">func (a Vec2) Dot(b Vec2) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Equals">func (a Vec2) Equals(b Vec2) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Greater">func (a Vec2) Greater(b Vec2) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Inverse">func (a Vec2) Inverse() Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.IsNaN">func (a Vec2) IsNaN() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Length">func (a Vec2) Length() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.LengthSq">func (a Vec2) LengthSq() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Lerp">func (a Vec2) Lerp(b Vec2, t float64) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Less">func (a Vec2) Less(b Vec2) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Max">func (a Vec2) Max(b Vec2) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Min">func (a Vec2) Min(b Vec2) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Mul">func (a Vec2) Mul(b Vec2) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.MulScalar">func (a Vec2) MulScalar(b float64) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Normalized">func (a Vec2) Normalized() (v Vec2, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Proj">func (a Vec2) Proj(b Vec2) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Radians">func (a Vec2) Radians() Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Rounded">func (a Vec2) Rounded() Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.String">func (a Vec2) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.Sub">func (a Vec2) Sub(b Vec2) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.SubScalar">func (a Vec2) SubScalar(b float64) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.TransformPointVec2">func (a Vec2) TransformPointVec2(b Mat3) Vec2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec2.TransformVec2">func (a Vec2) TransformVec2(b Mat3) Vec2</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3">type Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CartToSphere">func CartToSphere(p Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SphereToCart">func SphereToCart(r float64, p Vec2) Vec3</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Add">func (a Vec3) Add(b Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.AddScalar">func (a Vec3) AddScalar(b float64) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.AlmostEquals">func (a Vec3) AlmostEquals(b Vec3, epsilon float64) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Angle">func (a Vec3) Angle(b Vec3) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.AnyGreater">func (a Vec3) AnyGreater(b Vec3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.AnyLess">func (a Vec3) AnyLess(b Vec3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Clamp">func (a Vec3) Clamp(min, max float64) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Cross">func (a Vec3) Cross(b Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Degrees">func (a Vec3) Degrees() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Div">func (a Vec3) Div(b Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.DivScalar">func (a Vec3) DivScalar(b float64) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Dot">func (a Vec3) Dot(b Vec3) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Equals">func (a Vec3) Equals(b Vec3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Greater">func (a Vec3) Greater(b Vec3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.HprToXyz">func (v Vec3) HprToXyz() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Inverse">func (a Vec3) Inverse() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.IsNaN">func (a Vec3) IsNaN() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Length">func (a Vec3) Length() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.LengthSq">func (a Vec3) LengthSq() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Lerp">func (a Vec3) Lerp(b Vec3, t float64) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Less">func (a Vec3) Less(b Vec3) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Max">func (a Vec3) Max(b Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Min">func (a Vec3) Min(b Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Mul">func (a Vec3) Mul(b Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.MulScalar">func (a Vec3) MulScalar(b float64) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Normalized">func (a Vec3) Normalized() (v Vec3, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Proj">func (a Vec3) Proj(b Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Radians">func (a Vec3) Radians() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Rounded">func (a Vec3) Rounded() Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.SignedAngle">func (a Vec3) SignedAngle(b, reference Vec3) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.String">func (a Vec3) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Sub">func (a Vec3) Sub(b Vec3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.SubScalar">func (a Vec3) SubScalar(b float64) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.TransformGeneralMat3">func (a Vec3) TransformGeneralMat3(b Mat3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.TransformGeneralMat4">func (a Vec3) TransformGeneralMat4(b Mat4) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.TransformMat3">func (a Vec3) TransformMat3(b Mat3) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.TransformMat4">func (a Vec3) TransformMat4(b Mat4) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.TransformVecMat4">func (a Vec3) TransformVecMat4(b Mat4) Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.XyzToHpr">func (v Vec3) XyzToHpr() Vec3</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4">type Vec4</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Add">func (a Vec4) Add(b Vec4) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.AddScalar">func (a Vec4) AddScalar(b float64) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.AlmostEquals">func (a Vec4) AlmostEquals(b Vec4, epsilon float64) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.AnyGreater">func (a Vec4) AnyGreater(b Vec4) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.AnyLess">func (a Vec4) AnyLess(b Vec4) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Clamp">func (a Vec4) Clamp(min, max float64) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Degrees">func (a Vec4) Degrees() Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Div">func (a Vec4) Div(b Vec4) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.DivScalar">func (a Vec4) DivScalar(b float64) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Dot">func (a Vec4) Dot(b Vec4) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Equals">func (a Vec4) Equals(b Vec4) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Greater">func (a Vec4) Greater(b Vec4) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.IsNaN">func (a Vec4) IsNaN() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Length">func (a Vec4) Length() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.LengthSq">func (a Vec4) LengthSq() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Lerp">func (a Vec4) Lerp(b Vec4, t float64) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Less">func (a Vec4) Less(b Vec4) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Max">func (a Vec4) Max(b Vec4) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Min">func (a Vec4) Min(b Vec4) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Mul">func (a Vec4) Mul(b Vec4) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.MulScalar">func (a Vec4) MulScalar(b float64) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Normalized">func (a Vec4) Normalized() (v Vec4, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Proj">func (a Vec4) Proj(b Vec4) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Quat">func (a Vec4) Quat() Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Radians">func (a Vec4) Radians() Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Rounded">func (a Vec4) Rounded() Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.String">func (a Vec4) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Sub">func (a Vec4) Sub(b Vec4) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.SubScalar">func (a Vec4) SubScalar(b float64) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Transform">func (a Vec4) Transform(b Mat4) Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Vec3">func (a Vec4) Vec3() Vec3</a></span></span>
			
		
	</span>
</span>




<h1 id="constants" class="hdr pkg hdr-constants"><a href="#constants" title="permalink">»</a>&nbsp;Constants <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg constants">
	
		<pre>const EPSILON = 1.0E-8</pre>
		<p>The default epsilon value used for floating point comparisons.
</p>
	
		<pre>const (
	// Invalid coordinate system
	CoordSysInvalid	CoordSys	= iota

	// Z up axis, right handed coordinate system
	CoordSysZUpRight

	// Y up axis, right handed coordinate system
	CoordSysYUpRight

	// Z up axis, left handed coordinate system
	CoordSysZUpLeft

	// Y up axis, left handed coordinate system
	CoordSysYUpLeft
)</pre>
		<p></p>
	
</span>





<h1 id="variables" class="hdr pkg hdr-variables"><a href="#variables" title="permalink">»</a>&nbsp;Variables <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg variables">
	
		<pre>var (
	Mat3Identity	= Matrix3(
		1, 0, 0,
		0, 1, 0,
		0, 0, 1,
	)

	Mat3YToZUp	= Matrix3(
		1, 0, 0,
		0, 0, 1,
		0, -1, 0,
	)

	Mat3ZToYUp	= Matrix3(
		1, 0, 0,
		0, 0, -1,
		0, 1, 0,
	)

	Mat3FlipY	= Matrix3(
		1, 0, 0,
		0, -1, 0,
		0, 0, 1,
	)

	Mat3FlipZ	= Matrix3(
		1, 0, 0,
		0, 1, 0,
		0, 0, -1,
	)

	Mat3LZToRY	= Mat3FlipY.Mul(Mat3ZToYUp)
	Mat3LYToRZ	= Mat3FlipZ.Mul(Mat3YToZUp)
)</pre>
		<p></p>
	
		<pre>var (
	Mat4Identity	= Matrix4(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1,
	)

	Mat4Zeros	= Matrix4(
		0, 0, 0, 0,
		0, 0, 0, 0,
		0, 0, 0, 0,
		0, 0, 0, 0,
	)

	Mat4Ones	= Matrix4(
		1, 1, 1, 1,
		1, 1, 1, 1,
		1, 1, 1, 1,
		1, 1, 1, 1,
	)

	Mat4YToZUp	= Matrix4(
		1, 0, 0, 0,
		0, 0, 1, 0,
		0, -1, 0, 0,
		0, 0, 0, 1,
	)

	Mat4ZToYUp	= Matrix4(
		1, 0, 0, 0,
		0, 0, -1, 0,
		0, 1, 0, 0,
		0, 0, 0, 1,
	)

	Mat4FlipY	= Matrix4(
		1, 0, 0, 0,
		0, -1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1,
	)

	Mat4FlipZ	= Matrix4(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, -1, 0,
		0, 0, 0, 1,
	)

	Mat4LZToRY	= Mat4FlipY.Mul(Mat4ZToYUp)
	Mat4LYToRZ	= Mat4FlipZ.Mul(Mat4YToZUp)
)</pre>
		<p></p>
	
		<pre>var (
	QuatIdentity	= Quat{1, 0, 0, 0}
	QuatZero	= Quat{0, 0, 0, 0}
)</pre>
		<p></p>
	
		<pre>var (
	Vec2One		= Vec2{1, 1}
	Vec2XUnit	= Vec2{1, 0}
	Vec2YUnit	= Vec2{0, 1}
	Vec2Zero	= Vec2{0, 0}
)</pre>
		<p></p>
	
		<pre>var (
	Vec3One		= Vec3{1, 1, 1}
	Vec3XUnit	= Vec3{1, 0, 0}
	Vec3YUnit	= Vec3{0, 1, 0}
	Vec3ZUnit	= Vec3{0, 0, 1}
	Vec3Zero	= Vec3{0, 0, 0}
)</pre>
		<p></p>
	
		<pre>var (
	Vec4One		= Vec4{1, 1, 1, 1}
	Vec4XUnit	= Vec4{1, 0, 0, 0}
	Vec4YUnit	= Vec4{0, 1, 0, 0}
	Vec4ZUnit	= Vec4{0, 0, 1, 0}
	Vec4WUnit	= Vec4{0, 0, 0, 1}
	Vec4Zero	= Vec4{0, 0, 0, 0}
)</pre>
		<p></p>
	
		<pre>var Rect3Zero = Rect3{}</pre>
		<p>Rect3Zero is the zero rectangle.
</p>
	
</span>





	<h1 id="AlmostEqual" class="hdr pkg hdr-function"><a href="#AlmostEqual" title="permalink">»</a>&nbsp;func AlmostEqual(x, y, absTol float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func AlmostEqual(x, y, absTol float64) bool</pre>
		<p>
AlmostEqual tells if the two floating point values x and y are considered
equal within the specified absolute==relative tolerence value.
</p>
<p>
The method of comparison used is that described at:
</p>
<pre><a href="http://realtimecollisiondetection.net/blog/?p=89">http://realtimecollisiondetection.net/blog/?p=89</a>
</pre>

	</span>

	<h1 id="Clamp" class="hdr pkg hdr-function"><a href="#Clamp" title="permalink">»</a>&nbsp;func Clamp(v, min, max float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Clamp(v, min, max float64) float64</pre>
		<p>
Clamp returns the value v clamped to the range of [min, max].
</p>

	</span>

	<h1 id="Degrees" class="hdr pkg hdr-function"><a href="#Degrees" title="permalink">»</a>&nbsp;func Degrees(radians float64) (degrees float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Degrees(radians float64) (degrees float64)</pre>
		<p>
Degrees converts from radians to degrees.
</p>

	</span>

	<h1 id="Equal" class="hdr pkg hdr-function"><a href="#Equal" title="permalink">»</a>&nbsp;func Equal(a, b float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Equal(a, b float64) bool</pre>
		<p>
Equal tells if the two floating point values a and b are considered equal
within the default EPSILON comparison value. It is short-handed for:
</p>
<pre>AlmostEqual(a, b, EPSILON)
</pre>

	</span>

	<h1 id="Lerp" class="hdr pkg hdr-function"><a href="#Lerp" title="permalink">»</a>&nbsp;func Lerp(a, b, t float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Lerp(a, b, t float64) float64</pre>
		<p>
Lerp performs a linear interpolation between a and b. The t parameter is a
number in the range 0.0-1.0. Some examples:
</p>
<pre>Lerp(0, 10, 0) == 0
Lerp(0, 10, 0.5) == 5
Lerp(0, 10, 1) == 10
</pre>
<p>
The interpolation method is precise, so it is guaranteed that:
</p>
<pre>Lerp(a, b, 1) == a
</pre>

	</span>

	<h1 id="Radians" class="hdr pkg hdr-function"><a href="#Radians" title="permalink">»</a>&nbsp;func Radians(degrees float64) (radians float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Radians(degrees float64) (radians float64)</pre>
		<p>
Radians converts from degrees to radians.
</p>

	</span>

	<h1 id="Rounded" class="hdr pkg hdr-function"><a href="#Rounded" title="permalink">»</a>&nbsp;func Rounded(v float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Rounded(v float64) float64</pre>
		<p>
Rounded returns the value rounded to the nearest whole number.
</p>

	</span>





	
	<h1 id="CoordSys" class="hdr pkg hdr-type"><a href="#CoordSys" title="permalink">»</a>&nbsp;type CoordSys <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CoordSys uint8</pre>
		<p>
CoordSys represents an specific coordinate system.
</p>

	</span>

	
	

	
	
		
		<h1 id="CoordSys.Back" class="hdr pkg hdr-method"><a href="#CoordSys.Back" title="permalink">»</a>&nbsp;func (c CoordSys) Back() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) Back() Vec3</pre>
			<p>
Back returns the back vector for the given coordinate system
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		
		<h1 id="CoordSys.ConvertMat3" class="hdr pkg hdr-method"><a href="#CoordSys.ConvertMat3" title="permalink">»</a>&nbsp;func (c CoordSys) ConvertMat3(to CoordSys) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) ConvertMat3(to CoordSys) Mat3</pre>
			<p>
ConvertMat3 returns a matrix that transforms from the indicated coordinate
system, to the coordinate system specified.
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		
		<h1 id="CoordSys.ConvertMat4" class="hdr pkg hdr-method"><a href="#CoordSys.ConvertMat4" title="permalink">»</a>&nbsp;func (c CoordSys) ConvertMat4(to CoordSys) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) ConvertMat4(to CoordSys) Mat4</pre>
			<p>
ConvertMat4 returns a matrix that transforms from the indicated coordinate
system, to the coordinate system specified.
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		
		<h1 id="CoordSys.Down" class="hdr pkg hdr-method"><a href="#CoordSys.Down" title="permalink">»</a>&nbsp;func (c CoordSys) Down() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) Down() Vec3</pre>
			<p>
Down returns the down vector for the given coordinate system
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		
		<h1 id="CoordSys.Forward" class="hdr pkg hdr-method"><a href="#CoordSys.Forward" title="permalink">»</a>&nbsp;func (c CoordSys) Forward() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) Forward() Vec3</pre>
			<p>
Forward returns the forward vector for the given coordinate system
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		
		<h1 id="CoordSys.Left" class="hdr pkg hdr-method"><a href="#CoordSys.Left" title="permalink">»</a>&nbsp;func (c CoordSys) Left() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) Left() Vec3</pre>
			<p>
Left returns the left vector for the given coordinate system
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		
		<h1 id="CoordSys.LeftHanded" class="hdr pkg hdr-method"><a href="#CoordSys.LeftHanded" title="permalink">»</a>&nbsp;func (c CoordSys) LeftHanded() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) LeftHanded() bool</pre>
			<p>
LeftHanded is short for:
</p>
<pre>!cs.RightHanded()
</pre>

		</span>
	
		
		<h1 id="CoordSys.Right" class="hdr pkg hdr-method"><a href="#CoordSys.Right" title="permalink">»</a>&nbsp;func (c CoordSys) Right() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) Right() Vec3</pre>
			<p>
Right returns the right vector for the given coordinate system
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		
		<h1 id="CoordSys.RightFrontUp" class="hdr pkg hdr-method"><a href="#CoordSys.RightFrontUp" title="permalink">»</a>&nbsp;func (c CoordSys) RightFrontUp(right, forward, up float64) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) RightFrontUp(right, forward, up float64) Vec3</pre>
			<p>
RightFrontUp returns an vector that is described by it&#39;s right, forward, and
up components in whatever way the specified coordinate system represents
that vector.
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		
		<h1 id="CoordSys.RightHanded" class="hdr pkg hdr-method"><a href="#CoordSys.RightHanded" title="permalink">»</a>&nbsp;func (c CoordSys) RightHanded() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) RightHanded() bool</pre>
			<p>
RightHanded tells whether this coordinate system is right-handed.
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		
		<h1 id="CoordSys.Up" class="hdr pkg hdr-method"><a href="#CoordSys.Up" title="permalink">»</a>&nbsp;func (c CoordSys) Up() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c CoordSys) Up() Vec3</pre>
			<p>
Up returns the up vector for the given coordinate system
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	

	
	<h1 id="Mat3" class="hdr pkg hdr-type"><a href="#Mat3" title="permalink">»</a>&nbsp;type Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Mat3 [3][3]float64</pre>
		<p>
Mat3 represents an 3x3 matrix, indices are in m[row][column] order.
</p>

	</span>

	
	
		<h1 id="Mat3Compose" class="hdr pkg hdr-function"><a href="#Mat3Compose" title="permalink">»</a>&nbsp;func Mat3Compose(scale, shear, hpr Vec3, cs CoordSys) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat3Compose(scale, shear, hpr Vec3, cs CoordSys) Mat3</pre>
			<p>
Mat3Compose composes a transformation matrix that applies the given scaling,
shearing, and hew/pitch/roll euler rotation values for the given coordinate
system.
</p>

		</span>
	
		<h1 id="Mat3FromAxisAngle" class="hdr pkg hdr-function"><a href="#Mat3FromAxisAngle" title="permalink">»</a>&nbsp;func Mat3FromAxisAngle(axis Vec3, angle float64, cs CoordSys) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat3FromAxisAngle(axis Vec3, angle float64, cs CoordSys) Mat3</pre>
			<p>
Mat3FromAxisAngle returns a rotation matrix that will rotate by the given
angle in radians counterclockwise about the indicated axis.
</p>

		</span>
	
		<h1 id="Mat3FromScaleShear" class="hdr pkg hdr-function"><a href="#Mat3FromScaleShear" title="permalink">»</a>&nbsp;func Mat3FromScaleShear(scale, shear Vec3, cs CoordSys) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat3FromScaleShear(scale, shear Vec3, cs CoordSys) Mat3</pre>
			<p>
Mat3FromScaleShear returns a matrix that will apply the given scaling and
shearing values along their respective axis in the specified coordinate
system.
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		<h1 id="Mat3FromTranslation" class="hdr pkg hdr-function"><a href="#Mat3FromTranslation" title="permalink">»</a>&nbsp;func Mat3FromTranslation(translation Vec2) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat3FromTranslation(translation Vec2) Mat3</pre>
			<p>
Mat3FromTranslation returns a matrix that will apply the given translation
vector.
</p>

		</span>
	
		<h1 id="Matrix3" class="hdr pkg hdr-function"><a href="#Matrix3" title="permalink">»</a>&nbsp;func Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22 float64) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22 float64) Mat3</pre>
			<p>
Matrix3 returns an new Mat3 given the specified matrix components.
</p>

		</span>
	

	
	
		
		<h1 id="Mat3.Add" class="hdr pkg hdr-method"><a href="#Mat3.Add" title="permalink">»</a>&nbsp;func (a Mat3) Add(b Mat3) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Add(b Mat3) Mat3</pre>
			<p>
Add performs memberwise addition a + b and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat3.AddScalar" class="hdr pkg hdr-method"><a href="#Mat3.AddScalar" title="permalink">»</a>&nbsp;func (a Mat3) AddScalar(s float64) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) AddScalar(s float64) Mat3</pre>
			<p>
AddScalar performs memberwise addition a + s and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat3.AlmostEquals" class="hdr pkg hdr-method"><a href="#Mat3.AlmostEquals" title="permalink">»</a>&nbsp;func (a Mat3) AlmostEquals(b Mat3, epsilon float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) AlmostEquals(b Mat3, epsilon float64) bool</pre>
			<p>
AlmostEquals tells whether a is memberwise equal to b using the specified
epsilon value.
</p>

		</span>
	
		
		<h1 id="Mat3.Col" class="hdr pkg hdr-method"><a href="#Mat3.Col" title="permalink">»</a>&nbsp;func (a Mat3) Col(column int) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Col(column int) Vec3</pre>
			<p>
Col returns the values in the specified matrix column as an three-component
vector.
The column parameter must be 0, 1, or 2 or else a panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat3.ColVec2" class="hdr pkg hdr-method"><a href="#Mat3.ColVec2" title="permalink">»</a>&nbsp;func (a Mat3) ColVec2(column int) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) ColVec2(column int) Vec2</pre>
			<p>
ColVec2 returns the values in the specified matrix column as an
two-component vector, ignoring the third element of the column.
The column parameter must be 0, 1, or 2 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat3.Decompose" class="hdr pkg hdr-method"><a href="#Mat3.Decompose" title="permalink">»</a>&nbsp;func (a Mat3) Decompose(cs CoordSys) (scale, shear, hpr Vec3) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Decompose(cs CoordSys) (scale, shear, hpr Vec3)</pre>
			<p>
Decompose extracts out the scaling, shearing, and hew/pitch/roll components
from the composed rotation matrix.
The coordinate system must be one of: CoordSysZUpRight, CoordSysZUpLeft, or
CoordSysYUpLeft.
</p>

		</span>
	
		
		<h1 id="Mat3.Determinant" class="hdr pkg hdr-method"><a href="#Mat3.Determinant" title="permalink">»</a>&nbsp;func (a Mat3) Determinant() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Determinant() float64</pre>
			<p>
Determinant calculates and returns the determinant of the matrix.
</p>

		</span>
	
		
		<h1 id="Mat3.DivScalar" class="hdr pkg hdr-method"><a href="#Mat3.DivScalar" title="permalink">»</a>&nbsp;func (a Mat3) DivScalar(s float64) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) DivScalar(s float64) Mat3</pre>
			<p>
DivScalar performs memberwise division a / s and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat3.Equals" class="hdr pkg hdr-method"><a href="#Mat3.Equals" title="permalink">»</a>&nbsp;func (a Mat3) Equals(b Mat3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Equals(b Mat3) bool</pre>
			<p>
Equals tells whether a is memberwise equal to b using the default EPSILON
value.
</p>

		</span>
	
		
		<h1 id="Mat3.Inverse" class="hdr pkg hdr-method"><a href="#Mat3.Inverse" title="permalink">»</a>&nbsp;func (a Mat3) Inverse() (result Mat3, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Inverse() (result Mat3, ok bool)</pre>
			<p>
Inverse returns the inverse of the matrix a. This is a fully general
operation and has no requirements about the transformation represented by
this matrix.
Returned is result=Mat3Identity, ok=false if the matrix was singular and
could not be inverted.
</p>

		</span>
	
		
		<h1 id="Mat3.InverseTransposed" class="hdr pkg hdr-method"><a href="#Mat3.InverseTransposed" title="permalink">»</a>&nbsp;func (a Mat3) InverseTransposed() (result Mat3, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) InverseTransposed() (result Mat3, ok bool)</pre>
			<p>
InverseTransposed simultaneously inverts and transposes the matrix and
returns it.
Returned is result=Mat3Identity, ok=false if the matrix was singular and
could not be inverted.
</p>

		</span>
	
		
		<h1 id="Mat3.IsNaN" class="hdr pkg hdr-method"><a href="#Mat3.IsNaN" title="permalink">»</a>&nbsp;func (a Mat3) IsNaN() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) IsNaN() bool</pre>
			<p>
IsNan tells if any components of this matrix are not an number.
</p>

		</span>
	
		
		<h1 id="Mat3.Mul" class="hdr pkg hdr-method"><a href="#Mat3.Mul" title="permalink">»</a>&nbsp;func (a Mat3) Mul(b Mat3) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Mul(b Mat3) Mat3</pre>
			<p>
Mul returns the result of a * b
</p>

		</span>
	
		
		<h1 id="Mat3.MulQuat" class="hdr pkg hdr-method"><a href="#Mat3.MulQuat" title="permalink">»</a>&nbsp;func (a Mat3) MulQuat(b Quat) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) MulQuat(b Quat) Mat3</pre>
			<p>
MulQuat multiplies the matrix by the specified quaternion rotation and
returns the result,
</p>

		</span>
	
		
		<h1 id="Mat3.MulScalar" class="hdr pkg hdr-method"><a href="#Mat3.MulScalar" title="permalink">»</a>&nbsp;func (a Mat3) MulScalar(s float64) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) MulScalar(s float64) Mat3</pre>
			<p>
MulScalar performs memberwise multiplication a * s and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat3.Row" class="hdr pkg hdr-method"><a href="#Mat3.Row" title="permalink">»</a>&nbsp;func (a Mat3) Row(row int) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Row(row int) Vec3</pre>
			<p>
Row returns the values in the specified matrix row as an three-component
vector.
The row parameter must be 0, 1, or 2 or else a panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat3.RowVec2" class="hdr pkg hdr-method"><a href="#Mat3.RowVec2" title="permalink">»</a>&nbsp;func (a Mat3) RowVec2(row int) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) RowVec2(row int) Vec2</pre>
			<p>
RowVec2 returns the values in the specified matrix row as an two-component
vector, the third element of the row is ignored.
The row parameter must be 0, 1, or 2 or else a panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat3.SetCol" class="hdr pkg hdr-method"><a href="#Mat3.SetCol" title="permalink">»</a>&nbsp;func (a Mat3) SetCol(column int, values Vec3) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) SetCol(column int, values Vec3) Mat3</pre>
			<p>
SetCol sets the values in the specified matrix column to the values in the
specified three-component vector.
The column parameter must be 0, 1, or 2 or else a panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat3.SetColVec2" class="hdr pkg hdr-method"><a href="#Mat3.SetColVec2" title="permalink">»</a>&nbsp;func (a Mat3) SetColVec2(column int, values Vec2) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) SetColVec2(column int, values Vec2) Mat3</pre>
			<p>
SetColVec2 sets the values in the specified matrix column to the values in
the specified two-component vector, leaving the third element in the column
untouched.
The column parameter must be 0, 1, or 2 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat3.SetRow" class="hdr pkg hdr-method"><a href="#Mat3.SetRow" title="permalink">»</a>&nbsp;func (a Mat3) SetRow(row int, values Vec3) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) SetRow(row int, values Vec3) Mat3</pre>
			<p>
SetRow sets the values of the specified matrix row to the values in the
specified three-component vector.
The row parameter must be 0, 1, or 2 or else a panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat3.SetRowVec2" class="hdr pkg hdr-method"><a href="#Mat3.SetRowVec2" title="permalink">»</a>&nbsp;func (a Mat3) SetRowVec2(row int, values Vec2) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) SetRowVec2(row int, values Vec2) Mat3</pre>
			<p>
SetRowVec2 sets the values in the specified matrix row to the values in the
specified three-component vector, leaving the third element in the row
untouched.
The row parameter must be 0, 1, or 2 or else a panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat3.String" class="hdr pkg hdr-method"><a href="#Mat3.String" title="permalink">»</a>&nbsp;func (a Mat3) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) String() string</pre>
			<p>
String returns an string representation of this matrix.
</p>

		</span>
	
		
		<h1 id="Mat3.Sub" class="hdr pkg hdr-method"><a href="#Mat3.Sub" title="permalink">»</a>&nbsp;func (a Mat3) Sub(b Mat3) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Sub(b Mat3) Mat3</pre>
			<p>
Sub performs in-place subtraction a - b and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat3.SubScalar" class="hdr pkg hdr-method"><a href="#Mat3.SubScalar" title="permalink">»</a>&nbsp;func (a Mat3) SubScalar(s float64) Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) SubScalar(s float64) Mat3</pre>
			<p>
SubScalar performs memberwise subtraction a - s and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat3.Transposed" class="hdr pkg hdr-method"><a href="#Mat3.Transposed" title="permalink">»</a>&nbsp;func (a Mat3) Transposed() Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat3) Transposed() Mat3</pre>
			<p>
Transposed returns the transposed version of matrix a.
</p>

		</span>
	

	
	<h1 id="Mat4" class="hdr pkg hdr-type"><a href="#Mat4" title="permalink">»</a>&nbsp;type Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Mat4 [4][4]float64</pre>
		<p>
Mat4 represents an 4x4 matrix, indices are in m[row][column] order.
</p>

	</span>

	
	
		<h1 id="Mat4FromAxisAngle" class="hdr pkg hdr-function"><a href="#Mat4FromAxisAngle" title="permalink">»</a>&nbsp;func Mat4FromAxisAngle(axis Vec3, angle float64, cs CoordSys) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat4FromAxisAngle(axis Vec3, angle float64, cs CoordSys) Mat4</pre>
			<p>
Mat4FromAxisAngle returns a rotation matrix that will rotate by the given
angle in radians counterclockwise about the indicated axis.
</p>

		</span>
	
		<h1 id="Mat4FromFrustum" class="hdr pkg hdr-function"><a href="#Mat4FromFrustum" title="permalink">»</a>&nbsp;func Mat4FromFrustum(left, right, bottom, top, near, far float64) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat4FromFrustum(left, right, bottom, top, near, far float64) Mat4</pre>
			<p>
Mat4FromFrustum returns a matrix that represents the given frustum given the
specified bounds.
</p>

		</span>
	
		<h1 id="Mat4FromScale" class="hdr pkg hdr-function"><a href="#Mat4FromScale" title="permalink">»</a>&nbsp;func Mat4FromScale(scale Vec3) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat4FromScale(scale Vec3) Mat4</pre>
			<p>
Mat4FromScale returns a matrix that will apply the given scaling values
along their respective axis.
</p>

		</span>
	
		<h1 id="Mat4FromScaleShear" class="hdr pkg hdr-function"><a href="#Mat4FromScaleShear" title="permalink">»</a>&nbsp;func Mat4FromScaleShear(scale, shear Vec3, cs CoordSys) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat4FromScaleShear(scale, shear Vec3, cs CoordSys) Mat4</pre>
			<p>
Mat4FromScaleShear returns a matrix that will apply the given scaling and
shearing values along their respective axis in the specified coordinate
system.
A panic will occur if the coordinate system is invalid.
</p>

		</span>
	
		<h1 id="Mat4FromTranslation" class="hdr pkg hdr-function"><a href="#Mat4FromTranslation" title="permalink">»</a>&nbsp;func Mat4FromTranslation(translation Vec3) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat4FromTranslation(translation Vec3) Mat4</pre>
			<p>
Mat4FromTranslation returns a matrix that will apply the given translation
vector.
</p>

		</span>
	
		<h1 id="Mat4Ortho" class="hdr pkg hdr-function"><a href="#Mat4Ortho" title="permalink">»</a>&nbsp;func Mat4Ortho(left, right, bottom, top, near, far float64) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat4Ortho(left, right, bottom, top, near, far float64) Mat4</pre>
			<p>
Mat4Ortho returns a orthographic projection matrix given the specified
frustum bounds.
See: <a href="http://en.wikipedia.org/wiki/Orthographic_projection_(geometry)">http://en.wikipedia.org/wiki/Orthographic_projection_(geometry)</a>
</p>

		</span>
	
		<h1 id="Mat4Perspective" class="hdr pkg hdr-function"><a href="#Mat4Perspective" title="permalink">»</a>&nbsp;func Mat4Perspective(fovY, aspectRatio, near, far float64) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat4Perspective(fovY, aspectRatio, near, far float64) Mat4</pre>
			<p>
Mat4Perspective returns a matrix that represents a perspective viewing
frustum given the specified field of view, aspect ratio, and near/far
values.
</p>

		</span>
	
		<h1 id="Mat4UnOrtho" class="hdr pkg hdr-function"><a href="#Mat4UnOrtho" title="permalink">»</a>&nbsp;func Mat4UnOrtho(left, right, bottom, top, near, far float64) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat4UnOrtho(left, right, bottom, top, near, far float64) Mat4</pre>
			<p>
Mat4UnOrtho returns a orthographic unprojection matrix given the specified
frustum bounds.
See: <a href="http://en.wikipedia.org/wiki/Orthographic_projection_(geometry)">http://en.wikipedia.org/wiki/Orthographic_projection_(geometry)</a>
</p>

		</span>
	
		<h1 id="Matrix4" class="hdr pkg hdr-function"><a href="#Matrix4" title="permalink">»</a>&nbsp;func Matrix4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33 float64) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Matrix4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33 float64) Mat4</pre>
			<p>
Matrix4 returns an new *Mat4 given the specified matrix components.
</p>

		</span>
	

	
	
		
		<h1 id="Mat4.Add" class="hdr pkg hdr-method"><a href="#Mat4.Add" title="permalink">»</a>&nbsp;func (a Mat4) Add(b Mat4) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Add(b Mat4) Mat4</pre>
			<p>
Add performs in-place memberwise addition a + b and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat4.AddScalar" class="hdr pkg hdr-method"><a href="#Mat4.AddScalar" title="permalink">»</a>&nbsp;func (a Mat4) AddScalar(s float64) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) AddScalar(s float64) Mat4</pre>
			<p>
AddScalar performs in-place memberwise addition a + s and returns the
result.
</p>

		</span>
	
		
		<h1 id="Mat4.AffineInverse" class="hdr pkg hdr-method"><a href="#Mat4.AffineInverse" title="permalink">»</a>&nbsp;func (a Mat4) AffineInverse() (out Mat4, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) AffineInverse() (out Mat4, ok bool)</pre>
			<p>
AffineInverse returns the inverse of the affine transformation matrix and
returns the result.
Returned is Mat4Identity, ok=false if the matrix was singular and could not
be inverted,
</p>

		</span>
	
		
		<h1 id="Mat4.AlmostEquals" class="hdr pkg hdr-method"><a href="#Mat4.AlmostEquals" title="permalink">»</a>&nbsp;func (a Mat4) AlmostEquals(b Mat4, epsilon float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) AlmostEquals(b Mat4, epsilon float64) bool</pre>
			<p>
AlmostEquals tells whether a is memberwise equal to b using the specified
epsilon value.
</p>

		</span>
	
		
		<h1 id="Mat4.Col" class="hdr pkg hdr-method"><a href="#Mat4.Col" title="permalink">»</a>&nbsp;func (a Mat4) Col(column int) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Col(column int) Vec4</pre>
			<p>
Col returns the values in the specified matrix column as an four-component
vector.
The column parameter must be 0, 1, 2, or 3 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat4.ColVec3" class="hdr pkg hdr-method"><a href="#Mat4.ColVec3" title="permalink">»</a>&nbsp;func (a Mat4) ColVec3(column int) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) ColVec3(column int) Vec3</pre>
			<p>
ColVec3 returns the values in the specified matrix column as an
three-component vector, ignoring the fourth element of the column.
The column parameter must be 0, 1, 2, or 3 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat4.DivScalar" class="hdr pkg hdr-method"><a href="#Mat4.DivScalar" title="permalink">»</a>&nbsp;func (a Mat4) DivScalar(s float64) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) DivScalar(s float64) Mat4</pre>
			<p>
DivScalar performs in-place memberwise division a / s and returns the
result.
</p>

		</span>
	
		
		<h1 id="Mat4.Equals" class="hdr pkg hdr-method"><a href="#Mat4.Equals" title="permalink">»</a>&nbsp;func (a Mat4) Equals(b Mat4) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Equals(b Mat4) bool</pre>
			<p>
Equals tells whether a is memberwise equal to b using the default EPSILON
value.
</p>

		</span>
	
		
		<h1 id="Mat4.Inverse" class="hdr pkg hdr-method"><a href="#Mat4.Inverse" title="permalink">»</a>&nbsp;func (a Mat4) Inverse() (result Mat4, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Inverse() (result Mat4, ok bool)</pre>
			<p>
Inverse returns the inverse of the matrix, as a fully general operation and
makes no requirements about the type of transform represented by the matrix.
Returned is Mat4Identity, ok=false if the matrix was singular and could not
be inverted.
</p>

		</span>
	
		
		<h1 id="Mat4.IsNaN" class="hdr pkg hdr-method"><a href="#Mat4.IsNaN" title="permalink">»</a>&nbsp;func (a Mat4) IsNaN() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) IsNaN() bool</pre>
			<p>
IsNan tells if any components of this matrix are not an number.
</p>

		</span>
	
		
		<h1 id="Mat4.Mul" class="hdr pkg hdr-method"><a href="#Mat4.Mul" title="permalink">»</a>&nbsp;func (a Mat4) Mul(b Mat4) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Mul(b Mat4) Mat4</pre>
			<p>
Mul performs matrix multiplication a * b and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat4.MulQuat" class="hdr pkg hdr-method"><a href="#Mat4.MulQuat" title="permalink">»</a>&nbsp;func (a Mat4) MulQuat(b Quat) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) MulQuat(b Quat) Mat4</pre>
			<p>
MulQuat multiplies the matrix by the quaternion a * b and returns the
result.
</p>

		</span>
	
		
		<h1 id="Mat4.MulScalar" class="hdr pkg hdr-method"><a href="#Mat4.MulScalar" title="permalink">»</a>&nbsp;func (a Mat4) MulScalar(s float64) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) MulScalar(s float64) Mat4</pre>
			<p>
MulScalar performs in-place memberwise multiplication a * s and returns the
result.
</p>

		</span>
	
		
		<h1 id="Mat4.Project" class="hdr pkg hdr-method"><a href="#Mat4.Project" title="permalink">»</a>&nbsp;func (a Mat4) Project(p3 Vec3) (p2 Vec2, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Project(p3 Vec3) (p2 Vec2, ok bool)</pre>
			<p>
Project returns a 2D point in the range -1 to +1 given a 3D point also in
the frustum matrix a&#39;s coordinate space.
</p>
<p>
If ok=false is returned then the point is outside of the frustum matrix a,
and the returned point may not be meaningful.
</p>

		</span>
	
		
		<h1 id="Mat4.Row" class="hdr pkg hdr-method"><a href="#Mat4.Row" title="permalink">»</a>&nbsp;func (a Mat4) Row(row int) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Row(row int) Vec4</pre>
			<p>
Row returns the values in the specified matrix row as an three-component
vector.
The row parameter must be 0, 1, 2, or 3 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat4.RowVec3" class="hdr pkg hdr-method"><a href="#Mat4.RowVec3" title="permalink">»</a>&nbsp;func (a Mat4) RowVec3(row int) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) RowVec3(row int) Vec3</pre>
			<p>
RowVec3 returns the values in the specified matrix row as an three-component
vector, the fourth element of the row is ignored.
The row parameter must be 0, 1, 2, or 3 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat4.SetCol" class="hdr pkg hdr-method"><a href="#Mat4.SetCol" title="permalink">»</a>&nbsp;func (a Mat4) SetCol(column int, values Vec4) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) SetCol(column int, values Vec4) Mat4</pre>
			<p>
SetCol sets the values in the specified matrix column to the values in the
specified four-component vector.
The column parameter must be 0, 1, 2, or 3 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat4.SetColVec3" class="hdr pkg hdr-method"><a href="#Mat4.SetColVec3" title="permalink">»</a>&nbsp;func (a Mat4) SetColVec3(column int, values Vec3) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) SetColVec3(column int, values Vec3) Mat4</pre>
			<p>
SetColVec3 sets the values in the specified matrix column to the values in
the specified three-component vector, leaving the fourth element in the
column untouched.
The column parameter must be 0, 1, 2, or 3 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat4.SetRow" class="hdr pkg hdr-method"><a href="#Mat4.SetRow" title="permalink">»</a>&nbsp;func (a Mat4) SetRow(row int, values Vec4) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) SetRow(row int, values Vec4) Mat4</pre>
			<p>
SetRow sets the values in the specified matrix row to the values in the
specified four-component vector.
The row parameter must be 0, 1, 2, or 3 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat4.SetRowVec3" class="hdr pkg hdr-method"><a href="#Mat4.SetRowVec3" title="permalink">»</a>&nbsp;func (a Mat4) SetRowVec3(row int, values Vec3) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) SetRowVec3(row int, values Vec3) Mat4</pre>
			<p>
SetRowVec3 sets the values in the specified matrix row to the values in the
specified three-component vector, leaving the fourth element in the row
untouched.
The row parameter must be 0, 1, 2, or 3 or else an panic will occur.
</p>

		</span>
	
		
		<h1 id="Mat4.SetTranslation" class="hdr pkg hdr-method"><a href="#Mat4.SetTranslation" title="permalink">»</a>&nbsp;func (a Mat4) SetTranslation(t Vec3) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) SetTranslation(t Vec3) Mat4</pre>
			<p>
SetTranslation sets the translation components of the matrix to the given
vector and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat4.SetUpperMat3" class="hdr pkg hdr-method"><a href="#Mat4.SetUpperMat3" title="permalink">»</a>&nbsp;func (a Mat4) SetUpperMat3(b Mat3) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) SetUpperMat3(b Mat3) Mat4</pre>
			<p>
SetUpperMat3 sets the upper-left 3x3 matrix to the specified one and returns
the new 4x4 matrix.
</p>

		</span>
	
		
		<h1 id="Mat4.String" class="hdr pkg hdr-method"><a href="#Mat4.String" title="permalink">»</a>&nbsp;func (a Mat4) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) String() string</pre>
			<p>
String returns an string representation of this matrix.
</p>

		</span>
	
		
		<h1 id="Mat4.Sub" class="hdr pkg hdr-method"><a href="#Mat4.Sub" title="permalink">»</a>&nbsp;func (a Mat4) Sub(b Mat4) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Sub(b Mat4) Mat4</pre>
			<p>
Sub performs in-place memberwise subtraction a - b and returns the result.
</p>

		</span>
	
		
		<h1 id="Mat4.SubScalar" class="hdr pkg hdr-method"><a href="#Mat4.SubScalar" title="permalink">»</a>&nbsp;func (a Mat4) SubScalar(s float64) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) SubScalar(s float64) Mat4</pre>
			<p>
SubScalar performs in-place memberwise subtraction a - s and returns the
result.
</p>

		</span>
	
		
		<h1 id="Mat4.Translation" class="hdr pkg hdr-method"><a href="#Mat4.Translation" title="permalink">»</a>&nbsp;func (a Mat4) Translation() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Translation() Vec3</pre>
			<p>
Translation returns the translation components of the matrix as a vector.
</p>

		</span>
	
		
		<h1 id="Mat4.Transposed" class="hdr pkg hdr-method"><a href="#Mat4.Transposed" title="permalink">»</a>&nbsp;func (a Mat4) Transposed() Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) Transposed() Mat4</pre>
			<p>
Transposed returns the transposed version of matrix a.
</p>

		</span>
	
		
		<h1 id="Mat4.UpperMat3" class="hdr pkg hdr-method"><a href="#Mat4.UpperMat3" title="permalink">»</a>&nbsp;func (a Mat4) UpperMat3() Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Mat4) UpperMat3() Mat3</pre>
			<p>
UpperMat3 returns the upper-left 3x3 matrix.
</p>

		</span>
	

	
	<h1 id="Quat" class="hdr pkg hdr-type"><a href="#Quat" title="permalink">»</a>&nbsp;type Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Quat struct {
	W, X, Y, Z float64
}</pre>
		<p>
Quat represents a four component vector.
</p>

	</span>

	
	
		<h1 id="QuatFromAxisAngle" class="hdr pkg hdr-function"><a href="#QuatFromAxisAngle" title="permalink">»</a>&nbsp;func QuatFromAxisAngle(axis Vec3, angle float64) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func QuatFromAxisAngle(axis Vec3, angle float64) Quat</pre>
			<p>
QuatFromAxisAngle returns a quaternion rotation which represents the given
angle of rotation in radians about the given axis.
</p>

		</span>
	
		<h1 id="QuatFromHpr" class="hdr pkg hdr-function"><a href="#QuatFromHpr" title="permalink">»</a>&nbsp;func QuatFromHpr(hpr Vec3, cs CoordSys) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func QuatFromHpr(hpr Vec3, cs CoordSys) Quat</pre>
			<p>
QuatFromHpr returns a quaternion equivilent to the heading, pithc, and roll
Euler angles in radians for the given coordinate system.
</p>

		</span>
	
		<h1 id="QuatFromMat3" class="hdr pkg hdr-function"><a href="#QuatFromMat3" title="permalink">»</a>&nbsp;func QuatFromMat3(m Mat3) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func QuatFromMat3(m Mat3) Quat</pre>
			<p>
QuatFromMat3 returns a quaternion rotation according to the rotation
represented by the matrix.
</p>

		</span>
	

	
	
		
		<h1 id="Quat.Add" class="hdr pkg hdr-method"><a href="#Quat.Add" title="permalink">»</a>&nbsp;func (a Quat) Add(b Quat) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Add(b Quat) Quat</pre>
			<p>
Add performs a componentwise addition of the two quaternions, returning
a + b.
</p>

		</span>
	
		
		<h1 id="Quat.AddScalar" class="hdr pkg hdr-method"><a href="#Quat.AddScalar" title="permalink">»</a>&nbsp;func (a Quat) AddScalar(b float64) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) AddScalar(b float64) Quat</pre>
			<p>
AddScalar performs a componentwise scalar addition of a + b.
</p>

		</span>
	
		
		<h1 id="Quat.AlmostEquals" class="hdr pkg hdr-method"><a href="#Quat.AlmostEquals" title="permalink">»</a>&nbsp;func (a Quat) AlmostEquals(b Quat, epsilon float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) AlmostEquals(b Quat, epsilon float64) bool</pre>
			<p>
AlmostEquals tells if a == b using the specified epsilon value.
</p>

		</span>
	
		
		<h1 id="Quat.Angle" class="hdr pkg hdr-method"><a href="#Quat.Angle" title="permalink">»</a>&nbsp;func (a Quat) Angle() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Angle() float64</pre>
			<p>
Angle returns the rotation represented by the quaternion as an angle about
an arbitrary axis (returned by the Axis() function), the returned value is
expressed in radian units counterclockwise about the axis.
</p>

		</span>
	
		
		<h1 id="Quat.AngleQuat" class="hdr pkg hdr-method"><a href="#Quat.AngleQuat" title="permalink">»</a>&nbsp;func (a Quat) AngleQuat(cs CoordSys, b Quat) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) AngleQuat(cs CoordSys, b Quat) float64</pre>
			<p>
Angle returns the angle between the orientation represented by this
quaternion and the orientation represent by the quaternion b in radians.
</p>

		</span>
	
		
		<h1 id="Quat.Axis" class="hdr pkg hdr-method"><a href="#Quat.Axis" title="permalink">»</a>&nbsp;func (a Quat) Axis() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Axis() Vec3</pre>
			<p>
Axis returns the axis of the rotation represented by the quaternion. The
returned vector is not normalized.
</p>

		</span>
	
		
		<h1 id="Quat.Clamp" class="hdr pkg hdr-method"><a href="#Quat.Clamp" title="permalink">»</a>&nbsp;func (a Quat) Clamp(min, max float64) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Clamp(min, max float64) Quat</pre>
			<p>
Clamp clamps each value in the quaternion to the range of [min, max] and returns
it.
</p>

		</span>
	
		
		<h1 id="Quat.Conjugate" class="hdr pkg hdr-method"><a href="#Quat.Conjugate" title="permalink">»</a>&nbsp;func (a Quat) Conjugate() Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Conjugate() Quat</pre>
			<p>
Conjugate calculates and returns the conjugate of this quaternion.
</p>

		</span>
	
		
		<h1 id="Quat.Div" class="hdr pkg hdr-method"><a href="#Quat.Div" title="permalink">»</a>&nbsp;func (a Quat) Div(b Quat) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Div(b Quat) Quat</pre>
			<p>
Div performs a componentwise division of the two quaternions, returning
a * b.
</p>

		</span>
	
		
		<h1 id="Quat.DivScalar" class="hdr pkg hdr-method"><a href="#Quat.DivScalar" title="permalink">»</a>&nbsp;func (a Quat) DivScalar(b float64) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) DivScalar(b float64) Quat</pre>
			<p>
DivScalar performs a componentwise scalar division of a * b.
</p>

		</span>
	
		
		<h1 id="Quat.Dot" class="hdr pkg hdr-method"><a href="#Quat.Dot" title="permalink">»</a>&nbsp;func (a Quat) Dot(b Quat) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Dot(b Quat) float64</pre>
			<p>
Dot returns the dot product of a and b.
</p>

		</span>
	
		
		<h1 id="Quat.Equals" class="hdr pkg hdr-method"><a href="#Quat.Equals" title="permalink">»</a>&nbsp;func (a Quat) Equals(b Quat) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Equals(b Quat) bool</pre>
			<p>
Equals tells if a == b using the default EPSILON value.
</p>

		</span>
	
		
		<h1 id="Quat.ExtractToMat3" class="hdr pkg hdr-method"><a href="#Quat.ExtractToMat3" title="permalink">»</a>&nbsp;func (a Quat) ExtractToMat3() Mat3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) ExtractToMat3() Mat3</pre>
			<p>
ExtractToMat3 extracts the quaternion into a three-component matrix and
returns it.
</p>

		</span>
	
		
		<h1 id="Quat.ExtractToMat4" class="hdr pkg hdr-method"><a href="#Quat.ExtractToMat4" title="permalink">»</a>&nbsp;func (a Quat) ExtractToMat4() Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) ExtractToMat4() Mat4</pre>
			<p>
ExtractToMat4 extracts the quaternion into a four-component matrix and
returns it.
</p>

		</span>
	
		
		<h1 id="Quat.Forward" class="hdr pkg hdr-method"><a href="#Quat.Forward" title="permalink">»</a>&nbsp;func (a Quat) Forward(cs CoordSys) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Forward(cs CoordSys) Vec3</pre>
			<p>
Forward returns the orientation represented by this quaternion expressed as
an forward vector.
</p>

		</span>
	
		
		<h1 id="Quat.Hpr" class="hdr pkg hdr-method"><a href="#Quat.Hpr" title="permalink">»</a>&nbsp;func (a Quat) Hpr(cs CoordSys) (hpr Vec3) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Hpr(cs CoordSys) (hpr Vec3)</pre>
			<p>
Hpr extracts the equivilent heading, pitch, and roll euler angles in radians
from the quaternion for the given coordinate system.
</p>

		</span>
	
		
		<h1 id="Quat.Inverse" class="hdr pkg hdr-method"><a href="#Quat.Inverse" title="permalink">»</a>&nbsp;func (a Quat) Inverse() Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Inverse() Quat</pre>
			<p>
Inverse returns the inverse of this quaternion.
</p>

		</span>
	
		
		<h1 id="Quat.IsNaN" class="hdr pkg hdr-method"><a href="#Quat.IsNaN" title="permalink">»</a>&nbsp;func (a Quat) IsNaN() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) IsNaN() bool</pre>
			<p>
IsNaN tells if any components of this quaternion are not an number.
</p>

		</span>
	
		
		<h1 id="Quat.Length" class="hdr pkg hdr-method"><a href="#Quat.Length" title="permalink">»</a>&nbsp;func (a Quat) Length() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Length() float64</pre>
			<p>
Length returns the magnitude of this quaternion. To avoid a sqrt call when
strictly comparing distances, LengthSq can be used instead.
</p>

		</span>
	
		
		<h1 id="Quat.LengthSq" class="hdr pkg hdr-method"><a href="#Quat.LengthSq" title="permalink">»</a>&nbsp;func (a Quat) LengthSq() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) LengthSq() float64</pre>
			<p>
LengthSq returns the magnitude squared of this quaternion, useful for comparing
distances.
</p>

		</span>
	
		
		<h1 id="Quat.Lerp" class="hdr pkg hdr-method"><a href="#Quat.Lerp" title="permalink">»</a>&nbsp;func (a Quat) Lerp(b Quat, t float64) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Lerp(b Quat, t float64) Quat</pre>
			<p>
Lerp returns a quaternion representing the linear interpolation between the
quaternions a and b. The t parameter is the amount to interpolate
(0.0 - 1.0) between the quaternions.
</p>

		</span>
	
		
		<h1 id="Quat.Max" class="hdr pkg hdr-method"><a href="#Quat.Max" title="permalink">»</a>&nbsp;func (a Quat) Max(b Quat) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Max(b Quat) Quat</pre>
			<p>
Max returns a quaternion representing the largest components of both the
quaternions.
</p>

		</span>
	
		
		<h1 id="Quat.Min" class="hdr pkg hdr-method"><a href="#Quat.Min" title="permalink">»</a>&nbsp;func (a Quat) Min(b Quat) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Min(b Quat) Quat</pre>
			<p>
Min returns a quaternion representing the smallest components of both the
quaternions.
</p>

		</span>
	
		
		<h1 id="Quat.Mul" class="hdr pkg hdr-method"><a href="#Quat.Mul" title="permalink">»</a>&nbsp;func (a Quat) Mul(b Quat) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Mul(b Quat) Quat</pre>
			<p>
Mul returns the result of the quaternion multiplication a * b.
</p>

		</span>
	
		
		<h1 id="Quat.MulScalar" class="hdr pkg hdr-method"><a href="#Quat.MulScalar" title="permalink">»</a>&nbsp;func (a Quat) MulScalar(b float64) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) MulScalar(b float64) Quat</pre>
			<p>
MulScalar performs a componentwise scalar multiplication of a * b.
</p>

		</span>
	
		
		<h1 id="Quat.Normalized" class="hdr pkg hdr-method"><a href="#Quat.Normalized" title="permalink">»</a>&nbsp;func (a Quat) Normalized() Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Normalized() Quat</pre>
			<p>
Normalized returns the normalized (i.e. length/magnitude == 1) quaternion of
a.
The quaternion a must be non-zero or else division by zero may occur.
</p>

		</span>
	
		
		<h1 id="Quat.Right" class="hdr pkg hdr-method"><a href="#Quat.Right" title="permalink">»</a>&nbsp;func (a Quat) Right(cs CoordSys) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Right(cs CoordSys) Vec3</pre>
			<p>
Right returns the orientation represented by this quaternion expressed as an
right vector.
</p>

		</span>
	
		
		<h1 id="Quat.String" class="hdr pkg hdr-method"><a href="#Quat.String" title="permalink">»</a>&nbsp;func (a Quat) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) String() string</pre>
			<p>
String returns an string representation of this vector.
</p>

		</span>
	
		
		<h1 id="Quat.Sub" class="hdr pkg hdr-method"><a href="#Quat.Sub" title="permalink">»</a>&nbsp;func (a Quat) Sub(b Quat) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Sub(b Quat) Quat</pre>
			<p>
Sub performs a componentwise subtraction of the two quaternions, returning
a - b.
</p>

		</span>
	
		
		<h1 id="Quat.SubScalar" class="hdr pkg hdr-method"><a href="#Quat.SubScalar" title="permalink">»</a>&nbsp;func (a Quat) SubScalar(b float64) Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) SubScalar(b float64) Quat</pre>
			<p>
SubScalar performs a componentwise scalar subtraction of a - b.
</p>

		</span>
	
		
		<h1 id="Quat.TransformVec3" class="hdr pkg hdr-method"><a href="#Quat.TransformVec3" title="permalink">»</a>&nbsp;func (a Quat) TransformVec3(v Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) TransformVec3(v Vec3) Vec3</pre>
			<p>
TransformVec3 transforms the 3-component vector by the specified quaternion
rotation and returns the result.
</p>

		</span>
	
		
		<h1 id="Quat.TransformVec4" class="hdr pkg hdr-method"><a href="#Quat.TransformVec4" title="permalink">»</a>&nbsp;func (a Quat) TransformVec4(v Vec4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) TransformVec4(v Vec4) Vec4</pre>
			<p>
TransformVec4 transforms the 4-component vector by the specified quaternion
rotation and returns the result.
</p>

		</span>
	
		
		<h1 id="Quat.Up" class="hdr pkg hdr-method"><a href="#Quat.Up" title="permalink">»</a>&nbsp;func (a Quat) Up(cs CoordSys) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Up(cs CoordSys) Vec3</pre>
			<p>
Up returns the orientation represented by this quaternion expressed as an up
vector.
</p>

		</span>
	
		
		<h1 id="Quat.Vec4" class="hdr pkg hdr-method"><a href="#Quat.Vec4" title="permalink">»</a>&nbsp;func (a Quat) Vec4() Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Quat) Vec4() Vec4</pre>
			<p>
Vec4 converts the quaternion into a four-component vector; Short-hand for:
</p>
<pre>Vec4{a.W, a.X, a.Y, a.Z}
</pre>

		</span>
	

	
	<h1 id="Rect3" class="hdr pkg hdr-type"><a href="#Rect3" title="permalink">»</a>&nbsp;type Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Rect3 struct {
	Min, Max Vec3
}</pre>
		<p>
Rect3 represents a 3D rectangle. Although it can be used to represent any
form of 3D rectangle, a common use is for representing axis-aligned bounding
boxes.
</p>
<p>
The rectangle contains all points where:
</p>
<pre>Min.X &lt;= X &lt; Max.X
Min.Y &lt;= Y &lt; Max.Y
Min.Z &lt;= Z &lt; Max.Z
</pre>
<p>
A rectangle is considered empty if it would contain no points.
</p>

	</span>

	
	

	
	
		
		<h1 id="Rect3.Add" class="hdr pkg hdr-method"><a href="#Rect3.Add" title="permalink">»</a>&nbsp;func (r Rect3) Add(p Vec3) Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Add(p Vec3) Rect3</pre>
			<p>
Add returns the rectangle r translated by p.
</p>

		</span>
	
		
		<h1 id="Rect3.AlmostEmpty" class="hdr pkg hdr-method"><a href="#Rect3.AlmostEmpty" title="permalink">»</a>&nbsp;func (r Rect3) AlmostEmpty(epsilon float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) AlmostEmpty(epsilon float64) bool</pre>
			<p>
AlmostEmpty reports whether the rectangle contains no points using the
specified epsilon value.
</p>

		</span>
	
		
		<h1 id="Rect3.AlmostEquals" class="hdr pkg hdr-method"><a href="#Rect3.AlmostEquals" title="permalink">»</a>&nbsp;func (r Rect3) AlmostEquals(s Rect3, epsilon float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) AlmostEquals(s Rect3, epsilon float64) bool</pre>
			<p>
AlmostEquals tells whether a is memberwise equal to b using the specified
epsilon value.
</p>

		</span>
	
		
		<h1 id="Rect3.Area" class="hdr pkg hdr-method"><a href="#Rect3.Area" title="permalink">»</a>&nbsp;func (r Rect3) Area() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Area() float64</pre>
			<p>
Area returns the area of this rectangle (the sum of it&#39;s sides).
</p>

		</span>
	
		
		<h1 id="Rect3.Canon" class="hdr pkg hdr-method"><a href="#Rect3.Canon" title="permalink">»</a>&nbsp;func (r Rect3) Canon() Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Canon() Rect3</pre>
			<p>
Canon returns the canonical version of r. The returned rectangle has minimum
and maximum coordinates swapped if necessary so that it is well-formed.
</p>

		</span>
	
		
		<h1 id="Rect3.Center" class="hdr pkg hdr-method"><a href="#Rect3.Center" title="permalink">»</a>&nbsp;func (r Rect3) Center() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Center() Vec3</pre>
			<p>
Center returns the center point of this rectangle.
</p>

		</span>
	
		
		<h1 id="Rect3.Closest" class="hdr pkg hdr-method"><a href="#Rect3.Closest" title="permalink">»</a>&nbsp;func (r Rect3) Closest(p Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Closest(p Vec3) Vec3</pre>
			<p>
Closest returns the closest point towards p contained by this rectangle.
</p>

		</span>
	
		
		<h1 id="Rect3.Contains" class="hdr pkg hdr-method"><a href="#Rect3.Contains" title="permalink">»</a>&nbsp;func (r Rect3) Contains(p Vec3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Contains(p Vec3) bool</pre>
			<p>
Contains tells if the point p is within this rectangle.
</p>

		</span>
	
		
		<h1 id="Rect3.Corners" class="hdr pkg hdr-method"><a href="#Rect3.Corners" title="permalink">»</a>&nbsp;func (r Rect3) Corners() [8]Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Corners() [8]Vec3</pre>
			<p>
Corners returns an array of the eight corner points of this 3D rectangle.
The corners are returned in the order of left to right, back to front,
bottom to top:
</p>
<pre>left,  back,  bottom
right, back,  bottom
left,  front, bottom
right, front, bottom
left,  back,  top
right, back,  top
left,  front, top
right, front, top
</pre>

		</span>
	
		
		<h1 id="Rect3.Empty" class="hdr pkg hdr-method"><a href="#Rect3.Empty" title="permalink">»</a>&nbsp;func (r Rect3) Empty() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Empty() bool</pre>
			<p>
Empty reports whether the rectangle contains no points using the default
epsilon for equality.
</p>

		</span>
	
		
		<h1 id="Rect3.Equals" class="hdr pkg hdr-method"><a href="#Rect3.Equals" title="permalink">»</a>&nbsp;func (r Rect3) Equals(s Rect3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Equals(s Rect3) bool</pre>
			<p>
Equals reports whether r and s are equal using the default epsilon for
equality.
</p>

		</span>
	
		
		<h1 id="Rect3.Furthest" class="hdr pkg hdr-method"><a href="#Rect3.Furthest" title="permalink">»</a>&nbsp;func (r Rect3) Furthest(p Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Furthest(p Vec3) Vec3</pre>
			<p>
Furthest returns the furthest point away from p contained by this rectangle.
</p>

		</span>
	
		
		<h1 id="Rect3.In" class="hdr pkg hdr-method"><a href="#Rect3.In" title="permalink">»</a>&nbsp;func (r Rect3) In(s Rect3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) In(s Rect3) bool</pre>
			<p>
In reports whether every point in r is in s.
</p>

		</span>
	
		
		<h1 id="Rect3.InSphere" class="hdr pkg hdr-method"><a href="#Rect3.InSphere" title="permalink">»</a>&nbsp;func (r Rect3) InSphere(s Sphere) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) InSphere(s Sphere) bool</pre>
			<p>
InSphere reports whether the rectangle r is completely inside the sphere s.
</p>

		</span>
	
		
		<h1 id="Rect3.Inset" class="hdr pkg hdr-method"><a href="#Rect3.Inset" title="permalink">»</a>&nbsp;func (r Rect3) Inset(n float64) Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Inset(n float64) Rect3</pre>
			<p>
Inset returns the rectangle r inset by n, which may be negative. If either
of r&#39;s dimensions is less than 2*n then an empty rectangle near the center
of r will be returned.
</p>

		</span>
	
		
		<h1 id="Rect3.Intersect" class="hdr pkg hdr-method"><a href="#Rect3.Intersect" title="permalink">»</a>&nbsp;func (r Rect3) Intersect(s Rect3) (largest Rect3, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Intersect(s Rect3) (largest Rect3, ok bool)</pre>
			<p>
Intersect intersects the two rectangles and returns the largest rectangle
that is contained by both r and s. If the two rectangles do not overlap then
Rect3Zero, ok=false will be returned.
</p>
<p>
For simple boolean tests, one should instead use the Overlaps method (as it
is equivilent and faster).
</p>

		</span>
	
		
		<h1 id="Rect3.Overlaps" class="hdr pkg hdr-method"><a href="#Rect3.Overlaps" title="permalink">»</a>&nbsp;func (r Rect3) Overlaps(s Rect3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Overlaps(s Rect3) bool</pre>
			<p>
Overlaps reports whether r and s have a non-empty intersection. It is
functionally equivilent to, but faster than:
</p>
<pre>_, overlaps := r.Intersect(s)
</pre>

		</span>
	
		
		<h1 id="Rect3.Size" class="hdr pkg hdr-method"><a href="#Rect3.Size" title="permalink">»</a>&nbsp;func (r Rect3) Size() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Size() Vec3</pre>
			<p>
Size returns a vector whose X, Y, and Z components directly relate to the
width, depth, and height of this rectangle.
</p>

		</span>
	
		
		<h1 id="Rect3.SqDistToPoint" class="hdr pkg hdr-method"><a href="#Rect3.SqDistToPoint" title="permalink">»</a>&nbsp;func (r Rect3) SqDistToPoint(p Vec3) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) SqDistToPoint(p Vec3) float64</pre>
			<p>
SqDistToPoint returns the squared distance between the point p and the
rectangle r. It is functionally equivilent to (but faster than):
</p>
<pre>dist2 := r.Closest(p).Sub(p).LengthSq()
</pre>

		</span>
	
		
		<h1 id="Rect3.String" class="hdr pkg hdr-method"><a href="#Rect3.String" title="permalink">»</a>&nbsp;func (r Rect3) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) String() string</pre>
			<p>
String returns a string representation of the rectangle r.
</p>

		</span>
	
		
		<h1 id="Rect3.Sub" class="hdr pkg hdr-method"><a href="#Rect3.Sub" title="permalink">»</a>&nbsp;func (r Rect3) Sub(p Vec3) Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Sub(p Vec3) Rect3</pre>
			<p>
Add returns the rectangle r translated by -p.
</p>

		</span>
	
		
		<h1 id="Rect3.Union" class="hdr pkg hdr-method"><a href="#Rect3.Union" title="permalink">»</a>&nbsp;func (r Rect3) Union(s Rect3) Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (r Rect3) Union(s Rect3) Rect3</pre>
			<p>
Union returns the smallest rectangle that contains both r and s.
</p>

		</span>
	

	
	<h1 id="Sphere" class="hdr pkg hdr-type"><a href="#Sphere" title="permalink">»</a>&nbsp;type Sphere <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Sphere struct {
	Center	Vec3
	Radius	float64
}</pre>
		<p>
Sphere describes a 3D sphere composed of a center point and radius.
</p>

	</span>

	
	

	
	
		
		<h1 id="Sphere.Contains" class="hdr pkg hdr-method"><a href="#Sphere.Contains" title="permalink">»</a>&nbsp;func (s Sphere) Contains(p Vec3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s Sphere) Contains(p Vec3) bool</pre>
			<p>
Contains tells if the point p is within this sphere.
</p>

		</span>
	
		
		<h1 id="Sphere.In" class="hdr pkg hdr-method"><a href="#Sphere.In" title="permalink">»</a>&nbsp;func (s Sphere) In(b Sphere) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s Sphere) In(b Sphere) bool</pre>
			<p>
In tells if the sphere s inside the sphere b.
</p>

		</span>
	
		
		<h1 id="Sphere.InRect3" class="hdr pkg hdr-method"><a href="#Sphere.InRect3" title="permalink">»</a>&nbsp;func (s Sphere) InRect3(r Rect3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s Sphere) InRect3(r Rect3) bool</pre>
			<p>
InRect3 reports whether the sphere s is completely inside the rectangle r.
It is short-hand for:
</p>
<pre>s.Rect3().In(r)
</pre>

		</span>
	
		
		<h1 id="Sphere.Overlaps" class="hdr pkg hdr-method"><a href="#Sphere.Overlaps" title="permalink">»</a>&nbsp;func (s Sphere) Overlaps(b Sphere) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s Sphere) Overlaps(b Sphere) bool</pre>
			<p>
Overlaps reports whether s and b have a non-empty intersection.
</p>

		</span>
	
		
		<h1 id="Sphere.OverlapsRect3" class="hdr pkg hdr-method"><a href="#Sphere.OverlapsRect3" title="permalink">»</a>&nbsp;func (s Sphere) OverlapsRect3(r Rect3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s Sphere) OverlapsRect3(r Rect3) bool</pre>
			<p>
OverlapsRect3 reports whether the sphere s has a non-empty intersection with
the rectangle r.
</p>

		</span>
	
		
		<h1 id="Sphere.Rect3" class="hdr pkg hdr-method"><a href="#Sphere.Rect3" title="permalink">»</a>&nbsp;func (s Sphere) Rect3() Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s Sphere) Rect3() Rect3</pre>
			<p>
Rect3 returns a 3D rectangle encapsulating this sphere.
</p>

		</span>
	

	
	<h1 id="Vec2" class="hdr pkg hdr-type"><a href="#Vec2" title="permalink">»</a>&nbsp;type Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Vec2 struct {
	X, Y float64
}</pre>
		<p>
Vec2 represents a 2D vector or point.
</p>

	</span>

	
	

	
	
		
		<h1 id="Vec2.Add" class="hdr pkg hdr-method"><a href="#Vec2.Add" title="permalink">»</a>&nbsp;func (a Vec2) Add(b Vec2) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Add(b Vec2) Vec2</pre>
			<p>
Add performs a componentwise addition of the two vectors, returning a + b.
</p>

		</span>
	
		
		<h1 id="Vec2.AddScalar" class="hdr pkg hdr-method"><a href="#Vec2.AddScalar" title="permalink">»</a>&nbsp;func (a Vec2) AddScalar(b float64) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) AddScalar(b float64) Vec2</pre>
			<p>
AddScalar performs a componentwise scalar addition of a + b.
</p>

		</span>
	
		
		<h1 id="Vec2.AlmostEquals" class="hdr pkg hdr-method"><a href="#Vec2.AlmostEquals" title="permalink">»</a>&nbsp;func (a Vec2) AlmostEquals(b Vec2, epsilon float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) AlmostEquals(b Vec2, epsilon float64) bool</pre>
			<p>
AlmostEquals tells if a == b using the specified epsilon value.
</p>

		</span>
	
		
		<h1 id="Vec2.Angle" class="hdr pkg hdr-method"><a href="#Vec2.Angle" title="permalink">»</a>&nbsp;func (a Vec2) Angle(b Vec2) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Angle(b Vec2) float64</pre>
			<p>
Angle returns the angle in radians between the two vectors.
</p>

		</span>
	
		
		<h1 id="Vec2.AnyGreater" class="hdr pkg hdr-method"><a href="#Vec2.AnyGreater" title="permalink">»</a>&nbsp;func (a Vec2) AnyGreater(b Vec2) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) AnyGreater(b Vec2) bool</pre>
			<p>
AnyGreater tells if a is componentwise any greater than b:
</p>
<pre>return a.X &gt; b.X || a.Y &gt; b.Y
</pre>

		</span>
	
		
		<h1 id="Vec2.AnyLess" class="hdr pkg hdr-method"><a href="#Vec2.AnyLess" title="permalink">»</a>&nbsp;func (a Vec2) AnyLess(b Vec2) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) AnyLess(b Vec2) bool</pre>
			<p>
AnyLess tells if a is componentwise any less than b:
</p>
<pre>return a.X &lt; b.X || a.Y &lt; b.Y
</pre>

		</span>
	
		
		<h1 id="Vec2.Clamp" class="hdr pkg hdr-method"><a href="#Vec2.Clamp" title="permalink">»</a>&nbsp;func (a Vec2) Clamp(min, max float64) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Clamp(min, max float64) Vec2</pre>
			<p>
Clamp clamps each value in the vector to the range of [min, max] and returns
it.
</p>

		</span>
	
		
		<h1 id="Vec2.Degrees" class="hdr pkg hdr-method"><a href="#Vec2.Degrees" title="permalink">»</a>&nbsp;func (a Vec2) Degrees() Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Degrees() Vec2</pre>
			<p>
Degrees converts each value in the vector from radians to degrees and
returns it.
</p>

		</span>
	
		
		<h1 id="Vec2.Div" class="hdr pkg hdr-method"><a href="#Vec2.Div" title="permalink">»</a>&nbsp;func (a Vec2) Div(b Vec2) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Div(b Vec2) Vec2</pre>
			<p>
Div performs a componentwise division of the two vectors, returning a * b.
</p>

		</span>
	
		
		<h1 id="Vec2.DivScalar" class="hdr pkg hdr-method"><a href="#Vec2.DivScalar" title="permalink">»</a>&nbsp;func (a Vec2) DivScalar(b float64) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) DivScalar(b float64) Vec2</pre>
			<p>
DivScalar performs a componentwise scalar division of a * b.
</p>

		</span>
	
		
		<h1 id="Vec2.Dot" class="hdr pkg hdr-method"><a href="#Vec2.Dot" title="permalink">»</a>&nbsp;func (a Vec2) Dot(b Vec2) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Dot(b Vec2) float64</pre>
			<p>
Dot returns the dot product of a and b.
</p>

		</span>
	
		
		<h1 id="Vec2.Equals" class="hdr pkg hdr-method"><a href="#Vec2.Equals" title="permalink">»</a>&nbsp;func (a Vec2) Equals(b Vec2) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Equals(b Vec2) bool</pre>
			<p>
Equals tells if a == b using the default EPSILON value.
</p>

		</span>
	
		
		<h1 id="Vec2.Greater" class="hdr pkg hdr-method"><a href="#Vec2.Greater" title="permalink">»</a>&nbsp;func (a Vec2) Greater(b Vec2) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Greater(b Vec2) bool</pre>
			<p>
Greater tells if a is componentwise greater than b:
</p>
<pre>return a.X &gt; b.X &amp;&amp; a.Y &gt; b.Y
</pre>

		</span>
	
		
		<h1 id="Vec2.Inverse" class="hdr pkg hdr-method"><a href="#Vec2.Inverse" title="permalink">»</a>&nbsp;func (a Vec2) Inverse() Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Inverse() Vec2</pre>
			<p>
Inverse returns the inverse (negated) vector -a.
</p>

		</span>
	
		
		<h1 id="Vec2.IsNaN" class="hdr pkg hdr-method"><a href="#Vec2.IsNaN" title="permalink">»</a>&nbsp;func (a Vec2) IsNaN() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) IsNaN() bool</pre>
			<p>
IsNaN tells if any components of this vector are not an number.
</p>

		</span>
	
		
		<h1 id="Vec2.Length" class="hdr pkg hdr-method"><a href="#Vec2.Length" title="permalink">»</a>&nbsp;func (a Vec2) Length() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Length() float64</pre>
			<p>
Length returns the magnitude of this vector. To avoid a sqrt call when
strictly comparing distances, LengthSq can be used instead.
</p>

		</span>
	
		
		<h1 id="Vec2.LengthSq" class="hdr pkg hdr-method"><a href="#Vec2.LengthSq" title="permalink">»</a>&nbsp;func (a Vec2) LengthSq() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) LengthSq() float64</pre>
			<p>
LengthSq returns the magnitude squared of this vector, useful for comparing
distances.
</p>

		</span>
	
		
		<h1 id="Vec2.Lerp" class="hdr pkg hdr-method"><a href="#Vec2.Lerp" title="permalink">»</a>&nbsp;func (a Vec2) Lerp(b Vec2, t float64) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Lerp(b Vec2, t float64) Vec2</pre>
			<p>
Lerp returns a vector representing the linear interpolation between the
vectors a and b. The t parameter is the amount to interpolate (0.0 - 1.0)
between the vectors.
</p>

		</span>
	
		
		<h1 id="Vec2.Less" class="hdr pkg hdr-method"><a href="#Vec2.Less" title="permalink">»</a>&nbsp;func (a Vec2) Less(b Vec2) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Less(b Vec2) bool</pre>
			<p>
Less tells if a is componentwise less than b:
</p>
<pre>return a.X &lt; b.X &amp;&amp; a.Y &lt; b.Y
</pre>

		</span>
	
		
		<h1 id="Vec2.Max" class="hdr pkg hdr-method"><a href="#Vec2.Max" title="permalink">»</a>&nbsp;func (a Vec2) Max(b Vec2) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Max(b Vec2) Vec2</pre>
			<p>
Max returns a vector representing the largest components of both the
vectors.
</p>

		</span>
	
		
		<h1 id="Vec2.Min" class="hdr pkg hdr-method"><a href="#Vec2.Min" title="permalink">»</a>&nbsp;func (a Vec2) Min(b Vec2) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Min(b Vec2) Vec2</pre>
			<p>
Min returns a vector representing the smallest components of both the
vectors.
</p>

		</span>
	
		
		<h1 id="Vec2.Mul" class="hdr pkg hdr-method"><a href="#Vec2.Mul" title="permalink">»</a>&nbsp;func (a Vec2) Mul(b Vec2) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Mul(b Vec2) Vec2</pre>
			<p>
Mul performs a componentwise multiplication of the two vectors, returning
a * b.
</p>

		</span>
	
		
		<h1 id="Vec2.MulScalar" class="hdr pkg hdr-method"><a href="#Vec2.MulScalar" title="permalink">»</a>&nbsp;func (a Vec2) MulScalar(b float64) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) MulScalar(b float64) Vec2</pre>
			<p>
MulScalar performs a componentwise scalar multiplication of a * b.
</p>

		</span>
	
		
		<h1 id="Vec2.Normalized" class="hdr pkg hdr-method"><a href="#Vec2.Normalized" title="permalink">»</a>&nbsp;func (a Vec2) Normalized() (v Vec2, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Normalized() (v Vec2, ok bool)</pre>
			<p>
Normalized returns the normalized (i.e. length/magnitude == 1) vector of a.
If the vector&#39;s length is zero (and division by zero would occur) then
[Vec2Zero, false] is returned.
</p>

		</span>
	
		
		<h1 id="Vec2.Proj" class="hdr pkg hdr-method"><a href="#Vec2.Proj" title="permalink">»</a>&nbsp;func (a Vec2) Proj(b Vec2) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Proj(b Vec2) Vec2</pre>
			<p>
Proj returns a vector representing the projection of vector a onto b.
</p>

		</span>
	
		
		<h1 id="Vec2.Radians" class="hdr pkg hdr-method"><a href="#Vec2.Radians" title="permalink">»</a>&nbsp;func (a Vec2) Radians() Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Radians() Vec2</pre>
			<p>
Radians converts each value in the vector from degrees to radians and
returns it.
</p>

		</span>
	
		
		<h1 id="Vec2.Rounded" class="hdr pkg hdr-method"><a href="#Vec2.Rounded" title="permalink">»</a>&nbsp;func (a Vec2) Rounded() Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Rounded() Vec2</pre>
			<p>
Rounded rounds each value in the vector to the nearest whole number and
returns it.
</p>

		</span>
	
		
		<h1 id="Vec2.String" class="hdr pkg hdr-method"><a href="#Vec2.String" title="permalink">»</a>&nbsp;func (a Vec2) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) String() string</pre>
			<p>
String returns an string representation of this vector.
</p>

		</span>
	
		
		<h1 id="Vec2.Sub" class="hdr pkg hdr-method"><a href="#Vec2.Sub" title="permalink">»</a>&nbsp;func (a Vec2) Sub(b Vec2) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) Sub(b Vec2) Vec2</pre>
			<p>
Sub performs a componentwise subtraction of the two vectors, returning
a - b.
</p>

		</span>
	
		
		<h1 id="Vec2.SubScalar" class="hdr pkg hdr-method"><a href="#Vec2.SubScalar" title="permalink">»</a>&nbsp;func (a Vec2) SubScalar(b float64) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) SubScalar(b float64) Vec2</pre>
			<p>
SubScalar performs a componentwise scalar subtraction of a - b.
</p>

		</span>
	
		
		<h1 id="Vec2.TransformPointVec2" class="hdr pkg hdr-method"><a href="#Vec2.TransformPointVec2" title="permalink">»</a>&nbsp;func (a Vec2) TransformPointVec2(b Mat3) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) TransformPointVec2(b Mat3) Vec2</pre>
			<p>
TransformPointVec2 transforms a 2-component point vector by the matrix (with
translation component) and returns the result.
This function assumes that the matrix is an affine transformation.
</p>

		</span>
	
		
		<h1 id="Vec2.TransformVec2" class="hdr pkg hdr-method"><a href="#Vec2.TransformVec2" title="permalink">»</a>&nbsp;func (a Vec2) TransformVec2(b Mat3) Vec2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec2) TransformVec2(b Mat3) Vec2</pre>
			<p>
TransformVec2 transforms a 2-component point vector by the matrix (without
translation component) and returns the result.
This function assumes that the matrix is an affine transformation.
</p>

		</span>
	

	
	<h1 id="Vec3" class="hdr pkg hdr-type"><a href="#Vec3" title="permalink">»</a>&nbsp;type Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Vec3 struct {
	X, Y, Z float64
}</pre>
		<p>
Vec3 represents a 3D vector or point.
</p>

	</span>

	
	
		<h1 id="CartToSphere" class="hdr pkg hdr-function"><a href="#CartToSphere" title="permalink">»</a>&nbsp;func CartToSphere(p Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func CartToSphere(p Vec3) Vec3</pre>
			<p>
CartToSphere converts the point in cartesian coordinate space, p, into
spherical coordinates in the form of Vec3{radiys, inclination, azimuth} and
returns it.
</p>
<p>
It is implemented according to:
</p>
<pre><a href="http://en.wikipedia.org/wiki/Spherical_coordinate_system#Cartesian_coordinates">http://en.wikipedia.org/wiki/Spherical_coordinate_system#Cartesian_coordinates</a>
</pre>

		</span>
	
		<h1 id="SphereToCart" class="hdr pkg hdr-function"><a href="#SphereToCart" title="permalink">»</a>&nbsp;func SphereToCart(r float64, p Vec2) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func SphereToCart(r float64, p Vec2) Vec3</pre>
			<p>
SphereToCart converts the Vec2{inclination, azimuth} point on a sphere of
the given radius to cartesian coordinates and returns it.
</p>
<p>
It is implemented according to:
</p>
<pre><a href="http://en.wikipedia.org/wiki/Spherical_coordinate_system#Cartesian_coordinates">http://en.wikipedia.org/wiki/Spherical_coordinate_system#Cartesian_coordinates</a>
</pre>

		</span>
	

	
	
		
		<h1 id="Vec3.Add" class="hdr pkg hdr-method"><a href="#Vec3.Add" title="permalink">»</a>&nbsp;func (a Vec3) Add(b Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Add(b Vec3) Vec3</pre>
			<p>
Add performs a componentwise addition of the two vectors, returning a + b.
</p>

		</span>
	
		
		<h1 id="Vec3.AddScalar" class="hdr pkg hdr-method"><a href="#Vec3.AddScalar" title="permalink">»</a>&nbsp;func (a Vec3) AddScalar(b float64) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) AddScalar(b float64) Vec3</pre>
			<p>
AddScalar performs a componentwise scalar addition of a + b.
</p>

		</span>
	
		
		<h1 id="Vec3.AlmostEquals" class="hdr pkg hdr-method"><a href="#Vec3.AlmostEquals" title="permalink">»</a>&nbsp;func (a Vec3) AlmostEquals(b Vec3, epsilon float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) AlmostEquals(b Vec3, epsilon float64) bool</pre>
			<p>
AlmostEquals tells if a == b using the specified epsilon value.
</p>

		</span>
	
		
		<h1 id="Vec3.Angle" class="hdr pkg hdr-method"><a href="#Vec3.Angle" title="permalink">»</a>&nbsp;func (a Vec3) Angle(b Vec3) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Angle(b Vec3) float64</pre>
			<p>
Angle returns the unsigned angle between the vectors a and b, in radians.
</p>

		</span>
	
		
		<h1 id="Vec3.AnyGreater" class="hdr pkg hdr-method"><a href="#Vec3.AnyGreater" title="permalink">»</a>&nbsp;func (a Vec3) AnyGreater(b Vec3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) AnyGreater(b Vec3) bool</pre>
			<p>
AnyGreater tells if a is componentwise any greater than b:
</p>
<pre>return a.X &gt; b.X || a.Y &gt; b.Y || a.Z &gt; b.Z
</pre>

		</span>
	
		
		<h1 id="Vec3.AnyLess" class="hdr pkg hdr-method"><a href="#Vec3.AnyLess" title="permalink">»</a>&nbsp;func (a Vec3) AnyLess(b Vec3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) AnyLess(b Vec3) bool</pre>
			<p>
AnyLess tells if a is componentwise any less than b:
</p>
<pre>return a.X &lt; b.X || a.Y &lt; b.Y || a.Z &lt; b.Z
</pre>

		</span>
	
		
		<h1 id="Vec3.Clamp" class="hdr pkg hdr-method"><a href="#Vec3.Clamp" title="permalink">»</a>&nbsp;func (a Vec3) Clamp(min, max float64) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Clamp(min, max float64) Vec3</pre>
			<p>
Clamp clamps each value in the vector to the range of [min, max] and returns
it.
</p>

		</span>
	
		
		<h1 id="Vec3.Cross" class="hdr pkg hdr-method"><a href="#Vec3.Cross" title="permalink">»</a>&nbsp;func (a Vec3) Cross(b Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Cross(b Vec3) Vec3</pre>
			<p>
Cross returns the cross product of the two vectors.
</p>

		</span>
	
		
		<h1 id="Vec3.Degrees" class="hdr pkg hdr-method"><a href="#Vec3.Degrees" title="permalink">»</a>&nbsp;func (a Vec3) Degrees() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Degrees() Vec3</pre>
			<p>
Degrees converts each value in the vector from radians to degrees and
returns it.
</p>

		</span>
	
		
		<h1 id="Vec3.Div" class="hdr pkg hdr-method"><a href="#Vec3.Div" title="permalink">»</a>&nbsp;func (a Vec3) Div(b Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Div(b Vec3) Vec3</pre>
			<p>
Div performs a componentwise division of the two vectors, returning a * b.
</p>

		</span>
	
		
		<h1 id="Vec3.DivScalar" class="hdr pkg hdr-method"><a href="#Vec3.DivScalar" title="permalink">»</a>&nbsp;func (a Vec3) DivScalar(b float64) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) DivScalar(b float64) Vec3</pre>
			<p>
DivScalar performs a componentwise scalar division of a * b.
</p>

		</span>
	
		
		<h1 id="Vec3.Dot" class="hdr pkg hdr-method"><a href="#Vec3.Dot" title="permalink">»</a>&nbsp;func (a Vec3) Dot(b Vec3) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Dot(b Vec3) float64</pre>
			<p>
Dot returns the dot product of a and b.
</p>

		</span>
	
		
		<h1 id="Vec3.Equals" class="hdr pkg hdr-method"><a href="#Vec3.Equals" title="permalink">»</a>&nbsp;func (a Vec3) Equals(b Vec3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Equals(b Vec3) bool</pre>
			<p>
Equals tells if a == b using the default EPSILON value.
</p>

		</span>
	
		
		<h1 id="Vec3.Greater" class="hdr pkg hdr-method"><a href="#Vec3.Greater" title="permalink">»</a>&nbsp;func (a Vec3) Greater(b Vec3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Greater(b Vec3) bool</pre>
			<p>
Greater tells if a is componentwise greater than b:
</p>
<pre>return a.X &gt; b.X &amp;&amp; a.Y &gt; b.Y &amp;&amp; a.Z &gt; b.Z
</pre>

		</span>
	
		
		<h1 id="Vec3.HprToXyz" class="hdr pkg hdr-method"><a href="#Vec3.HprToXyz" title="permalink">»</a>&nbsp;func (v Vec3) HprToXyz() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (v Vec3) HprToXyz() Vec3</pre>
			<p>
HprToXyz converts Hew, Pitch and Roll rotation to X, Y, and Z axis rotation.
</p>

		</span>
	
		
		<h1 id="Vec3.Inverse" class="hdr pkg hdr-method"><a href="#Vec3.Inverse" title="permalink">»</a>&nbsp;func (a Vec3) Inverse() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Inverse() Vec3</pre>
			<p>
Inverse returns the inverse (negated) vector -a.
</p>

		</span>
	
		
		<h1 id="Vec3.IsNaN" class="hdr pkg hdr-method"><a href="#Vec3.IsNaN" title="permalink">»</a>&nbsp;func (a Vec3) IsNaN() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) IsNaN() bool</pre>
			<p>
IsNaN tells if any components of this vector are not an number.
</p>

		</span>
	
		
		<h1 id="Vec3.Length" class="hdr pkg hdr-method"><a href="#Vec3.Length" title="permalink">»</a>&nbsp;func (a Vec3) Length() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Length() float64</pre>
			<p>
Length returns the magnitude of this vector. To avoid a sqrt call when
strictly comparing distances, LengthSq can be used instead.
</p>

		</span>
	
		
		<h1 id="Vec3.LengthSq" class="hdr pkg hdr-method"><a href="#Vec3.LengthSq" title="permalink">»</a>&nbsp;func (a Vec3) LengthSq() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) LengthSq() float64</pre>
			<p>
LengthSq returns the magnitude squared of this vector, useful for comparing
distances.
</p>

		</span>
	
		
		<h1 id="Vec3.Lerp" class="hdr pkg hdr-method"><a href="#Vec3.Lerp" title="permalink">»</a>&nbsp;func (a Vec3) Lerp(b Vec3, t float64) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Lerp(b Vec3, t float64) Vec3</pre>
			<p>
Lerp returns a vector representing the linear interpolation between the
vectors a and b. The t parameter is the amount to interpolate (0.0 - 1.0)
between the vectors.
</p>

		</span>
	
		
		<h1 id="Vec3.Less" class="hdr pkg hdr-method"><a href="#Vec3.Less" title="permalink">»</a>&nbsp;func (a Vec3) Less(b Vec3) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Less(b Vec3) bool</pre>
			<p>
Less tells if a is componentwise less than b:
</p>
<pre>return a.X &lt; b.X &amp;&amp; a.Y &lt; b.Y &amp;&amp; a.Z &lt; b.Z
</pre>

		</span>
	
		
		<h1 id="Vec3.Max" class="hdr pkg hdr-method"><a href="#Vec3.Max" title="permalink">»</a>&nbsp;func (a Vec3) Max(b Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Max(b Vec3) Vec3</pre>
			<p>
Max returns a vector representing the largest components of both the
vectors.
</p>

		</span>
	
		
		<h1 id="Vec3.Min" class="hdr pkg hdr-method"><a href="#Vec3.Min" title="permalink">»</a>&nbsp;func (a Vec3) Min(b Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Min(b Vec3) Vec3</pre>
			<p>
Min returns a vector representing the smallest components of both the
vectors.
</p>

		</span>
	
		
		<h1 id="Vec3.Mul" class="hdr pkg hdr-method"><a href="#Vec3.Mul" title="permalink">»</a>&nbsp;func (a Vec3) Mul(b Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Mul(b Vec3) Vec3</pre>
			<p>
Mul performs a componentwise multiplication of the two vectors, returning
a * b.
</p>

		</span>
	
		
		<h1 id="Vec3.MulScalar" class="hdr pkg hdr-method"><a href="#Vec3.MulScalar" title="permalink">»</a>&nbsp;func (a Vec3) MulScalar(b float64) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) MulScalar(b float64) Vec3</pre>
			<p>
MulScalar performs a componentwise scalar multiplication of a * b.
</p>

		</span>
	
		
		<h1 id="Vec3.Normalized" class="hdr pkg hdr-method"><a href="#Vec3.Normalized" title="permalink">»</a>&nbsp;func (a Vec3) Normalized() (v Vec3, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Normalized() (v Vec3, ok bool)</pre>
			<p>
Normalized returns the normalized (i.e. length/magnitude == 1) vector of a.
If the vector&#39;s length is zero (and division by zero would occur) then
[Vec3Zero, false] is returned.
</p>

		</span>
	
		
		<h1 id="Vec3.Proj" class="hdr pkg hdr-method"><a href="#Vec3.Proj" title="permalink">»</a>&nbsp;func (a Vec3) Proj(b Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Proj(b Vec3) Vec3</pre>
			<p>
Proj returns a vector representing the projection of vector a onto b.
</p>

		</span>
	
		
		<h1 id="Vec3.Radians" class="hdr pkg hdr-method"><a href="#Vec3.Radians" title="permalink">»</a>&nbsp;func (a Vec3) Radians() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Radians() Vec3</pre>
			<p>
Radians converts each value in the vector from degrees to radians and
returns it.
</p>

		</span>
	
		
		<h1 id="Vec3.Rounded" class="hdr pkg hdr-method"><a href="#Vec3.Rounded" title="permalink">»</a>&nbsp;func (a Vec3) Rounded() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Rounded() Vec3</pre>
			<p>
Rounded rounds each value in the vector to the nearest whole number and
returns it.
</p>

		</span>
	
		
		<h1 id="Vec3.SignedAngle" class="hdr pkg hdr-method"><a href="#Vec3.SignedAngle" title="permalink">»</a>&nbsp;func (a Vec3) SignedAngle(b, reference Vec3) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) SignedAngle(b, reference Vec3) float64</pre>
			<p>
SignedAngle returns the signed angle between the vectors a and b, in
radians.
The returned angle is positive if the rotation from a to b is clockwise when
looking in the direction of the reference vector.
</p>

		</span>
	
		
		<h1 id="Vec3.String" class="hdr pkg hdr-method"><a href="#Vec3.String" title="permalink">»</a>&nbsp;func (a Vec3) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) String() string</pre>
			<p>
String returns an string representation of this vector.
</p>

		</span>
	
		
		<h1 id="Vec3.Sub" class="hdr pkg hdr-method"><a href="#Vec3.Sub" title="permalink">»</a>&nbsp;func (a Vec3) Sub(b Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) Sub(b Vec3) Vec3</pre>
			<p>
Sub performs a componentwise subtraction of the two vectors, returning
a - b.
</p>

		</span>
	
		
		<h1 id="Vec3.SubScalar" class="hdr pkg hdr-method"><a href="#Vec3.SubScalar" title="permalink">»</a>&nbsp;func (a Vec3) SubScalar(b float64) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) SubScalar(b float64) Vec3</pre>
			<p>
SubScalar performs a componentwise scalar subtraction of a - b.
</p>

		</span>
	
		
		<h1 id="Vec3.TransformGeneralMat3" class="hdr pkg hdr-method"><a href="#Vec3.TransformGeneralMat3" title="permalink">»</a>&nbsp;func (a Vec3) TransformGeneralMat3(b Mat3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) TransformGeneralMat3(b Mat3) Vec3</pre>
			<p>
TransformGeneralMat3 transforms this vector by the matrix (vector * matrix)
without translation component, and returns the result, as a fully general
operation.
</p>

		</span>
	
		
		<h1 id="Vec3.TransformGeneralMat4" class="hdr pkg hdr-method"><a href="#Vec3.TransformGeneralMat4" title="permalink">»</a>&nbsp;func (a Vec3) TransformGeneralMat4(b Mat4) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) TransformGeneralMat4(b Mat4) Vec3</pre>
			<p>
TransformGeneralMat4 transforms this vector by the matrix (vector * matrix)
without translation component, and returns the result, as a fully general
operation.
</p>

		</span>
	
		
		<h1 id="Vec3.TransformMat3" class="hdr pkg hdr-method"><a href="#Vec3.TransformMat3" title="permalink">»</a>&nbsp;func (a Vec3) TransformMat3(b Mat3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) TransformMat3(b Mat3) Vec3</pre>
			<p>
TransformMat3 transforms this point vector by the matrix (vector * matrix),
and returns the result.
Can operate on orthonormal transformation matrices.
</p>

		</span>
	
		
		<h1 id="Vec3.TransformMat4" class="hdr pkg hdr-method"><a href="#Vec3.TransformMat4" title="permalink">»</a>&nbsp;func (a Vec3) TransformMat4(b Mat4) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) TransformMat4(b Mat4) Vec3</pre>
			<p>
TransformMat4 transforms this point vector by the affine transformation
matrix (vector * matrix) and returns the result.
The matrix parameter must be an affine transformation matrix.
</p>

		</span>
	
		
		<h1 id="Vec3.TransformVecMat4" class="hdr pkg hdr-method"><a href="#Vec3.TransformVecMat4" title="permalink">»</a>&nbsp;func (a Vec3) TransformVecMat4(b Mat4) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec3) TransformVecMat4(b Mat4) Vec3</pre>
			<p>
TransformVecMat4 transforms this vector (without translation component) by
the orthonormal matrix and returns the result.
</p>

		</span>
	
		
		<h1 id="Vec3.XyzToHpr" class="hdr pkg hdr-method"><a href="#Vec3.XyzToHpr" title="permalink">»</a>&nbsp;func (v Vec3) XyzToHpr() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (v Vec3) XyzToHpr() Vec3</pre>
			<p>
XyzToHpr converts X, Y, and Z axis rotation to Hew, Pitch, and Roll
rotation.
</p>

		</span>
	

	
	<h1 id="Vec4" class="hdr pkg hdr-type"><a href="#Vec4" title="permalink">»</a>&nbsp;type Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Vec4 struct {
	X, Y, Z, W float64
}</pre>
		<p>
Vec4 represents a four component vector.
</p>

	</span>

	
	

	
	
		
		<h1 id="Vec4.Add" class="hdr pkg hdr-method"><a href="#Vec4.Add" title="permalink">»</a>&nbsp;func (a Vec4) Add(b Vec4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Add(b Vec4) Vec4</pre>
			<p>
Add performs a componentwise addition of the two vectors, returning a + b.
</p>

		</span>
	
		
		<h1 id="Vec4.AddScalar" class="hdr pkg hdr-method"><a href="#Vec4.AddScalar" title="permalink">»</a>&nbsp;func (a Vec4) AddScalar(b float64) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) AddScalar(b float64) Vec4</pre>
			<p>
AddScalar performs a componentwise scalar addition of a + b.
</p>

		</span>
	
		
		<h1 id="Vec4.AlmostEquals" class="hdr pkg hdr-method"><a href="#Vec4.AlmostEquals" title="permalink">»</a>&nbsp;func (a Vec4) AlmostEquals(b Vec4, epsilon float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) AlmostEquals(b Vec4, epsilon float64) bool</pre>
			<p>
AlmostEquals tells if a == b using the specified epsilon value.
</p>

		</span>
	
		
		<h1 id="Vec4.AnyGreater" class="hdr pkg hdr-method"><a href="#Vec4.AnyGreater" title="permalink">»</a>&nbsp;func (a Vec4) AnyGreater(b Vec4) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) AnyGreater(b Vec4) bool</pre>
			<p>
AnyGreater tells if a is componentwise any greater than b:
</p>
<pre>return a.X &gt; b.X || a.Y &gt; b.Y || a.Z &gt; b.Z || a.W &gt; b.W
</pre>

		</span>
	
		
		<h1 id="Vec4.AnyLess" class="hdr pkg hdr-method"><a href="#Vec4.AnyLess" title="permalink">»</a>&nbsp;func (a Vec4) AnyLess(b Vec4) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) AnyLess(b Vec4) bool</pre>
			<p>
AnyLess tells if a is componentwise any less than b:
</p>
<pre>return a.X &lt; b.X || a.Y &lt; b.Y || a.Z &lt; b.Z || a.W &lt; b.W
</pre>

		</span>
	
		
		<h1 id="Vec4.Clamp" class="hdr pkg hdr-method"><a href="#Vec4.Clamp" title="permalink">»</a>&nbsp;func (a Vec4) Clamp(min, max float64) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Clamp(min, max float64) Vec4</pre>
			<p>
Clamp clamps each value in the vector to the range of [min, max] and returns
it.
</p>

		</span>
	
		
		<h1 id="Vec4.Degrees" class="hdr pkg hdr-method"><a href="#Vec4.Degrees" title="permalink">»</a>&nbsp;func (a Vec4) Degrees() Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Degrees() Vec4</pre>
			<p>
Degrees converts each value in the vector from radians to degrees and
returns it.
</p>

		</span>
	
		
		<h1 id="Vec4.Div" class="hdr pkg hdr-method"><a href="#Vec4.Div" title="permalink">»</a>&nbsp;func (a Vec4) Div(b Vec4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Div(b Vec4) Vec4</pre>
			<p>
Div performs a componentwise division of the two vectors, returning a * b.
</p>

		</span>
	
		
		<h1 id="Vec4.DivScalar" class="hdr pkg hdr-method"><a href="#Vec4.DivScalar" title="permalink">»</a>&nbsp;func (a Vec4) DivScalar(b float64) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) DivScalar(b float64) Vec4</pre>
			<p>
DivScalar performs a componentwise scalar division of a * b.
</p>

		</span>
	
		
		<h1 id="Vec4.Dot" class="hdr pkg hdr-method"><a href="#Vec4.Dot" title="permalink">»</a>&nbsp;func (a Vec4) Dot(b Vec4) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Dot(b Vec4) float64</pre>
			<p>
Dot returns the dot product of a and b.
</p>

		</span>
	
		
		<h1 id="Vec4.Equals" class="hdr pkg hdr-method"><a href="#Vec4.Equals" title="permalink">»</a>&nbsp;func (a Vec4) Equals(b Vec4) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Equals(b Vec4) bool</pre>
			<p>
Equals tells if a == b using the default EPSILON value.
</p>

		</span>
	
		
		<h1 id="Vec4.Greater" class="hdr pkg hdr-method"><a href="#Vec4.Greater" title="permalink">»</a>&nbsp;func (a Vec4) Greater(b Vec4) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Greater(b Vec4) bool</pre>
			<p>
Greater tells if a is componentwise greater than b:
</p>
<pre>return a.X &gt; b.X &amp;&amp; a.Y &gt; b.Y
</pre>

		</span>
	
		
		<h1 id="Vec4.IsNaN" class="hdr pkg hdr-method"><a href="#Vec4.IsNaN" title="permalink">»</a>&nbsp;func (a Vec4) IsNaN() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) IsNaN() bool</pre>
			<p>
IsNaN tells if any components of this vector are not an number.
</p>

		</span>
	
		
		<h1 id="Vec4.Length" class="hdr pkg hdr-method"><a href="#Vec4.Length" title="permalink">»</a>&nbsp;func (a Vec4) Length() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Length() float64</pre>
			<p>
Length returns the magnitude of this vector. To avoid a sqrt call when
strictly comparing distances, LengthSq can be used instead.
</p>

		</span>
	
		
		<h1 id="Vec4.LengthSq" class="hdr pkg hdr-method"><a href="#Vec4.LengthSq" title="permalink">»</a>&nbsp;func (a Vec4) LengthSq() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) LengthSq() float64</pre>
			<p>
LengthSq returns the magnitude squared of this vector, useful for comparing
distances.
</p>

		</span>
	
		
		<h1 id="Vec4.Lerp" class="hdr pkg hdr-method"><a href="#Vec4.Lerp" title="permalink">»</a>&nbsp;func (a Vec4) Lerp(b Vec4, t float64) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Lerp(b Vec4, t float64) Vec4</pre>
			<p>
Lerp returns a vector representing the linear interpolation between the
vectors a and b. The t parameter is the amount to interpolate (0.0 - 1.0)
between the vectors.
</p>

		</span>
	
		
		<h1 id="Vec4.Less" class="hdr pkg hdr-method"><a href="#Vec4.Less" title="permalink">»</a>&nbsp;func (a Vec4) Less(b Vec4) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Less(b Vec4) bool</pre>
			<p>
Less tells if a is componentwise less than b:
</p>
<pre>return a.X &lt; b.X &amp;&amp; a.Y &lt; b.Y
</pre>

		</span>
	
		
		<h1 id="Vec4.Max" class="hdr pkg hdr-method"><a href="#Vec4.Max" title="permalink">»</a>&nbsp;func (a Vec4) Max(b Vec4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Max(b Vec4) Vec4</pre>
			<p>
Max returns a vector representing the largest components of both the
vectors.
</p>

		</span>
	
		
		<h1 id="Vec4.Min" class="hdr pkg hdr-method"><a href="#Vec4.Min" title="permalink">»</a>&nbsp;func (a Vec4) Min(b Vec4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Min(b Vec4) Vec4</pre>
			<p>
Min returns a vector representing the smallest components of both the
vectors.
</p>

		</span>
	
		
		<h1 id="Vec4.Mul" class="hdr pkg hdr-method"><a href="#Vec4.Mul" title="permalink">»</a>&nbsp;func (a Vec4) Mul(b Vec4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Mul(b Vec4) Vec4</pre>
			<p>
Mul performs a componentwise multiplication of the two vectors, returning
a * b.
</p>

		</span>
	
		
		<h1 id="Vec4.MulScalar" class="hdr pkg hdr-method"><a href="#Vec4.MulScalar" title="permalink">»</a>&nbsp;func (a Vec4) MulScalar(b float64) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) MulScalar(b float64) Vec4</pre>
			<p>
MulScalar performs a componentwise scalar multiplication of a * b.
</p>

		</span>
	
		
		<h1 id="Vec4.Normalized" class="hdr pkg hdr-method"><a href="#Vec4.Normalized" title="permalink">»</a>&nbsp;func (a Vec4) Normalized() (v Vec4, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Normalized() (v Vec4, ok bool)</pre>
			<p>
Normalized returns the normalized (i.e. length/magnitude == 1) vector of a.
If the vector&#39;s length is zero (and division by zero would occur) then
[Vec4Zero, false] is returned.
</p>

		</span>
	
		
		<h1 id="Vec4.Proj" class="hdr pkg hdr-method"><a href="#Vec4.Proj" title="permalink">»</a>&nbsp;func (a Vec4) Proj(b Vec4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Proj(b Vec4) Vec4</pre>
			<p>
Proj returns a vector representing the projection of vector a onto b.
</p>

		</span>
	
		
		<h1 id="Vec4.Quat" class="hdr pkg hdr-method"><a href="#Vec4.Quat" title="permalink">»</a>&nbsp;func (a Vec4) Quat() Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Quat() Quat</pre>
			<p>
Quat converts this vector to a quaternion. It&#39;s short-hand for:
</p>
<pre>Quat{a.X, a.Y, a.Z, a.W}
</pre>

		</span>
	
		
		<h1 id="Vec4.Radians" class="hdr pkg hdr-method"><a href="#Vec4.Radians" title="permalink">»</a>&nbsp;func (a Vec4) Radians() Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Radians() Vec4</pre>
			<p>
Radians converts each value in the vector from degrees to radians and
returns it.
</p>

		</span>
	
		
		<h1 id="Vec4.Rounded" class="hdr pkg hdr-method"><a href="#Vec4.Rounded" title="permalink">»</a>&nbsp;func (a Vec4) Rounded() Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Rounded() Vec4</pre>
			<p>
Rounded rounds each value in the vector to the nearest whole number and
returns it.
</p>

		</span>
	
		
		<h1 id="Vec4.String" class="hdr pkg hdr-method"><a href="#Vec4.String" title="permalink">»</a>&nbsp;func (a Vec4) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) String() string</pre>
			<p>
String returns an string representation of this vector.
</p>

		</span>
	
		
		<h1 id="Vec4.Sub" class="hdr pkg hdr-method"><a href="#Vec4.Sub" title="permalink">»</a>&nbsp;func (a Vec4) Sub(b Vec4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Sub(b Vec4) Vec4</pre>
			<p>
Sub performs a componentwise subtraction of the two vectors, returning
a - b.
</p>

		</span>
	
		
		<h1 id="Vec4.SubScalar" class="hdr pkg hdr-method"><a href="#Vec4.SubScalar" title="permalink">»</a>&nbsp;func (a Vec4) SubScalar(b float64) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) SubScalar(b float64) Vec4</pre>
			<p>
SubScalar performs a componentwise scalar subtraction of a - b.
</p>

		</span>
	
		
		<h1 id="Vec4.Transform" class="hdr pkg hdr-method"><a href="#Vec4.Transform" title="permalink">»</a>&nbsp;func (a Vec4) Transform(b Mat4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Transform(b Mat4) Vec4</pre>
			<p>
Transform transforms this vector by the matrix (vector * matrix) and returns
the result.
This is an fully general operation.
</p>

		</span>
	
		
		<h1 id="Vec4.Vec3" class="hdr pkg hdr-method"><a href="#Vec4.Vec3" title="permalink">»</a>&nbsp;func (a Vec4) Vec3() Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a Vec4) Vec3() Vec3</pre>
			<p>
Vec3 converts this four-component vector to a three-component one. It&#39;s
short-hand for:
</p>
<pre>Vec3{a.X, a.Y, a.Z}
</pre>

		</span>
	



<h1 id="package-files" class="hdr pkg hdr-files"><a href="#package-files" title="permalink">»</a>&nbsp;Package Files <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg files">
	<p>
	<a href="https:/github.com/azul3d/lmath/blob/dev/coordsys.go" title="view source">coordsys.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/doc.go" title="view source">doc.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/mat3.go" title="view source">mat3.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/mat4.go" title="view source">mat4.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/math.go" title="view source">math.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/quat.go" title="view source">quat.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/rect3.go" title="view source">rect3.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/sphere.go" title="view source">sphere.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/vec2.go" title="view source">vec2.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/vec3.go" title="view source">vec3.go</a>
	
	<a href="https:/github.com/azul3d/lmath/blob/dev/vec4.go" title="view source">vec4.go</a>
	</p>

	<h2><span class="linkarea">(<a href="#" id="tagged-files-toggle">show tagged files</a>)</span></h2>
	<span id="tagged-files">
		<h2>Test Files</h2>
		<p>
		<a href="https:/github.com/azul3d/lmath/blob/dev/mat3_test.go" title="view source">mat3_test.go</a>
		
		<a href="https:/github.com/azul3d/lmath/blob/dev/mat4_test.go" title="view source">mat4_test.go</a>
		
		<a href="https:/github.com/azul3d/lmath/blob/dev/quat_test.go" title="view source">quat_test.go</a>
		
		<a href="https:/github.com/azul3d/lmath/blob/dev/rect3_test.go" title="view source">rect3_test.go</a>
		
		<a href="https:/github.com/azul3d/lmath/blob/dev/vec2_test.go" title="view source">vec2_test.go</a>
		
		<a href="https:/github.com/azul3d/lmath/blob/dev/vec3_test.go" title="view source">vec3_test.go</a>
		
		<a href="https:/github.com/azul3d/lmath/blob/dev/vec4_test.go" title="view source">vec4_test.go</a>
		</p>
	</span>
</span>


<script>
$(function() {
	$("#tagged-files").slideUp();
	var toggle = true;
	$("#tagged-files-toggle").click(function(event) {
		event.preventDefault();
		toggle = !toggle;
		if(toggle) {
			$("#tagged-files").slideUp();
			$("#tagged-files-toggle").html("show tagged files");
		} else {
			$("#tagged-files").slideDown();
			$("#tagged-files-toggle").html("hide tagged files");
		}
	});
});
</script>

	</div>
</div>


<div id="footer">
	<div>© 2014 The Azul3D Authors, All Rights Reserved.</div>
	<div>Unless noted otherwise, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code is licensed under a BSD license.</div>
</div>


<script>
$(document).ready(function() {
	$("body").css("opacity", 0);

	 
	var ValidIpAddressRegex = "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$";
	var redirect = window.location.hostname != 'azul3d.org';
	if(location.hostname == "localhost" || location.hostname.search(ValidIpAddressRegex) != -1) {
		
		
		redirect = false;
	}
	if(redirect){
	    window.top.location.href = 'http://azul3d.org'; 
	}
});

$(window).ready(function() {
	var fadeIn = function(self, delay) {
		self.css("opacity", 0).delay(delay).animate({opacity: 1}, "slow");
	}

	var fromSameSite = document.referrer.indexOf(location.protocol + "//" + location.host) === 0;


	
	
	var longPage = $(document).height() > $(window).height() * 3;
	if(fromSameSite || longPage) {
		fadeIn($("body"), 10);
	} else {
		var workingIndex = 0;
		var speed = 75;
		$("#content").children().each(function(index) {
			fadeIn($(this), 1000 + (speed * workingIndex));
			workingIndex++;
			if($(this).hasClass("list")) {
				$(this).children().each(function(index) {
					fadeIn($(this), 1000 + (speed * workingIndex));
					workingIndex++;
				});
			}
		});

		var w = $("#shortbar").width();
		$("#shortbar").css({
			right: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			right: "0px",
			opacity: 1
			}, "slow");

		var w = $("#navigation").width();
		$("#navigation").css({
			left: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			left: "0px",
			opacity: 1
			}, "slow");

		fadeIn($("#logo"), 10);
		fadeIn($("body"), 10);
	}
})
</script>
	</body>
</html>



