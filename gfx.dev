

<!DOCTYPE html>
<html lang="en">
	<head>
		
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<meta name="description" content="A 3D game engine written in Go!">
		<meta name="author" content="The Azul3D Authors">
		<title>Azul3D</title>
		<link rel="shortcut icon" href="/content/favicon.png"> 

		
		<link rel="stylesheet" type="text/css" href="/content/reset.css">

		
		<link href='http://fonts.googleapis.com/css?family=Audiowide' rel='stylesheet' type='text/css'>
		<link href='http://fonts.googleapis.com/css?family=Cutive+Mono' rel='stylesheet' type='text/css'>

		
		<link href='/content/dejavusans_book/stylesheet.css' rel='stylesheet' type='text/css'>

		
		<link href='/content/brandico/brandico.css' rel='stylesheet' type='text/css'>

		
		

		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

		
		<link rel="stylesheet" type="text/css" href="/content/stylesheet.css">
		<link rel="stylesheet" type="text/css" href="/content/mq.css">
	</head>
	<body>


<div id="top"></div>






































<div id="toparea">
	<div id="logo">
		<a href="/"><span class="biohazard">☣</span>
		<span>Azul3D</span></a>
	</div>

	<div id="shortbar">
		<a href="https://github.com/azul3d" target="_blank"><i class="icon-github menuIcon"></i><div class="title">GitHub</div></a>
		<a href="https://twitter.com/hashtag/azul3d" target="_blank"><i class="icon-twitter-bird menuIcon"></i><div class="title">Twitter</div></a>
		<a href="https://www.facebook.com/pages/Azul3D/651643168254798" target="_blank"><i class="icon-facebook menuIcon"></i><div class="title">Facebook</div></a>
		<a href="https://groups.google.com/forum/#!forum/azul3d" target="_blank" class="mail"><i class="menuIcon mailIcon">✉</i><div class="title">Mailing List</div></a>
	</div>
</div>

<div id="navigation">
	<h1>Navigation</h1>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/">Home</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/news">News</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/packages.html">Packages</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/doc/faq.html">FAQ</a></span></span>
	</span>
</div>


<div id="content-container">
	<div id="content" class="pkg-content">






<h1 class="hdr pkg hdr-general">Package gfx</h1>
<span class="section pkg general">
	
		<p><em>In Development</em></p>
	
	<span class="pkg import">import "azul3d.org/gfx.dev"</span>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#versions">Versions</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#overview">Overview</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#index">Index</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#package-files">Package Files</a></span></span>
	</span>
	
		<h2>WARNING!</h2>
		<span class="sub">
			
				<p>This version is the in-development -- <em><strong>unstable</strong></em> -- version of this package. Backwards incompatible changes will be made to this package in the future and as such <em>you should not use this version</em>! Please use the latest release <a href="/gfx.v1">here</a>.</p>
			
		</span>
	

	
</span>



<h1 id="versions" class="hdr pkg hdr-versions"><a href="#versions" title="permalink">»</a>&nbsp;Versions <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg versions">
	
		<p>You are viewing an older version of this package (dev).</p>
	
	<p>Other versions of this package are available as follows. <em>Dev</em> is the in-development version of this package and should not generally be used (see <a href="/doc/versioning.html#development-versions">here</a> for more details).</p>
	<span class="list">
		
			
			
			
				
					<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="gfx.v1" title="azul3d.org/gfx.v1">v1</a> (latest version)</span></span>
				
			
		
			
			
			
				<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="gfx.dev" title="azul3d.org/gfx.dev">dev</a> (in development)</span></span>
			
		
	</span>
</span>



<h1 id="overview" class="hdr pkg hdr-overview"><a href="#overview" title="permalink">»</a>&nbsp;Overview <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg overview">
	<p>
Package gfx provides generic interfaces to GPU-based rendering techniques.
</p>
<p>
This package is not useful by itself but instead part of a larger picture as
this package provides generic interfaces and data types to modern graphics
rendering API&#39;s such as OpenGL, OpenGL ES, WebGL, Direct3D, etc.
</p>
<p>
The coordinate system used by this package is the right-handed Z up
coordinate system unless explicitly specified otherwise.
</p>
<p>
Texture coordinates do not follow OpenGL convention where the origin (0, 0)
is the bottom-left, instead the origin (0, 0) is the top-left because:
</p>
<pre>1. Go&#39;s image package uses top-left as the origin.

2. If we followed OpenGL convention we would have to flip the image or
   texture coordinates on the CPU before upload to the GPU or in each
   shader.
</pre>

</span>


<h1 id="index" class="hdr pkg hdr-index"><a href="#index" title="permalink">»</a>&nbsp;Index <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg index">
	<span class="list">
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#constants">Constants</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#variables">Variables</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#InsertionSort">func InsertionSort(data sort.Interface)</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#AlphaMode">type AlphaMode</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#AlphaMode.String">func (m AlphaMode) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BlendEq">type BlendEq</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BlendOp">type BlendOp</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BlendState">type BlendState</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BlendState.Compare">func (b BlendState) Compare(other BlendState) bool</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Boundable">type Boundable</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Bounds">type Bounds</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Bounds.Bounds">func (b Bounds) Bounds() lmath.Rect3</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ByDist">type ByDist</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ByDist.Len">func (b ByDist) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ByDist.Less">func (b ByDist) Less(ii, jj int) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ByDist.Swap">func (b ByDist) Swap(i, j int)</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ByState">type ByState</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ByState.Len">func (b ByState) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ByState.Less">func (b ByState) Less(i, j int) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ByState.Swap">func (b ByState) Swap(i, j int)</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Camera">type Camera</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NewCamera">func NewCamera() *Camera</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Camera.Copy">func (c *Camera) Copy() *Camera</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Camera.Destroy">func (c *Camera) Destroy()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Camera.Project">func (c *Camera) Project(p3 lmath.Vec3) (p2 lmath.Vec2, ok bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Camera.Reset">func (c *Camera) Reset()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Camera.SetOrtho">func (c *Camera) SetOrtho(view image.Rectangle, near, far float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Camera.SetPersp">func (c *Camera) SetPersp(view image.Rectangle, fov, near, far float64)</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Canvas">type Canvas</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Cmp">type Cmp</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Color">type Color</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Color.RGBA">func (c Color) RGBA() (r, g, b, a uint32)</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CoordConv">type CoordConv</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DSFormat">type DSFormat</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DSFormat.DepthBits">func (f DSFormat) DepthBits() uint8</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DSFormat.IsCombined">func (f DSFormat) IsCombined() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DSFormat.IsDepth">func (f DSFormat) IsDepth() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DSFormat.IsStencil">func (f DSFormat) IsStencil() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DSFormat.StencilBits">func (f DSFormat) StencilBits() uint8</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DSFormat.String">func (t DSFormat) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Destroyable">type Destroyable</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Downloadable">type Downloadable</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#FaceCullMode">type FaceCullMode</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#FaceCullMode.String">func (f FaceCullMode) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GPUInfo">type GPUInfo</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4">type Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ConvertMat4">func ConvertMat4(m lmath.Mat4) Mat4</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat4.Mat4">func (m Mat4) Mat4() lmath.Mat4</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mesh">type Mesh</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NewMesh">func NewMesh() *Mesh</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mesh.Bounds">func (m *Mesh) Bounds() lmath.Rect3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mesh.CalculateBounds">func (m *Mesh) CalculateBounds()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mesh.ClearData">func (m *Mesh) ClearData()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mesh.Copy">func (m *Mesh) Copy() *Mesh</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mesh.Destroy">func (m *Mesh) Destroy()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mesh.GenerateBary">func (m *Mesh) GenerateBary()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mesh.HasChanged">func (m *Mesh) HasChanged() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mesh.Reset">func (m *Mesh) Reset()</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeMesh">type NativeMesh</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeObject">type NativeObject</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeShader">type NativeShader</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeTexture">type NativeTexture</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Object">type Object</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NewObject">func NewObject() *Object</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Object.Bounds">func (o *Object) Bounds() lmath.Rect3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Object.Compare">func (o *Object) Compare(other *Object) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Object.Copy">func (o *Object) Copy() *Object</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Object.Destroy">func (o *Object) Destroy()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Object.Reset">func (o *Object) Reset()</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Precision">type Precision</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RTTConfig">type RTTConfig</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RTTConfig.Valid">func (c RTTConfig) Valid() bool</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RTTFormats">type RTTFormats</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RTTFormats.Choose">func (f RTTFormats) Choose(p Precision, compression bool) (color TexFormat, depth, stencil DSFormat)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RTTFormats.ChooseConfig">func (f RTTFormats) ChooseConfig(p Precision, compression bool) RTTConfig</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Renderer">type Renderer</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Nil">func Nil() Renderer</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shader">type Shader</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NewShader">func NewShader(name string) *Shader</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shader.ClearData">func (s *Shader) ClearData()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shader.Copy">func (s *Shader) Copy() *Shader</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shader.Destroy">func (s *Shader) Destroy()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shader.Reset">func (s *Shader) Reset()</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#State">type State</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#State.Compare">func (s State) Compare(other State) bool</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#StencilOp">type StencilOp</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#StencilState">type StencilState</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#StencilState.Compare">func (s StencilState) Compare(other StencilState) bool</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexCoord">type TexCoord</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexCoordSet">type TexCoordSet</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexFilter">type TexFilter</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexFilter.Mipmapped">func (t TexFilter) Mipmapped() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexFilter.String">func (t TexFilter) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexFormat">type TexFormat</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexFormat.Bits">func (t TexFormat) Bits() (r, g, b, a uint8)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexFormat.String">func (t TexFormat) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexWrap">type TexWrap</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TexWrap.String">func (t TexWrap) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Texture">type Texture</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NewTexture">func NewTexture() *Texture</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Texture.ClearData">func (t *Texture) ClearData()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Texture.Copy">func (t *Texture) Copy() *Texture</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Texture.Destroy">func (t *Texture) Destroy()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Texture.Reset">func (t *Texture) Reset()</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform">type Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NewTransform">func NewTransform() *Transform</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Convert">func (t *Transform) Convert(c CoordConv) lmath.Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.ConvertPos">func (t *Transform) ConvertPos(p lmath.Vec3, c CoordConv) lmath.Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.ConvertRot">func (t *Transform) ConvertRot(r lmath.Vec3, c CoordConv) lmath.Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Copy">func (t *Transform) Copy() *Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Destroy">func (t *Transform) Destroy()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Equals">func (t *Transform) Equals(other *Transform) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.IsQuat">func (t *Transform) IsQuat() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.LocalMat4">func (t *Transform) LocalMat4() lmath.Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Mat4">func (t *Transform) Mat4() lmath.Mat4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.New">func (t *Transform) New() *Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Parent">func (t *Transform) Parent() Transformable</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Pos">func (t *Transform) Pos() lmath.Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Quat">func (t *Transform) Quat() lmath.Quat</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Reset">func (t *Transform) Reset()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Rot">func (t *Transform) Rot() lmath.Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Scale">func (t *Transform) Scale() lmath.Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.SetParent">func (t *Transform) SetParent(p Transformable)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.SetPos">func (t *Transform) SetPos(p lmath.Vec3)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.SetQuat">func (t *Transform) SetQuat(q lmath.Quat)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.SetRot">func (t *Transform) SetRot(r lmath.Vec3)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.SetScale">func (t *Transform) SetScale(s lmath.Vec3)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.SetShear">func (t *Transform) SetShear(s lmath.Vec3)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Shear">func (t *Transform) Shear() lmath.Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Transform">func (t *Transform) Transform() *Transform</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transformable">type Transformable</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3">type Vec3</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ConvertVec3">func ConvertVec3(v lmath.Vec3) Vec3</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec3.Vec3">func (v Vec3) Vec3() lmath.Vec3</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4">type Vec4</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ConvertVec4">func ConvertVec4(v lmath.Vec4) Vec4</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vec4.Vec4">func (v Vec4) Vec4() lmath.Vec4</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#VertexAttrib">type VertexAttrib</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#VertexAttrib.Copy">func (a VertexAttrib) Copy() VertexAttrib</a></span></span>
			
		
	</span>
</span>




<h1 id="constants" class="hdr pkg hdr-constants"><a href="#constants" title="permalink">»</a>&nbsp;Constants <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg constants">
	
		<pre>const (
	// NoAlpha means the object should be drawn without transparency. Parts
	// of the object that would normally be drawn as transparent will be drawn
	// as an opaque black color instead.
	NoAlpha	AlphaMode	= iota

	// AlphaBlend means the object should be drawn with alpha-blended
	// transparency. This type of transparency works well for most (but not
	// all) cases.
	//
	// Pros:
	//     Pixels can be semi-transparent.
	//
	// Cons:
	//     Render order dependant. Opaque objects mut be drawn before
	//     transparent ones due to the way alpha blending works.
	//
	//     Does not work well with self-occluding transparent objects (e.g. a
	//     cube where all faces are semi-transparent) because individual faces
	//     would have to be sorted for correct order -- which is not feasible
	//     in realtime applications.
	//
	AlphaBlend

	// BinaryAlpha means the object should be drawn with binary transparency,
	// this causes transparency to be thought of as a &#39;binary&#39; decision, where
	// each pixel is either fully transparent or opaque.
	//
	// Pixels with an alpha value of less than 0.5 are considered fully
	// transparent (invisible), and likewise pixels with an alpha value of
	// greater than or equal to 0.5 are considered fully opaque (solid,
	// non-transparent).
	//
	// Pros:
	//     Render order independent. Regardless of the order objects are drawn
	//     the result will look the same (unlike AlphaBlend).
	//
	// Cons:
	//     Jagged-looking edges because pixels may not be semi-transparent.
	//
	BinaryAlpha

	// AlphaToCoverage means the object should be drawn using alpha-to-coverage
	// with special multisample bits.
	//
	// Pros:
	//     Render order independent. Regardless of the order objects are drawn
	//     the result will look the same (unlike AlphaBlend).
	//
	//     No jagged-looking edges, pixels may be semi-transparent (unlike
	//     BinaryAlpha).
	//
	// Cons:
	//     Only some newer hardware supports it (in the event that hardware
	//     does not support it the fallback used is BinaryAlpha because it also
	//     does not suffer from render ordering issues, although it does cause
	//     jagged-looking edges).
	AlphaToCoverage
)</pre>
		<p></p>
	
		<pre>const (
	// BAdd represents a blending equation where the src and dst colors are
	// added to eachother to produce the result.
	BAdd	BlendEq	= iota

	// BSub represents a blending equation where the src and dst colors are
	// subtracted from eachother to produce the result.
	BSub

	// BReverseSub represents a blending equation where the src and dst colors
	// are reverse-subtracted from eachother to produce the result.
	BReverseSub
)</pre>
		<p></p>
	
		<pre>const (
	BZero	BlendOp	= iota
	BOne
	BSrcColor
	BOneMinusSrcColor
	BDstColor
	BOneMinusDstColor
	BSrcAlpha
	BOneMinusSrcAlpha
	BDstAlpha
	BOneMinusDstAlpha
	BConstantColor
	BOneMinusConstantColor
	BConstantAlpha
	BOneMinusConstantAlpha

	// Not applicable for use in BlendState.SrcRGB.
	BSrcAlphaSaturate
)</pre>
		<p></p>
	
		<pre>const (
	// Always is like Go&#39;s &#39;true&#39;, for example:
	//  if true {
	//      ...
	//  }
	Always	Cmp	= iota

	// Never is like Go&#39;s &#39;false&#39;, for example:
	//  if false {
	//      ...
	//  }
	Never

	// Less is like Go&#39;s &#39;&lt;&#39;, for example:
	//  if a &lt; b {
	//      ...
	//  }
	Less

	// LessOrEqual is like Go&#39;s &#39;&lt;=&#39;, for example:
	//  if a &lt;= b {
	//      ...
	//  }
	LessOrEqual

	// Greater is like Go&#39;s &#39;&gt;&#39;, for example:
	//  if a &gt; b {
	//      ...
	//  }
	Greater

	// GreaterOrEqual is like Go&#39;s &#39;&gt;=&#39;, for example:
	//  if a &gt;= b {
	//      ...
	//  }
	GreaterOrEqual

	// Equal is like Go&#39;s &#39;==&#39;, for example:
	//  if a == b {
	//      ...
	//  }
	Equal

	// NotEqual is like Go&#39;s &#39;!=&#39;, for example:
	//  if a != b {
	//      ...
	//  }
	NotEqual
)</pre>
		<p></p>
	
		<pre>const (
	// LocalToWorld converts from local space to world space.
	LocalToWorld	CoordConv	= iota

	// WorldToLocal converts from world space to local space.
	WorldToLocal

	// ParentToWorld converts from parent space to world space.
	ParentToWorld

	// WorldToParent converts from world space to parent space.
	WorldToParent
)</pre>
		<p></p>
	
		<pre>const (
	// Zero-value depth/stencil format. Used to represent nil/none/zero.
	ZeroDSFormat	DSFormat	= iota

	// The 16-bit depth buffer format.
	Depth16

	// The 24-bit depth buffer format.
	Depth24

	// The 32-bit depth buffer format.
	Depth32

	// The 24-bit depth buffer, combined with 8-bit stencil buffer format.
	Depth24AndStencil8
)</pre>
		<p></p>
	
		<pre>const (
	// Culls only back faces (i.e. only the front side is rendered).
	BackFaceCulling	FaceCullMode	= iota

	// Culls only front faces (i.e. only the back side is rendered).
	FrontFaceCulling

	// Does not cull any faces (i.e. both sides are rendered).
	NoFaceCulling
)</pre>
		<p></p>
	
		<pre>const (
	// SKeep keeps the existing stencil data.
	SKeep	StencilOp	= iota

	// SZero sets the stencil data to zero.
	SZero

	// SReplace replaces the existing stencil data with the stencil reference
	// value.
	SReplace

	// SIncr increments the stencil value by one and clamps the result.
	SIncr

	// SIncrWrap increments the stencil value by 1 and wraps the result if
	// necessary.
	SIncrWrap

	// SDecr decrements the stencil value by one and clamps the result.
	SDecr

	// SDecrWrap decrements the stencil value by 1 and wraps the result if
	// necessary.
	SDecrWrap

	// SInvert inverts the stencil data.
	SInvert
)</pre>
		<p></p>
	
		<pre>const (
	// Samples the nearest pixel.
	Nearest	TexFilter	= iota

	// Samples the four closest pixels and linearly interpolates them.
	Linear

	// Samples point from the closest mipmap. May not be used as a magnification
	// filter.
	NearestMipmapNearest

	// Bilinear filter the pixel from the closest mipmap. May not be used as a
	// magnification filter.
	LinearMipmapNearest

	// Samples the pixel from two closest mipmaps, and linearly blends. May not
	// be used as a magnification filter.
	NearestMipmapLinear

	// (Trilinear filtering) Bilinearly filters the pixel from two mipmaps, and
	// linearly blends the result. May not be used as a magnification filter.
	LinearMipmapLinear
)</pre>
		<p></p>
	
		<pre>const (
	// Zero-value texture format. Used to represent nil/none/zero.
	ZeroTexFormat	TexFormat	= iota

	// RGBA is a standard 32-bit premultiplied alpha image format.
	RGBA

	// RGB is a standard 24-bit RGB image format with no alpha component.
	RGB

	// DXT1 is a DXT1 texture compression format in RGB form (i.e. fully
	// opaque) each 4x4 block of pixels take up 64-bits of data, as such when
	// compared to a standard 24-bit RGB format it provides a 6:1 compression
	// ratio.
	DXT1

	// DXT1RGBA is a DXT1 texture compression format in RGBA form with 1 bit
	// reserved for alpha (i.e. fully transparent or fully opaque per-pixel
	// transparency).
	DXT1RGBA

	// DXT3 is a RGBA texture compression format with four bits per pixel
	// reserved for alpha. Each 4x4 block of pixels take up 128-bits of data,
	// as such when compared to a standard 32-bit RGBA format it provides a 4:1
	// compression ratio. Color information stored in DXT3 is mostly the same
	// as DXT1.
	DXT3

	// DXT5 is a RGBA format similar to DXT3 except it compresses the alpha
	// chunk in a similar manner to DXT1&#39;s color storage. It provides the same
	// 4:1 compression ratio as DXT3.
	DXT5
)</pre>
		<p></p>
	
		<pre>const (
	// The extra area of the texture is repeated into infinity.
	Repeat	TexWrap	= iota

	// The extra area of the texture is represented by stretching the edge
	// pixels out into infinity.
	Clamp

	// The extra area of the texture is represented by the border color
	// specified on the texture object.
	BorderColor

	// The extra area of the texture is represented by itself mirrored into
	// infinity.
	Mirror
)</pre>
		<p></p>
	
</span>





<h1 id="variables" class="hdr pkg hdr-variables"><a href="#variables" title="permalink">»</a>&nbsp;Variables <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg variables">
	
		<pre>var ColorModel color.Model = color.ModelFunc(colorModel)</pre>
		<p>ColorModel represents the graphics color model (i.e. normalized 32-bit
floating point values RGBA color).
</p>
	
		<pre>var DefaultBlendState = BlendState{
	Color:		Color{0, 0, 0, 0},
	SrcRGB:		BOne,
	SrcAlpha:	BOne,
	DstRGB:		BOneMinusSrcAlpha,
	DstAlpha:	BOneMinusSrcAlpha,
	RGBEq:		BAdd,
	AlphaEq:	BAdd,
}</pre>
		<p>The default blend state to use for graphics objects (by default it works
well for premultiplied alpha blending).
</p>
	
		<pre>var DefaultState = State{
	AlphaMode:	NoAlpha,
	Blend:		DefaultBlendState,
	WriteRed:	true,
	WriteGreen:	true,
	WriteBlue:	true,
	WriteAlpha:	true,
	Dithering:	true,
	DepthTest:	true,
	DepthWrite:	true,
	DepthCmp:	Less,
	StencilTest:	false,
	FaceCulling:	BackFaceCulling,
	StencilFront:	DefaultStencilState,
	StencilBack:	DefaultStencilState,
}</pre>
		<p>The default state that should be used for graphics objects.
</p>
	
		<pre>var DefaultStencilState = StencilState{
	WriteMask:	0xFFFF,
	Fail:		SKeep,
	DepthFail:	SKeep,
	DepthPass:	SKeep,
	Cmp:		Always,
}</pre>
		<p>The default stencil state that should be used for graphics objects.
</p>
	
</span>





	<h1 id="InsertionSort" class="hdr pkg hdr-function"><a href="#InsertionSort" title="permalink">»</a>&nbsp;func InsertionSort(data sort.Interface) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func InsertionSort(data sort.Interface)</pre>
		<p>
InsertionSort performs a simple insertion sort on the sort interface. In the
case of ByDist it performs generally as fast as sort.Sort() except that it
can exploit temporal coherence improving performance dramatically when the
objects have not moved much.
</p>

	</span>





	
	<h1 id="AlphaMode" class="hdr pkg hdr-type"><a href="#AlphaMode" title="permalink">»</a>&nbsp;type AlphaMode <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type AlphaMode uint8</pre>
		<p>
AlphaMode describes a single alpha transparency mode that can be used for
rendering transparent parts of objects.
</p>

	</span>

	
	

	
	
		
		<h1 id="AlphaMode.String" class="hdr pkg hdr-method"><a href="#AlphaMode.String" title="permalink">»</a>&nbsp;func (m AlphaMode) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m AlphaMode) String() string</pre>
			<p>
String returns a string representation of this alpha transparency mode.
e.g. NoAlpha -&gt; &#34;NoAlpha&#34;
</p>

		</span>
	

	
	<h1 id="BlendEq" class="hdr pkg hdr-type"><a href="#BlendEq" title="permalink">»</a>&nbsp;type BlendEq <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type BlendEq uint8</pre>
		<p>
BlendEq represents a single blend equation to use when blending RGB or Alpha
components in the color buffer, it must be one of BlendAdd, BlendSubtract, BlendReverseSubtract.
</p>

	</span>

	
	

	
	

	
	<h1 id="BlendOp" class="hdr pkg hdr-type"><a href="#BlendOp" title="permalink">»</a>&nbsp;type BlendOp <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type BlendOp uint8</pre>
		<p>
BlendOp represents a single blend operand, e.g. BOne, BOneMinusSrcAlpha.
</p>

	</span>

	
	

	
	

	
	<h1 id="BlendState" class="hdr pkg hdr-type"><a href="#BlendState" title="permalink">»</a>&nbsp;type BlendState <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type BlendState struct {
	// The constant blend color to be used (e.g. with BConstantColor).
	Color	Color

	// Specifies the blend operand to use for the source RGB components.
	// All predefined BlendOp constants may be used.
	SrcRGB	BlendOp

	// Specifies the blend operand to use for the destination RGB components.
	// All predefined BlendOp constants may be used except BSrcAlphaSaturate.
	DstRGB	BlendOp

	// Specifies the blending operation to use between source and destination
	// alpha components.
	SrcAlpha, DstAlpha	BlendOp

	// Specifies the blending equation to use for RGB and Alpha components,
	// respectively.
	RGBEq, AlphaEq	BlendEq
}</pre>
		<p>
BlendState represents the blend state to use when rendering an object whose
AlphaMode == BlendedAlpha.
</p>

	</span>

	
	

	
	
		
		<h1 id="BlendState.Compare" class="hdr pkg hdr-method"><a href="#BlendState.Compare" title="permalink">»</a>&nbsp;func (b BlendState) Compare(other BlendState) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b BlendState) Compare(other BlendState) bool</pre>
			<p>
Compare compares this state against the other one using DefaultBlendState as
a reference when inequality occurs and returns whether or not this state
should sort before the other one for purposes of state sorting.
</p>

		</span>
	

	
	<h1 id="Boundable" class="hdr pkg hdr-type"><a href="#Boundable" title="permalink">»</a>&nbsp;type Boundable <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Boundable interface {
	// Bounds returns the axis-aligned bounding box of this boundable object.
	Bounds() lmath.Rect3
}</pre>
		<p>
Boundable represents any object that can return it&#39;s axis-aligned bounding
box.
</p>

	</span>

	
	

	
	

	
	<h1 id="Bounds" class="hdr pkg hdr-type"><a href="#Bounds" title="permalink">»</a>&nbsp;type Bounds <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Bounds lmath.Rect3</pre>
		<p>
Bounds is a simple datatype which implements the Boundable interface.
</p>

	</span>

	
	

	
	
		
		<h1 id="Bounds.Bounds" class="hdr pkg hdr-method"><a href="#Bounds.Bounds" title="permalink">»</a>&nbsp;func (b Bounds) Bounds() lmath.Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b Bounds) Bounds() lmath.Rect3</pre>
			<p>
Bounds implements the Boundable interface.
</p>

		</span>
	

	
	<h1 id="ByDist" class="hdr pkg hdr-type"><a href="#ByDist" title="permalink">»</a>&nbsp;type ByDist <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ByDist struct {
	// The list of objects to sort.
	Objects	[]*Object

	// The target position to compare against. The list is sorted based off
	// each object&#39;s distance away from this position (typically this is the
	// camera&#39;s position).
	Target	lmath.Vec3
}</pre>
		<p>
ByDist sorts a list of graphics objects based on their distance away from
a target position (typically the camera). As such if the sorted objects are
drawn in order then they are drawn back-to-front (which is useful for
rendering alpha-blended objects such that transparency appears correct).
</p>
<p>
Using sort.Reverse this doubles as front-to-back sorting (which is useful
for drawing opaque objects efficiently due to depth testing).
</p>
<p>
The Less() method properly read-locks the objects when required.
</p>

	</span>

	
	

	
	
		
		<h1 id="ByDist.Len" class="hdr pkg hdr-method"><a href="#ByDist.Len" title="permalink">»</a>&nbsp;func (b ByDist) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b ByDist) Len() int</pre>
			<p>
Implements sort.Interface.
</p>

		</span>
	
		
		<h1 id="ByDist.Less" class="hdr pkg hdr-method"><a href="#ByDist.Less" title="permalink">»</a>&nbsp;func (b ByDist) Less(ii, jj int) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b ByDist) Less(ii, jj int) bool</pre>
			<p>
Implements sort.Interface.
</p>

		</span>
	
		
		<h1 id="ByDist.Swap" class="hdr pkg hdr-method"><a href="#ByDist.Swap" title="permalink">»</a>&nbsp;func (b ByDist) Swap(i, j int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b ByDist) Swap(i, j int)</pre>
			<p>
Implements sort.Interface.
</p>

		</span>
	

	
	<h1 id="ByState" class="hdr pkg hdr-type"><a href="#ByState" title="permalink">»</a>&nbsp;type ByState <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ByState []*Object</pre>
		<p>
ByState sorts a list of graphics objects based on the change of their
graphics state in order to reduce graphics state changes and increase the
overall throughput when rendering several objects whose graphics state
differ.
</p>
<p>
The Less() method properly read-locks the objects when required.
</p>

	</span>

	
	

	
	
		
		<h1 id="ByState.Len" class="hdr pkg hdr-method"><a href="#ByState.Len" title="permalink">»</a>&nbsp;func (b ByState) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b ByState) Len() int</pre>
			<p>
Implements sort.Interface.
</p>

		</span>
	
		
		<h1 id="ByState.Less" class="hdr pkg hdr-method"><a href="#ByState.Less" title="permalink">»</a>&nbsp;func (b ByState) Less(i, j int) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b ByState) Less(i, j int) bool</pre>
			<p>
Implements sort.Interface.
</p>

		</span>
	
		
		<h1 id="ByState.Swap" class="hdr pkg hdr-method"><a href="#ByState.Swap" title="permalink">»</a>&nbsp;func (b ByState) Swap(i, j int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b ByState) Swap(i, j int)</pre>
			<p>
Implements sort.Interface.
</p>

		</span>
	

	
	<h1 id="Camera" class="hdr pkg hdr-type"><a href="#Camera" title="permalink">»</a>&nbsp;type Camera <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Camera struct {
	*Object

	// The projection matrix of the camera, which is responsible for projecting
	// world coordinates into device coordinates.
	Projection	Mat4
}</pre>
		<p>
Camera represents a camera object, it may be moved in 3D space using the
objects transform and the viewing frustum controls how the camera views
things. Since a camera is in itself also an object it may also have visible
meshes attatched to it, etc.
</p>

	</span>

	
	
		<h1 id="NewCamera" class="hdr pkg hdr-function"><a href="#NewCamera" title="permalink">»</a>&nbsp;func NewCamera() *Camera <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func NewCamera() *Camera</pre>
			<p>
NewCamera returns a new *Camera with the default values.
</p>

		</span>
	

	
	
		
		<h1 id="Camera.Copy" class="hdr pkg hdr-method"><a href="#Camera.Copy" title="permalink">»</a>&nbsp;func (c *Camera) Copy() *Camera <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Camera) Copy() *Camera</pre>
			<p>
Copy returns a new copy of this Camera.
</p>
<p>
The camera&#39;s read lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Camera.Destroy" class="hdr pkg hdr-method"><a href="#Camera.Destroy" title="permalink">»</a>&nbsp;func (c *Camera) Destroy() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Camera) Destroy()</pre>
			<p>
Destroy destroys this camera for use by other callees to NewCamera. You must
not use it after calling this method. This makes an implicit call to
c.Object.Destroy.
</p>
<p>
The camera&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Camera.Project" class="hdr pkg hdr-method"><a href="#Camera.Project" title="permalink">»</a>&nbsp;func (c *Camera) Project(p3 lmath.Vec3) (p2 lmath.Vec2, ok bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Camera) Project(p3 lmath.Vec3) (p2 lmath.Vec2, ok bool)</pre>
			<p>
Project returns a 2D point in normalized device space coordinates given a 3D
point in the world.
</p>
<p>
If ok=false is returned then the point is outside of the camera&#39;s view and
the returned point may not be meaningful.
</p>
<p>
The camera&#39;s read lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Camera.Reset" class="hdr pkg hdr-method"><a href="#Camera.Reset" title="permalink">»</a>&nbsp;func (c *Camera) Reset() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Camera) Reset()</pre>
			<p>
Reset resets this camera to it&#39;s default (NewCamera) state.
</p>
<p>
The camera&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Camera.SetOrtho" class="hdr pkg hdr-method"><a href="#Camera.SetOrtho" title="permalink">»</a>&nbsp;func (c *Camera) SetOrtho(view image.Rectangle, near, far float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Camera) SetOrtho(view image.Rectangle, near, far float64)</pre>
			<p>
SetOrtho sets this camera&#39;s Projection matrix to an orthographic one.
</p>
<p>
The view parameter is the viewing rectangle for the orthographic
projection in window coordinates.
</p>
<p>
The near and far parameters describe the minimum closest and maximum
furthest clipping points of the view frustum.
</p>
<p>
Clients who need advanced control over how the orthographic viewing frustum
is set up may use this method&#39;s source as a reference (e.g. to change the
center point, which this method sets at the bottom-left).
</p>
<p>
The camera&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Camera.SetPersp" class="hdr pkg hdr-method"><a href="#Camera.SetPersp" title="permalink">»</a>&nbsp;func (c *Camera) SetPersp(view image.Rectangle, fov, near, far float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Camera) SetPersp(view image.Rectangle, fov, near, far float64)</pre>
			<p>
SetPersp sets this camera&#39;s Projection matrix to an perspective one.
</p>
<p>
The view parameter is the viewing rectangle for the orthographic
projection in window coordinates.
</p>
<p>
The fov parameter is the Y axis field of view (e.g. some games use 75) to
use.
</p>
<p>
The near and far parameters describe the minimum closest and maximum
furthest clipping points of the view frustum.
</p>
<p>
Clients who need advanced control over how the perspective viewing frustum
is set up may use this method&#39;s source as a reference (e.g. to change the
center point, which this method sets at the center).
</p>
<p>
The camera&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	

	
	<h1 id="Canvas" class="hdr pkg hdr-type"><a href="#Canvas" title="permalink">»</a>&nbsp;type Canvas <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Canvas interface {
	Downloadable

	// SetMSAA should request that this canvas use multi-sample anti-aliasing
	// during rendering. By default MSAA is enabled.
	//
	// Even if MSAA is requested to be enabled, there is no guarantee that it
	// will actually be used. For instance if the graphics hardware or
	// rendering API does not support it.
	SetMSAA(enabled bool)

	// MSAA returns the last value passed into SetMSAA on this renderer.
	MSAA() bool

	// Precision should return the precision of the canvas&#39;s color, depth, and
	// stencil buffers.
	Precision() Precision

	// Bounds should return the bounding rectangle of this canvas, any and all
	// methods of this canvas that take rectangles as parameters will be
	// clamped to these bounds.
	// The bounds returned by this method may change at any given time (e.g.
	// when a user resizes the window).
	Bounds() image.Rectangle

	// Clear submits a clear operation to the renderer. It will clear the given
	// rectangle of the canvas&#39;s color buffer to the specified background
	// color.
	//
	// If the rectangle is empty the entire canvas is cleared.
	Clear(r image.Rectangle, bg Color)

	// ClearDepth submits a depth-clear operation to the renderer. It will
	// clear the given rectangle of the canvas&#39;s depth buffer to the specified
	// depth value (in the range of 0.0 to 1.0, where 1.0 is furthest away).
	//
	// If the rectangle is empty the entire canvas is cleared.
	ClearDepth(r image.Rectangle, depth float64)

	// ClearStencil submits a stencil-clear operation to the renderer. It will
	// clear the given rectangle of the canvas&#39;s stencil buffer to the
	// specified stencil value.
	//
	// If the rectangle is empty the entire canvas is cleared.
	ClearStencil(r image.Rectangle, stencil int)

	// Draw submits a draw operation to the renderer. It will draw the given
	// graphics object onto the specified rectangle of the canvas.
	//
	// The canvas will lock the object and camera object and they may stay
	// locked until some point in the future when the draw operation completes.
	//
	// If not nil, then the object is drawn according to how it is seen by the
	// given camera object (taking into account the camera object&#39;s
	// transformation and projection matrices).
	//
	// If the GPU supports occlusion queries (see GPUInfo.OcclusionQuery) and
	// o.OcclusionTest is set to true then at some point in the future (or when
	// QueryWait() is called) the native object will record the number of
	// samples that passed depth and stencil testing phases such that when
	// SampleCount() is called it will return the number of samples last drawn
	// by the object.
	//
	// The canvas must invoke o.Bounds() some time before clearing data slices
	// of loaded meshes, such that the object has a chance to determine it&#39;s
	// bounding box.
	//
	// The object will not be drawn if any of the following cases are true:
	//  o.Shader == nil
	//  len(o.Shader.Error) &gt; 0
	//  len(o.Meshes) == 0
	//  !o.Meshes[N].Loaded &amp;&amp; len(o.Meshes[N].Vertices) == 0
	//
	// If the rectangle is empty the entire canvas is drawn to.
	Draw(r image.Rectangle, o *Object, c *Camera)

	// QueryWait blocks until all pending draw object&#39;s occlusion queries
	// completely finish. Most clients should avoid this call as it can easilly
	// cause graphics pipeline stalls if not handled with care.
	//
	// Instead of calling QueryWait immediately for conditional rendering, it is
	// common practice to instead make use of the previous frame&#39;s occlusion
	// query results as this allows the CPU and GPU to work in parralel instead
	// of being directly synchronized with one another.
	//
	// If the GPU does not support occlusion queries (see
	// GPUInfo.OcclusionQuery) then this function is no-op.
	QueryWait()

	// Render should finalize all pending clear and draw operations as if they
	// where all submitted over a single channel like so:
	//  pending := len(ops)
	//  for i := 0; i &lt; pending; i&#43;&#43; {
	//      op := &lt;-ops
	//      finalize(op)
	//  }
	// and once complete the final frame should be sent to the graphics
	// hardware for rasterization.
	//
	// Additionally, a call to Render() means an implicit call to QueryWait().
	Render()
}</pre>
		<p>
Canvas defines a canvas that can be drawn to (i.e. a window that the user
will visibly see, or a texture that will store the results for later use).
</p>
<p>
All methods must be safe to call from multiple goroutines.
</p>

	</span>

	
	

	
	

	
	<h1 id="Cmp" class="hdr pkg hdr-type"><a href="#Cmp" title="permalink">»</a>&nbsp;type Cmp <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Cmp uint8</pre>
		<p>
Cmp represents a single comparison operator, like Less, Never, etc.
</p>

	</span>

	
	

	
	

	
	<h1 id="Color" class="hdr pkg hdr-type"><a href="#Color" title="permalink">»</a>&nbsp;type Color <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Color struct {
	R, G, B, A float32
}</pre>
		<p>
Color represents a normalized (values are in the range of 0.0 to 1.0)
32-bit floating point RGBA color data type.
</p>

	</span>

	
	

	
	
		
		<h1 id="Color.RGBA" class="hdr pkg hdr-method"><a href="#Color.RGBA" title="permalink">»</a>&nbsp;func (c Color) RGBA() (r, g, b, a uint32) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c Color) RGBA() (r, g, b, a uint32)</pre>
			<p>
Implements image/color.Color interface.
</p>

		</span>
	

	
	<h1 id="CoordConv" class="hdr pkg hdr-type"><a href="#CoordConv" title="permalink">»</a>&nbsp;type CoordConv <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CoordConv uint8</pre>
		<p>
CoordSpace represents a single coordinate space conversion.
</p>
<p>
World space is the top-most &#39;world&#39; or &#39;global&#39; space. A transform whose
parent is nil explicitly means the parent is the &#39;world&#39;.
</p>
<p>
Local space is the local space that this transform defines. Conceptually
you may think of a transform as positioning, scaling, shearing, etc it&#39;s
(local) space relative to it&#39;s parent.
</p>
<p>
Parent space is the local space of any given transform&#39;s parent. If the
transform does not have a parent then parent space is identical to world
space.
</p>

	</span>

	
	

	
	

	
	<h1 id="DSFormat" class="hdr pkg hdr-type"><a href="#DSFormat" title="permalink">»</a>&nbsp;type DSFormat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type DSFormat uint8</pre>
		<p>
DSFormat specifies a single depth or stencil buffer storage format.
</p>

	</span>

	
	

	
	
		
		<h1 id="DSFormat.DepthBits" class="hdr pkg hdr-method"><a href="#DSFormat.DepthBits" title="permalink">»</a>&nbsp;func (f DSFormat) DepthBits() uint8 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (f DSFormat) DepthBits() uint8</pre>
			<p>
DepthBits returns the number of depth bits in this format. For example:
</p>
<pre>Depth16 == 16
Depth24AndStencil8 == 24
</pre>

		</span>
	
		
		<h1 id="DSFormat.IsCombined" class="hdr pkg hdr-method"><a href="#DSFormat.IsCombined" title="permalink">»</a>&nbsp;func (f DSFormat) IsCombined() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (f DSFormat) IsCombined() bool</pre>
			<p>
IsCombined tells if f is a combined depth and stencil buffer format. It must
be one of the following:
</p>
<pre>Depth24AndStencil8
</pre>

		</span>
	
		
		<h1 id="DSFormat.IsDepth" class="hdr pkg hdr-method"><a href="#DSFormat.IsDepth" title="permalink">»</a>&nbsp;func (f DSFormat) IsDepth() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (f DSFormat) IsDepth() bool</pre>
			<p>
IsDepth tells if f is a valid depth buffer format. It must be one of the
following:
</p>
<pre>Depth16
Depth24
Depth32
Depth24AndStencil8
</pre>

		</span>
	
		
		<h1 id="DSFormat.IsStencil" class="hdr pkg hdr-method"><a href="#DSFormat.IsStencil" title="permalink">»</a>&nbsp;func (f DSFormat) IsStencil() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (f DSFormat) IsStencil() bool</pre>
			<p>
IsStencil tells if f is a valid stencil buffer format. It must be one of the
following:
</p>
<pre>Depth24AndStencil8
</pre>

		</span>
	
		
		<h1 id="DSFormat.StencilBits" class="hdr pkg hdr-method"><a href="#DSFormat.StencilBits" title="permalink">»</a>&nbsp;func (f DSFormat) StencilBits() uint8 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (f DSFormat) StencilBits() uint8</pre>
			<p>
StencilBits returns the number of stencil bits in this format. For example:
</p>
<pre>Depth24AndStencil8 == 8
Depth16 == 0
</pre>

		</span>
	
		
		<h1 id="DSFormat.String" class="hdr pkg hdr-method"><a href="#DSFormat.String" title="permalink">»</a>&nbsp;func (t DSFormat) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t DSFormat) String() string</pre>
			<p>
String returns a string name for this depth/stencil buffer format. For
example:
</p>
<pre>Depth24AndStencil8 -&gt; &#34;Depth24AndStencil8&#34;
</pre>

		</span>
	

	
	<h1 id="Destroyable" class="hdr pkg hdr-type"><a href="#Destroyable" title="permalink">»</a>&nbsp;type Destroyable <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Destroyable interface {
	// Destroy destroys this object. Once destroyed the object can still be
	// used but doing so is not advised for performance reasons (e.g. requires
	// reloading the entire object).
	//
	// This method is safe to invoke from multiple goroutines concurrently.
	Destroy()
}</pre>
		<p>
Destroyable defines a destroyable object. Once an object is destroyed it may
still be used, but typically doing so is not good and would e.g. involve
reloading the entire object and cause performance issues.
</p>
<p>
Clients should invoke the Destroy() method when they are done utilizing the
object or else doing so will be left up to a runtime Finalizer.
</p>

	</span>

	
	

	
	

	
	<h1 id="Downloadable" class="hdr pkg hdr-type"><a href="#Downloadable" title="permalink">»</a>&nbsp;type Downloadable <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Downloadable interface {
	// Download should download the given intersecting rectangle of this
	// downloadable image from the graphics hardware into system memory and
	// send it to the complete channel when done.
	//
	// If downloading this texture is impossible (i.e. hardware does not
	// support this) then nil will be sent over the channel and all future
	// attempts to download this texture will fail as well.
	//
	// It should be noted that the downloaded image may not be pixel-identical
	// to the previously uploaded source image of a texture, for instance if
	// texture compression was used it may suffer from compression artifacts,
	// etc.
	//
	// Only a texture created from render-to-texture is guaranteed to succeed,
	// others may not (esp. compressed textures). Most renderers support
	// downloading RGB/A textures and sometimes depth/alpha ones.
	Download(r image.Rectangle, complete chan image.Image)
}</pre>
		<p>
Downloadable represents a image that can be downloaded from the graphics
hardware into system memory (e.g. for taking a screen-shot).
</p>

	</span>

	
	

	
	

	
	<h1 id="FaceCullMode" class="hdr pkg hdr-type"><a href="#FaceCullMode" title="permalink">»</a>&nbsp;type FaceCullMode <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type FaceCullMode uint8</pre>
		<p>
FaceCullMode represents a single face culling mode. BackFaceCulling is the
default (zero value).
</p>

	</span>

	
	

	
	
		
		<h1 id="FaceCullMode.String" class="hdr pkg hdr-method"><a href="#FaceCullMode.String" title="permalink">»</a>&nbsp;func (f FaceCullMode) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (f FaceCullMode) String() string</pre>
			<p>
String returns a string representation of this FaceCullMode.
e.g. BackFaceCulling -&gt; &#34;BackFaceCulling&#34;
</p>

		</span>
	

	
	<h1 id="GPUInfo" class="hdr pkg hdr-type"><a href="#GPUInfo" title="permalink">»</a>&nbsp;type GPUInfo <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type GPUInfo struct {
	// MaxTextureSize is the maximum size of either X or Y dimension of texture
	// images for use with the renderer, or -1 if not available.
	MaxTextureSize	int

	// Whether or not the AlphaToCoverage alpha mode is supported (if false
	// then BinaryAlpha will automatically be used as a fallback).
	AlphaToCoverage	bool

	// Whether or not occlusion queries are supported or not.
	OcclusionQuery	bool

	// The number of bits reserved for the sample count when performing
	// occlusion queries, if the number goes above what this many bits could
	// store then it is generally (but not always) clamped to that value.
	OcclusionQueryBits	int

	// The name of the graphics hardware, or an empty string if not available.
	// For example it may look something like:
	//  Mesa DRI Intel(R) Sandybridge Mobile
	Name	string

	// The vendor name of the graphics hardware, or an empty string if not
	// available. For example:
	//  Intel Open Source Technology Center
	Vendor	string

	// Whether or not the graphics hardware supports Non Power Of Two texture
	// sizes.
	//
	// If true, then textures may be any arbitrary size (while keeping in mind
	// this often incurs a performance cost, and does not work well with
	// compression or mipmapping).
	//
	// If false, then texture dimensions must be a power of two (e.g. 32x64,
	// 512x512, etc) or else the texture will be resized by the renderer to the
	// nearest power-of-two.
	NPOT	bool

	// The formats available for render-to-texture (RTT).
	RTTFormats

	// Major and minor versions of the OpenGL version in use, or -1 if not
	// available. For example:
	//  3, 0 (for OpenGL 3.0)
	GLMajor, GLMinor	int

	// A read-only slice of OpenGL extension strings, empty if not available.
	GLExtensions	[]string

	// Major and minor versions of the OpenGL Shading Language version in use,
	// or -1 if not available. For example:
	//  1, 30 (for GLSL 1.30)
	GLSLMajor, GLSLMinor	int

	// The maximum number of floating-point variables available for varying
	// variables inside GLSL programs, or -1 if not available. Generally at
	// least 32.
	GLSLMaxVaryingFloats	int

	// The maximum number of shader inputs (i.e. floating-point values, where a
	// 4x4 matrix is 16 floating-point values) that can be used inside a GLSL
	// vertex shader, or -1 if not available. Generally at least 512.
	GLSLMaxVertexInputs	int

	// The maximum number of shader inputs (i.e. floating-point values, where a
	// 4x4 matrix is 16 floating-point values) that can be used inside a GLSL
	// fragment shader, or -1 if not available. Generally at least 64.
	GLSLMaxFragmentInputs	int
}</pre>
		<p>
GPUInfo describes general information and limitations of the graphics
hardware, such as the maximum texture size and other features which may or
may not be supported by the graphics hardware.
</p>

	</span>

	
	

	
	

	
	<h1 id="Mat4" class="hdr pkg hdr-type"><a href="#Mat4" title="permalink">»</a>&nbsp;type Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Mat4 [4][4]float32</pre>
		<p>
Mat4 represents a 32-bit floating point 4x4 matrix for compatability with
graphics hardware.
lmath.Mat4 should be used anywhere that an explicit 32-bit type is not
needed.
</p>

	</span>

	
	
		<h1 id="ConvertMat4" class="hdr pkg hdr-function"><a href="#ConvertMat4" title="permalink">»</a>&nbsp;func ConvertMat4(m lmath.Mat4) Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func ConvertMat4(m lmath.Mat4) Mat4</pre>
			<p>
ConvertMat4 converts the 64-bit lmath.Mat4 to a 32-bit Mat4 matrix.
</p>

		</span>
	

	
	
		
		<h1 id="Mat4.Mat4" class="hdr pkg hdr-method"><a href="#Mat4.Mat4" title="permalink">»</a>&nbsp;func (m Mat4) Mat4() lmath.Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m Mat4) Mat4() lmath.Mat4</pre>
			<p>
Mat4 converts this 32-bit Mat4 to a 64-bit lmath.Mat4 matrix.
</p>

		</span>
	

	
	<h1 id="Mesh" class="hdr pkg hdr-type"><a href="#Mesh" title="permalink">»</a>&nbsp;type Mesh <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Mesh struct {
	sync.RWMutex

	// The native object of this mesh. Once loaded the renderer using this mesh
	// must assign a value to this field. Typically clients should not assign
	// values to this field at all.
	NativeMesh

	// Weather or not this mesh is currently loaded or not.
	Loaded	bool

	// If true then when this mesh is loaded the sources of it will be kept
	// instead of being set to nil (which allows them to be garbage collected).
	KeepDataOnLoad	bool

	// Weather or not the mesh will be dynamically updated. Only used as a hint
	// to increase performence of dynamically updated meshes, does not actually
	// control whether or not a mesh may be dynamically updated.
	Dynamic	bool

	// AABB is the axis aligned bounding box of this mesh. There may not be one
	// if AABB.Empty() == true, but one can be calculate using the
	// CalculateBounds() method.
	AABB	lmath.Rect3

	// A slice of indices, if non-nil then this slice contains indices into
	// each other slice (such as Vertices) and this is a indexed mesh.
	// The indices are uint32 (instead of int) for compatability with graphics
	// hardware.
	Indices	[]uint32

	// Weather or not the indices have changed since the last time the mesh
	// was loaded. If set to true the renderer should take note and
	// re-upload the data slice to the graphics hardware.
	IndicesChanged	bool

	// The slice of vertices for the mesh.
	Vertices	[]Vec3

	// Weather or not the vertices have changed since the last time the
	// mesh was loaded. If set to true the renderer should take note and
	// re-upload the data slice to the graphics hardware.
	VerticesChanged	bool

	// The slice of vertex colors for the mesh.
	Colors	[]Color

	// Weather or not the vertex colors have changed since the last time
	// the mesh was loaded. If set to true the renderer should take note
	// and re-upload the data slice to the graphics hardware.
	ColorsChanged	bool

	// A slice of barycentric coordinates for the mesh.
	Bary	[]Vec3

	// Whether or not the barycentric coordinates have changed since the last
	// time the mesh was loaded. If set to true the renderer should take note
	// and re-upload the data slice to the graphics hardware.
	BaryChanged	bool

	// A slice of texture coordinate sets for the mesh, there may be
	// multiple sets which directly relate to multiple textures on a
	// object.
	TexCoords	[]TexCoordSet

	// A map of custom per-vertex attributes for the mesh. It is analogous to
	// the Colors, Bary, and TexCoords fields. It allows you to submit a set of
	// named custom per-vertex data to shaders.
	//
	// For instance you could submit a set of per-vertex vec3&#39;s with:
	//  myData := make([]gfx.Vec3, len(mesh.Vertices))
	//  mesh.Attribs[&#34;MyName&#34;] = gfx.VertexAttrib{
	//      Data: myData,
	//  }
	//
	// If changes to the data are made, the data set will have to be uploaded
	// to the graphics hardware again, so you must inform the renderer when you
	// change the data:
	//  ... modify myData ...
	//  mesh.Attribs[&#34;MyName&#34;].Changed = true
	//
	// In GLSL you could access that per-vertex data by writing:
	//  attribute vec3 MyName;
	//
	// Arrays of data are available in GLSL by slice indice suffixes:
	//  // Data declared in Go:
	//  myData := make([][]gfx.Mat4, 2)
	//
	//  // And in GLSL:
	//  attribute mat4 MyName0; // Per-vertex data from myData[0].
	//  attribute mat4 MyName1; // Per-vertex data from myData[1].
	//
	// See the documentation on the VertexAttrib type for more information
	// regarding what data types may be used.
	Attribs	map[string]VertexAttrib
}</pre>
		<p>
Mesh represents a single mesh made up of several components. A mesh may or
may not be made up of indexed vertices, etc, depending on whether or not
len(m.Indices) == 0 holds true.
In the event that a mesh is indexed, m.Indices holds the indices and it can
be expected that each other slice (Vertices for instance) will hold at least
enough elements (or be nil) such that the each index will not be out of
bounds.
</p>
<p>
Clients are responsible for utilizing the RWMutex of the mesh when using it
or invoking methods.
</p>

	</span>

	
	
		<h1 id="NewMesh" class="hdr pkg hdr-function"><a href="#NewMesh" title="permalink">»</a>&nbsp;func NewMesh() *Mesh <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func NewMesh() *Mesh</pre>
			<p>
NewMesh returns a new *Mesh, for effeciency it may be a re-used one (see the
Destroy method) whose slices have zero-lengths.
</p>

		</span>
	

	
	
		
		<h1 id="Mesh.Bounds" class="hdr pkg hdr-method"><a href="#Mesh.Bounds" title="permalink">»</a>&nbsp;func (m *Mesh) Bounds() lmath.Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *Mesh) Bounds() lmath.Rect3</pre>
			<p>
Bounds implements the Boundable interface. It is thread-safe and performs
locking automatically. If the AABB of this mesh is empty then the bounds are
calculated.
</p>

		</span>
	
		
		<h1 id="Mesh.CalculateBounds" class="hdr pkg hdr-method"><a href="#Mesh.CalculateBounds" title="permalink">»</a>&nbsp;func (m *Mesh) CalculateBounds() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *Mesh) CalculateBounds()</pre>
			<p>
CalculateBounds calculates a new axis aligned bounding box for this mesh.
</p>
<p>
The mesh&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Mesh.ClearData" class="hdr pkg hdr-method"><a href="#Mesh.ClearData" title="permalink">»</a>&nbsp;func (m *Mesh) ClearData() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *Mesh) ClearData()</pre>
			<p>
ClearData sets the data slices of this mesh to nil if m.KeepDataOnLoad is
set to false.
</p>
<p>
The mesh&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Mesh.Copy" class="hdr pkg hdr-method"><a href="#Mesh.Copy" title="permalink">»</a>&nbsp;func (m *Mesh) Copy() *Mesh <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *Mesh) Copy() *Mesh</pre>
			<p>
Copy returns a new copy of this Mesh. Depending on how large the mesh is
this may be an expensive operation. Explicitly not copied over is the native
mesh, the OnLoad slice, and the loaded and changed statuses (Loaded,
IndicesChanged, VerticesChanged, etc).
</p>
<p>
The mesh&#39;s read lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Mesh.Destroy" class="hdr pkg hdr-method"><a href="#Mesh.Destroy" title="permalink">»</a>&nbsp;func (m *Mesh) Destroy() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *Mesh) Destroy()</pre>
			<p>
Destroy destroys this mesh for use by other callees to NewMesh. You must not
use it after calling this method. This makes an implicit call to
m.NativeMesh.Destroy.
</p>
<p>
The mesh&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Mesh.GenerateBary" class="hdr pkg hdr-method"><a href="#Mesh.GenerateBary" title="permalink">»</a>&nbsp;func (m *Mesh) GenerateBary() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *Mesh) GenerateBary()</pre>
			<p>
GenerateBary generates the barycentric coordinates for this mesh.
</p>
<p>
The mesh&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Mesh.HasChanged" class="hdr pkg hdr-method"><a href="#Mesh.HasChanged" title="permalink">»</a>&nbsp;func (m *Mesh) HasChanged() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *Mesh) HasChanged() bool</pre>
			<p>
HasChanged tells if any of the data slices of the mesh are marked as having
changed.
</p>
<p>
The mesh&#39;s read lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Mesh.Reset" class="hdr pkg hdr-method"><a href="#Mesh.Reset" title="permalink">»</a>&nbsp;func (m *Mesh) Reset() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *Mesh) Reset()</pre>
			<p>
Reset resets this mesh to it&#39;s default (NewMesh) state.
</p>
<p>
The mesh&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	

	
	<h1 id="NativeMesh" class="hdr pkg hdr-type"><a href="#NativeMesh" title="permalink">»</a>&nbsp;type NativeMesh <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type NativeMesh Destroyable</pre>
		<p>
NativeMesh represents the native object of a mesh, typically only renderers
create these.
</p>

	</span>

	
	

	
	

	
	<h1 id="NativeObject" class="hdr pkg hdr-type"><a href="#NativeObject" title="permalink">»</a>&nbsp;type NativeObject <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type NativeObject interface {
	Destroyable

	// If the GPU supports occlusion queries (see GPUInfo.OcclusionQuery) and
	// OcclusionTest is set to true on the graphics object, then this method
	// will return the number of samples that passed the depth and stencil
	// testing phases the last time the object was drawn. If occlusion queries
	// are not supported then -1 will be returned.
	//
	// This method is safe to invoke from multiple goroutines concurrently.
	SampleCount() int
}</pre>
		<p>
NativeObject represents a native graphics object, they are normally only
created by renderers.
</p>

	</span>

	
	

	
	

	
	<h1 id="NativeShader" class="hdr pkg hdr-type"><a href="#NativeShader" title="permalink">»</a>&nbsp;type NativeShader <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type NativeShader Destroyable</pre>
		<p>
NativeShader represents the native object of a shader. Typically only
renderers will create these.
</p>

	</span>

	
	

	
	

	
	<h1 id="NativeTexture" class="hdr pkg hdr-type"><a href="#NativeTexture" title="permalink">»</a>&nbsp;type NativeTexture <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type NativeTexture interface {
	Destroyable
	Downloadable

	// ChosenFormat tells the texture format chosen by the renderer for storing
	// this texture on the graphics device. It may differ from the Texture&#39;s
	// Format field only if the graphics device does not support that format.
	ChosenFormat() TexFormat
}</pre>
		<p>
NativeTexture represents the native object of a *Texture, the renderer is
responsible for creating these and fulfilling the interface.
</p>

	</span>

	
	

	
	

	
	<h1 id="Object" class="hdr pkg hdr-type"><a href="#Object" title="permalink">»</a>&nbsp;type Object <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Object struct {
	sync.RWMutex

	// The native object of this graphics object. The renderer using this
	// graphics object must assign a value to this field after a call to
	// Draw() has finished before unlocking the object.
	NativeObject

	// Whether or not this object should be occlusion tested. See also the
	// SampleCount() method of NativeObject.
	OcclusionTest	bool

	// The render state of this object.
	State

	// The transformation of the object.
	*Transform

	// The shader program to be used during rendering the object.
	*Shader

	// A slice of meshes which make up the object. The order in which the
	// meshes appear in this slice also affects the order in which they are
	// sent to the graphics card.
	//
	// This is a slice specifically to allow renderer implementations to
	// optimize the number of draw calls that must occur to render
	// consecutively listed meshes here (this allows for &#39;hardware&#39; instancing
	// support).
	Meshes	[]*Mesh

	// A slice of textures which are used to texture the meshes of this object.
	// The order in which the textures appear in this slice is also the order
	// in which they are sent to the graphics card.
	Textures	[]*Texture

	// CachedBounds represents the pre-calculated cached bounding box of this
	// object. Note that the bounds are only calculated once Object.Bounds() is
	// invoked.
	//
	// If you make changes to the vertices of any mesh associated with this
	// object, or if you add / remove meshes from this object, the bounds will
	// not reflect this automatically. Instead, you must clear the cached
	// bounds explicitly:
	//  o.Lock()
	//  o.CachedBounds = nil
	//  o.Unlock()
	//
	// And then simply invoke o.Bounds() again to calculate the bounds again.
	CachedBounds	*lmath.Rect3
}</pre>
		<p>
Object represents a single graphics object for rendering, it has a
transformation matrix which is applied to each vertex of each mesh, it
has a shader program, meshes, and textures used for rendering the object.
</p>
<p>
Clients are responsible for utilizing the RWMutex of the object when using
it or invoking methods.
</p>

	</span>

	
	
		<h1 id="NewObject" class="hdr pkg hdr-function"><a href="#NewObject" title="permalink">»</a>&nbsp;func NewObject() *Object <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func NewObject() *Object</pre>
			<p>
NewObject creates and returns a new object with:
</p>
<pre>o.State == DefaultState
o.Transform == DefaultTransform
</pre>

		</span>
	

	
	
		
		<h1 id="Object.Bounds" class="hdr pkg hdr-method"><a href="#Object.Bounds" title="permalink">»</a>&nbsp;func (o *Object) Bounds() lmath.Rect3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (o *Object) Bounds() lmath.Rect3</pre>
			<p>
Bounds implements the Boundable interface. The returned bounding box takes
into account all of the mesh&#39;s bounding boxes, transformed into world space.
</p>
<p>
The bounding box is cached (see o.CachedBounds) so that multiple calls to
this method are fast. If you make changes to the vertices, or add/remove
meshes from this object you need to explicitly clear the cached bounds so
that the next call to Bounds() will calculate the bounding box again:
</p>
<pre>o.Lock()
o.CachedBounds = nil
o.Unlock()
</pre>
<p>
You do not need to clear the cached bounds if the transform of the object
has changed (as it is applied after calculation of the bounding box).
</p>
<p>
This method properly write-locks the object.
</p>

		</span>
	
		
		<h1 id="Object.Compare" class="hdr pkg hdr-method"><a href="#Object.Compare" title="permalink">»</a>&nbsp;func (o *Object) Compare(other *Object) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (o *Object) Compare(other *Object) bool</pre>
			<p>
Compare compares this object&#39;s state (including shader and textures) against
the other one and determines if it should sort before the other one for
state sorting purposes.
</p>
<p>
The object&#39;s read lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Object.Copy" class="hdr pkg hdr-method"><a href="#Object.Copy" title="permalink">»</a>&nbsp;func (o *Object) Copy() *Object <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (o *Object) Copy() *Object</pre>
			<p>
Copy returns a new copy of this Object. Explicitily not copied is the native
object. The transform is copied via it&#39;s Copy() method. The shader is only
copied by pointer.
</p>
<p>
The object&#39;s read lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Object.Destroy" class="hdr pkg hdr-method"><a href="#Object.Destroy" title="permalink">»</a>&nbsp;func (o *Object) Destroy() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (o *Object) Destroy()</pre>
			<p>
Destroy destroys this object for use by other callees to NewObject. You must
not use it after calling this method. This makes an implicit call to
o.NativeObject.Destroy.
</p>
<p>
The object&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Object.Reset" class="hdr pkg hdr-method"><a href="#Object.Reset" title="permalink">»</a>&nbsp;func (o *Object) Reset() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (o *Object) Reset()</pre>
			<p>
Reset resets this object to it&#39;s default (NewObject) state.
</p>
<p>
The object&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	

	
	<h1 id="Precision" class="hdr pkg hdr-type"><a href="#Precision" title="permalink">»</a>&nbsp;type Precision <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Precision struct {
	// The precision in bits of each pixel in the color buffer, per color (e.g.
	// 8/8/8/8 would be 32bpp RGBA color, 8/8/8/0 would be 24bpp RGB color, and
	// so on).
	RedBits, GreenBits, BlueBits, AlphaBits	uint8

	// The precision in bits of each pixel in the depth buffer (e.g. 8, 16, 24,
	// etc).
	DepthBits	uint8

	// The precision in bits of each pixel in the stencil buffer (e.g. 8, 16,
	// 24, etc).
	StencilBits	uint8

	// The number of samples available per pixel (e.g. the number of MSAA
	// samples).
	Samples	int
}</pre>
		<p>
Precision represents the precision in bits of the color, depth, and stencil
buffers as well as the number of samples per pixel.
</p>

	</span>

	
	

	
	

	
	<h1 id="RTTConfig" class="hdr pkg hdr-type"><a href="#RTTConfig" title="permalink">»</a>&nbsp;type RTTConfig <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type RTTConfig struct {
	// Bounds is the target resolution of the canvas to render at. If it is an
	// empty rectangle, the renderer&#39;s bounds is used instead.
	Bounds	image.Rectangle

	// The number of samples to use for multisampling. It should be one of the
	// numbers listed in the GPUInfo.RTTFormats structure.
	Samples	int

	// Color, Depth, and Stencil textures, each of these texture&#39;s Format
	// fields are explicitly ignored (see the format fields below). If any of
	// these textures are non-nil, the results of that buffer (e.g. the color
	// buffer) are stored into that texture.
	//
	// Specify nil for any you do not intend to use as a texture (e.g. if you
	// want a 16-bit depth buffer but do not intend to use it as a texture, you
	// could set Depth == nil and DepthFormat == Depth16).
	Color, Depth, Stencil	*Texture

	// Color format to use for the color buffer, it should be one listed in the
	// GPUInfo.RTTFormats structure.
	ColorFormat	TexFormat

	// Depth and Stencil formats to use for the depth and stencil buffers,
	// respectively. They should be ones listed in the GPUInfo.RTTFormats
	// structure.
	//
	// Combined depth and stencil formats can be used (e.g. by setting
	// both DepthFormat and StencilFormat to Depth24AndStencil8), they are
	// often faster and use less memory, but with the caveat that they cannot
	// be used as textures.
	DepthFormat, StencilFormat	DSFormat
}</pre>
		<p>
RTTConfig represents a configuration used for creating a render-to-texture
(RTT) canvas. At least one of Color, Depth, or Stencil textures must be non
nil.
</p>

	</span>

	
	

	
	
		
		<h1 id="RTTConfig.Valid" class="hdr pkg hdr-method"><a href="#RTTConfig.Valid" title="permalink">»</a>&nbsp;func (c RTTConfig) Valid() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c RTTConfig) Valid() bool</pre>
			<p>
Valid tells if this render-to-texture (RTT) configuration is valid or not, a
configuration is considered invalid if:
</p>
<pre>1. All three textures are nil.
2. Any non-nil texture is not accompanies by a format.
3. Either DepthFormat.IsCombined() or StencilFormat.IsCombined() and the other
   is not.
</pre>

		</span>
	

	
	<h1 id="RTTFormats" class="hdr pkg hdr-type"><a href="#RTTFormats" title="permalink">»</a>&nbsp;type RTTFormats <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type RTTFormats struct {
	// Slice of sample counts available for multisampling.
	Samples	[]int

	// Slice of color buffer formats.
	ColorFormats	[]TexFormat

	// Slices of depth and stencil buffer formats.
	DepthFormats, StencilFormats	[]DSFormat
}</pre>
		<p>
RTTFormats represents color, depth, and stencil buffer formats applicable to
render-to-texture (RTT).
</p>

	</span>

	
	

	
	
		
		<h1 id="RTTFormats.Choose" class="hdr pkg hdr-method"><a href="#RTTFormats.Choose" title="permalink">»</a>&nbsp;func (f RTTFormats) Choose(p Precision, compression bool) (color TexFormat, depth, stencil DSFormat) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (f RTTFormats) Choose(p Precision, compression bool) (color TexFormat, depth, stencil DSFormat)</pre>
			<p>
Choose returns a color, depth, and stencil format from the formats, f. It
tries to choose the most applicable one to the requested precision. If
compression is true, it tries to choose the most compressed format.
</p>

		</span>
	
		
		<h1 id="RTTFormats.ChooseConfig" class="hdr pkg hdr-method"><a href="#RTTFormats.ChooseConfig" title="permalink">»</a>&nbsp;func (f RTTFormats) ChooseConfig(p Precision, compression bool) RTTConfig <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (f RTTFormats) ChooseConfig(p Precision, compression bool) RTTConfig</pre>
			<p>
ChooseConfig is short-hand for:
</p>
<pre>colorFormat, depthFormat, stencilFormat := f.Choose(p, compression)
cfg := RTTConfig{
    ColorFormat: colorFormat,
    DepthFormat: depthFormat,
    StencilFormat: stencilFormat,
}
</pre>

		</span>
	

	
	<h1 id="Renderer" class="hdr pkg hdr-type"><a href="#Renderer" title="permalink">»</a>&nbsp;type Renderer <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Renderer interface {
	Canvas

	// Clock should return the graphics clock object which monitors the time
	// between frames, etc. The renderer is responsible for ticking it every
	// time a frame is rendered.
	Clock() *clock.Clock

	// GPUInfo should return information about the graphics hardware.
	GPUInfo() GPUInfo

	// LoadMesh should begin loading the specified mesh asynchronously.
	//
	// Additionally, the renderer will set m.Loaded to true, and then invoke
	// m.ClearData(), thus allowing the data slices to be garbage collected).
	//
	// The renderer will lock the mesh and it may stay locked until sometime in
	// the future when the load operation completes. The mesh will be sent over
	// the done channel once the load operation has completed if the channel is
	// not nil and sending would not block.
	LoadMesh(m *Mesh, done chan *Mesh)

	// LoadTexture should begin loading the specified texture asynchronously.
	//
	// Additionally, the renderer will set t.Loaded to true, and then invoke
	// t.ClearData(), thus allowing the source image to be garbage collected.
	//
	// The renderer will lock the texture and it may stay locked until sometime
	// in the future when the load operation completes. The texture will be
	// sent over the done channel once the load operation has completed if the
	// channel is not nil and sending would not block.
	LoadTexture(t *Texture, done chan *Texture)

	// LoadShader should begin loading the specified shader asynchronously.
	//
	// Additionally, if the shader was successfully loaded (no error log was
	// written) then the renderer will set s.Loaded to true, and then invoke
	// s.ClearData(), thus allowing the source data slices to be garbage
	// collected.
	//
	// The renderer will lock the shader and it may stay locked until sometime
	// in the future when the load operation completes. The shader will be sent
	// over the done channel once the load operation has completed if the
	// channel is not nil and sending would not block.
	LoadShader(s *Shader, done chan *Shader)

	// RenderToTexture creates and returns a canvas that when rendered to,
	// stores the results into one or multiple of the tree textures (Color,
	// Depth, Stencil) of the given configuration.
	//
	// If the any of the configuration&#39;s formats are not supported by the
	// graphics hardware (i.e. not in GPUInfo.RTTFormats), then nil is
	// returned.
	//
	// If the given configuration is not valid (see the cfg.Valid method) then
	// a panic will occur.
	//
	// Any non-nil texture in the configuration will be set to loaded, will
	// have ClearData() called on it, and will have it&#39;s bounds set to
	// cfg.Bounds.
	RenderToTexture(cfg RTTConfig) Canvas
}</pre>
		<p>
Renderer is capable of loading meshes, textures, and shaders. A renderer can
be drawn to as it implements the Canvas interface, and can also be used to
All methods must be safe to call from multiple goroutines.
</p>

	</span>

	
	
		<h1 id="Nil" class="hdr pkg hdr-function"><a href="#Nil" title="permalink">»</a>&nbsp;func Nil() Renderer <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Nil() Renderer</pre>
			<p>
Nil returns a renderer that does not actually render anything.
</p>

		</span>
	

	
	

	
	<h1 id="Shader" class="hdr pkg hdr-type"><a href="#Shader" title="permalink">»</a>&nbsp;type Shader <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Shader struct {
	sync.RWMutex

	// The native object of this shader. Once loaded (if no compiler error
	// occured) then the renderer using this shader must assign a value to this
	// field. Typically clients should not assign values to this field at all.
	NativeShader

	// Weather or not this shader is currently loaded or not.
	Loaded	bool

	// If true then when this shader is loaded the data sources of it will be
	// kept instead of being set to nil (which allows them to be garbage
	// collected).
	KeepDataOnLoad	bool

	// The name of the shader, optional (used in the shader compilation error
	// log).
	Name	string

	// The GLSL vertex shader source.
	GLSLVert	[]byte

	// The GLSL fragment shader.
	GLSLFrag	[]byte

	// A map of names and values to use as inputs for the shader program while
	// rendering. Values must be of the following data types or else they will
	// be ignored:
	//  bool
	//  float32
	//  []float32
	//  gfx.Vec3
	//  []gfx.Vec3
	//  gfx.Vec4
	//  []gfx.Vec4
	//  gfx.Mat4
	//  []gfx.Mat4
	Inputs	map[string]interface{}

	// The error log from compiling the shader program, if any. Only set once
	// the shader is loaded.
	Error	[]byte
}</pre>
		<p>
Shader represents a single shader program.
</p>
<p>
Clients are responsible for utilizing the RWMutex of the shader when using
it or invoking methods.
</p>

	</span>

	
	
		<h1 id="NewShader" class="hdr pkg hdr-function"><a href="#NewShader" title="permalink">»</a>&nbsp;func NewShader(name string) *Shader <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func NewShader(name string) *Shader</pre>
			<p>
NewShader returns a new, initialized *Shader object with the given name.
</p>

		</span>
	

	
	
		
		<h1 id="Shader.ClearData" class="hdr pkg hdr-method"><a href="#Shader.ClearData" title="permalink">»</a>&nbsp;func (s *Shader) ClearData() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shader) ClearData()</pre>
			<p>
ClearData sets the data slices (s.GLSLVert, s.Error, etc) of this shader to
nil if s.KeepDataOnLoad is set to false.
</p>

		</span>
	
		
		<h1 id="Shader.Copy" class="hdr pkg hdr-method"><a href="#Shader.Copy" title="permalink">»</a>&nbsp;func (s *Shader) Copy() *Shader <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shader) Copy() *Shader</pre>
			<p>
Copy returns a new copy of this Shader. Explicitly not copied over is the
native shader, the OnLoad slice, the Loaded status, and error log slice.
</p>

		</span>
	
		
		<h1 id="Shader.Destroy" class="hdr pkg hdr-method"><a href="#Shader.Destroy" title="permalink">»</a>&nbsp;func (s *Shader) Destroy() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shader) Destroy()</pre>
			<p>
Destroy destroys this shader for use by other callees to NewShader. You must
not use it after calling this method. This makes an implicit call to
s.NativeShader.Destroy.
</p>
<p>
The shader&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Shader.Reset" class="hdr pkg hdr-method"><a href="#Shader.Reset" title="permalink">»</a>&nbsp;func (s *Shader) Reset() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shader) Reset()</pre>
			<p>
Reset resets this shader to it&#39;s default (NewShader) state.
</p>
<p>
The shader&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	

	
	<h1 id="State" class="hdr pkg hdr-type"><a href="#State" title="permalink">»</a>&nbsp;type State <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type State struct {
	// A single alpha transparency mode describing how transparent parts of
	// of the object are to be rendered.
	// Must be one of: NoAlpha, BlendedAlpha, BinaryAlpha, AlphaToCoverage
	AlphaMode	AlphaMode

	// Blend represents how blending between existing (source) and new
	// (destination) pixels in the color buffer occurs when AlphaMode ==
	// BlendedAlpha.
	Blend	BlendState

	// Whether or not red/green/blue/alpha should be written to the color
	// buffer or not when rendering this object.
	WriteRed, WriteGreen, WriteBlue, WriteAlpha	bool

	// Whether or not dithering should be used when rendering the object.
	Dithering	bool

	// Whether or not depth testing and depth writing should be enabled when
	// rendering the object.
	DepthTest, DepthWrite	bool

	// The comparison operator to use for depth testing against existing pixels
	// in the depth buffer.
	DepthCmp	Cmp

	// Whether or not stencil testing should be enabled when rendering the
	// object.
	StencilTest	bool

	// Whether or not (and how) face culling should occur when rendering
	// the object.
	// Must be one of: BackFaceCulling, FrontFaceCulling, NoFaceCulling
	FaceCulling	FaceCullMode

	// The stencil state for front and back facing pixels, respectively.
	StencilFront, StencilBack	StencilState
}</pre>
		<p>
State represents a generic set of graphics state properties to be used when
rendering a graphics object. Changes to such properties across multiple draw
calls (called &#39;graphics state changes&#39; or &#39;render state changes&#39;) have a
performance cost.
</p>
<p>
The performance penalty mentioned depends on several factors (graphics
hardware, drivers, the specific property being changed, etc). The important
factor to recognize is that multiple draw calls are faster when the objects
being draw would cause less changes to the graphics state than the
previously drawn object.
</p>

	</span>

	
	

	
	
		
		<h1 id="State.Compare" class="hdr pkg hdr-method"><a href="#State.Compare" title="permalink">»</a>&nbsp;func (s State) Compare(other State) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s State) Compare(other State) bool</pre>
			<p>
Compare compares this state against the other one using DefaultState as a
reference when inequality occurs and returns whether or not this state
should sort before the other one for purposes of state sorting.
</p>

		</span>
	

	
	<h1 id="StencilOp" class="hdr pkg hdr-type"><a href="#StencilOp" title="permalink">»</a>&nbsp;type StencilOp <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type StencilOp uint8</pre>
		<p>
StencilOp represents a single stencil operation to occur when the stencil
function passes, like SKeep, SReplace, etc.
</p>

	</span>

	
	

	
	

	
	<h1 id="StencilState" class="hdr pkg hdr-type"><a href="#StencilState" title="permalink">»</a>&nbsp;type StencilState <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type StencilState struct {
	// A mask that will be AND&#39;d with each pixel to be written to the stencil
	// buffer, e.g. 0xFFFF would allow writing to the full range of every pixel
	// in the stencil buffer when rendering the object.
	WriteMask	uint

	// A mask that will be AND&#39;d with each pixel to be read/compared to the
	// existing value in the stencil buffer, e.g. 0xFFFF would disable the use
	// of the mask altogether.
	ReadMask	uint

	// The reference value that will be used to compare existing values in the
	// stencil buffer against, e.g. if s.Reference == 2 and if s.Func ==
	// GreaterOrEqual, then any value below 2 would not be affected.
	Reference	uint

	// Fail specifies what stencil operation should occur when the stencil test
	// fails.
	//
	// Any predefined StencilOp constant is accepted.
	Fail	StencilOp

	// DepthFail specifies what stencil operation should occur when the stencil
	// test passes but the depth test fails.
	//
	// Any predefined StencilOp constant is accepted.
	DepthFail	StencilOp

	// DepthPass specifies what stencil operation should occur when the stencil
	// test passes and the depth test passes.
	//
	// Any predefined StencilOp constant is accepted.
	DepthPass	StencilOp

	// Cmp specifies the comparison operator to use when comparing stencil data
	// with existing data in the stencil buffer.
	//
	// Any predefined Cmp constant is accepted.
	Cmp	Cmp
}</pre>
		<p>
StencilState represents the state to use when the stencil test occurs for a
front or back facing pixel of an object during rendering. If written in Go
it would look something like:
</p>
<pre>if (s.Reference &amp; s.ReadMask) s.Cmp (stencilValue &amp; s.ReadMask) {
    if depthTestFailed {
        stencilValue = s.DepthFail() &amp; s.WriteMask
    } else {
        stencilValue = s.DepthPass() &amp; s.WriteMask
    }
} else {
    stencilValue = s.Fail() &amp; s.WriteMask
}
</pre>

	</span>

	
	

	
	
		
		<h1 id="StencilState.Compare" class="hdr pkg hdr-method"><a href="#StencilState.Compare" title="permalink">»</a>&nbsp;func (s StencilState) Compare(other StencilState) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s StencilState) Compare(other StencilState) bool</pre>
			<p>
Compare compares this state against the other one using DefaultStencilState
as a reference when inequality occurs and returns whether or not this state
should sort before the other one for purposes of state sorting.
</p>

		</span>
	

	
	<h1 id="TexCoord" class="hdr pkg hdr-type"><a href="#TexCoord" title="permalink">»</a>&nbsp;type TexCoord <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type TexCoord struct {
	U, V float32
}</pre>
		<p>
TexCoord represents a 2D texture coordinate with U and V components.
</p>

	</span>

	
	

	
	

	
	<h1 id="TexCoordSet" class="hdr pkg hdr-type"><a href="#TexCoordSet" title="permalink">»</a>&nbsp;type TexCoordSet <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type TexCoordSet struct {
	// The slice of texture coordinates for the set.
	Slice	[]TexCoord

	// Weather or not the texture coordinates of this set have changed since
	// the last time the mesh was loaded. If set to true the renderer should
	// take note and re-upload the data slice to the graphics hardware.
	Changed	bool
}</pre>
		<p>
TexCoordSet represents a single texture coordinate set for a mesh.
</p>

	</span>

	
	

	
	

	
	<h1 id="TexFilter" class="hdr pkg hdr-type"><a href="#TexFilter" title="permalink">»</a>&nbsp;type TexFilter <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type TexFilter uint8</pre>
		<p>
TexFilter represents a single texture filter to be used for minification or
magnification of a texture during rendering.
</p>

	</span>

	
	

	
	
		
		<h1 id="TexFilter.Mipmapped" class="hdr pkg hdr-method"><a href="#TexFilter.Mipmapped" title="permalink">»</a>&nbsp;func (t TexFilter) Mipmapped() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t TexFilter) Mipmapped() bool</pre>
			<p>
Mipmapped tells if the texture filter is a mipmapped one, that is one of:
</p>
<pre>NearestMipmapNearest
LinearMipmapNearest
NearestMipmapLinear
LinearMipmapLinear
</pre>

		</span>
	
		
		<h1 id="TexFilter.String" class="hdr pkg hdr-method"><a href="#TexFilter.String" title="permalink">»</a>&nbsp;func (t TexFilter) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t TexFilter) String() string</pre>
			<p>
String returns a string representation of this TexFilter.
e.g. Nearest -&gt; &#34;Nearest&#34;
</p>

		</span>
	

	
	<h1 id="TexFormat" class="hdr pkg hdr-type"><a href="#TexFormat" title="permalink">»</a>&nbsp;type TexFormat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type TexFormat uint8</pre>
		<p>
TexFormat specifies a single texture storage format.
</p>

	</span>

	
	

	
	
		
		<h1 id="TexFormat.Bits" class="hdr pkg hdr-method"><a href="#TexFormat.Bits" title="permalink">»</a>&nbsp;func (t TexFormat) Bits() (r, g, b, a uint8) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t TexFormat) Bits() (r, g, b, a uint8)</pre>
			<p>
Bits returns the number of bits per color component in this texture format.
For example:
</p>
<pre>r, g, b, a := RGB.Bits()
r == 8 &amp;&amp; g == 8 &amp;&amp; b == 8 &amp;&amp; a == 0
</pre>
<p>
A panic will occur if the format is not one of the predefined ones in this
package.
</p>
<p>
ZeroTexFormat, DXT1, DXT3, and DXT5 formats will return only zero.
</p>

		</span>
	
		
		<h1 id="TexFormat.String" class="hdr pkg hdr-method"><a href="#TexFormat.String" title="permalink">»</a>&nbsp;func (t TexFormat) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t TexFormat) String() string</pre>
			<p>
String returns a string name for this texture format. For example:
</p>
<pre>RGBA -&gt; &#34;RGBA&#34;
</pre>

		</span>
	

	
	<h1 id="TexWrap" class="hdr pkg hdr-type"><a href="#TexWrap" title="permalink">»</a>&nbsp;type TexWrap <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type TexWrap uint8</pre>
		<p>
TexWrap represents a single way that the extra area of a texture wraps
around a mesh.
</p>

	</span>

	
	

	
	
		
		<h1 id="TexWrap.String" class="hdr pkg hdr-method"><a href="#TexWrap.String" title="permalink">»</a>&nbsp;func (t TexWrap) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t TexWrap) String() string</pre>
			<p>
String returns a string representation of this TexWrapMode.
e.g. Repeat -&gt; &#34;Repeat&#34;
</p>

		</span>
	

	
	<h1 id="Texture" class="hdr pkg hdr-type"><a href="#Texture" title="permalink">»</a>&nbsp;type Texture <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Texture struct {
	sync.RWMutex

	// The native object of this texture. Once loaded the renderer using this
	// texture must assign a value to this field. Typically clients should not
	// assign values to this field at all.
	NativeTexture

	// Weather or not this texture is currently loaded or not.
	Loaded	bool

	// If true then when this texture is loaded the data image source of it
	// will be kept instead of being set to nil (which allows it to be garbage
	// collected).
	KeepDataOnLoad	bool

	// The bounds of the texture, in the case of a texture loaded from a image
	// this should be set to the image&#39;s bounds. In the case of rendering to a
	// texture this should be set to the desired canvas resolution.
	Bounds	image.Rectangle

	// The source image of the texture, may be nil (i.e. in the case of render
	// to texture, unless downloaded).
	Source	image.Image

	// The texture format to use for storing this texture on the GPU, which may
	// result in lossy conversions (e.g. RGB would lose the alpha channel, etc).
	//
	// If the format is not supported then the renderer may use an image format
	// that is similar and is supported (and the format chosen by the renderer
	// can be determined via NativeTexture&#39;s ChosenFormat method).
	Format	TexFormat

	// The U and V wrap modes of this texture.
	WrapU, WrapV	TexWrap

	// The color of the border when a wrap mode is set to BorderColor.
	BorderColor	Color

	// The texture filtering used for minification and magnification of the
	// texture.
	MinFilter, MagFilter	TexFilter
}</pre>
		<p>
Texture represents a single 2D texture that may be applied to a mesh for
drawing.
</p>
<p>
Clients are responsible for utilizing the RWMutex of the texture when using
it or invoking methods.
</p>

	</span>

	
	
		<h1 id="NewTexture" class="hdr pkg hdr-function"><a href="#NewTexture" title="permalink">»</a>&nbsp;func NewTexture() *Texture <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func NewTexture() *Texture</pre>
			<p>
NewTexture returns a new, initialized *Texture object.
</p>

		</span>
	

	
	
		
		<h1 id="Texture.ClearData" class="hdr pkg hdr-method"><a href="#Texture.ClearData" title="permalink">»</a>&nbsp;func (t *Texture) ClearData() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Texture) ClearData()</pre>
			<p>
ClearData sets the data source image, t.Source, of this texture to nil if
t.KeepDataOnLoad is set to false.
</p>
<p>
The texture&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Texture.Copy" class="hdr pkg hdr-method"><a href="#Texture.Copy" title="permalink">»</a>&nbsp;func (t *Texture) Copy() *Texture <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Texture) Copy() *Texture</pre>
			<p>
Copy returns a new copy of this Texture. Explicitly not copied over is the
native texture, the OnLoad slice, the Loaded status, and the source image
(because the image type is not strictly known). Because the texture&#39;s source
image is not copied over, you may want to copy it directly over yourself.
</p>
<p>
The texture&#39;s read lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Texture.Destroy" class="hdr pkg hdr-method"><a href="#Texture.Destroy" title="permalink">»</a>&nbsp;func (t *Texture) Destroy() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Texture) Destroy()</pre>
			<p>
Destroy destroys this texture for use by other callees to NewTexture. You
must not use it after calling this method. This makes an implicit call to
t.NativeTexture.Destroy.
</p>
<p>
The texture&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	
		
		<h1 id="Texture.Reset" class="hdr pkg hdr-method"><a href="#Texture.Reset" title="permalink">»</a>&nbsp;func (t *Texture) Reset() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Texture) Reset()</pre>
			<p>
Reset resets this texture to it&#39;s default (NewTexture) state.
</p>
<p>
The textures&#39;s write lock must be held for this method to operate safely.
</p>

		</span>
	

	
	<h1 id="Transform" class="hdr pkg hdr-type"><a href="#Transform" title="permalink">»</a>&nbsp;type Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Transform struct {
	// contains filtered or unexported fields
}</pre>
		<p>
Transform represents a 3D transformation to a coordinate space. A transform
effectively defines the position, scale, shear, etc of the local space,
therefore it is sometimes said that a Transform is a coordinate space.
</p>
<p>
It can be safely used from multiple goroutines concurrently. It is built
from various components such as position, scale, and shear values and may
use euler or quaternion rotation. It supports a hierarchial tree system of
transforms to create complex transformations.
</p>
<p>
When in doubt about coordinate spaces it can be helpful to think about the
fact that each vertex of an object is considered to be in it&#39;s local space
and is then converted to world space for display.
</p>
<p>
Since world space serves as the common factor among all transforms (i.e.
any value in any transform&#39;s local space can be converted to world space and
back) converting between world and local/parent space can be extremely
useful for e.g. relative movement/rotation to another object&#39;s transform.
</p>

	</span>

	
	
		<h1 id="NewTransform" class="hdr pkg hdr-function"><a href="#NewTransform" title="permalink">»</a>&nbsp;func NewTransform() *Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func NewTransform() *Transform</pre>
			<p>
NewTransform returns a new *Transform with the default values (a uniform
scale of one).
</p>

		</span>
	

	
	
		
		<h1 id="Transform.Convert" class="hdr pkg hdr-method"><a href="#Transform.Convert" title="permalink">»</a>&nbsp;func (t *Transform) Convert(c CoordConv) lmath.Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Convert(c CoordConv) lmath.Mat4</pre>
			<p>
Convert returns a matrix which performs the given coordinate space
conversion.
</p>

		</span>
	
		
		<h1 id="Transform.ConvertPos" class="hdr pkg hdr-method"><a href="#Transform.ConvertPos" title="permalink">»</a>&nbsp;func (t *Transform) ConvertPos(p lmath.Vec3, c CoordConv) lmath.Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) ConvertPos(p lmath.Vec3, c CoordConv) lmath.Vec3</pre>
			<p>
ConvertPos converts the given point, p, using the given coordinate space
conversion. For instance to convert a point in local space into world space:
</p>
<pre>t.ConvertPos(p, LocalToWorld)
</pre>

		</span>
	
		
		<h1 id="Transform.ConvertRot" class="hdr pkg hdr-method"><a href="#Transform.ConvertRot" title="permalink">»</a>&nbsp;func (t *Transform) ConvertRot(r lmath.Vec3, c CoordConv) lmath.Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) ConvertRot(r lmath.Vec3, c CoordConv) lmath.Vec3</pre>
			<p>
ConvertRot converts the given rotation, r, using the given coordinate space
conversion. For instance to convert a rotation in local space into world
space:
</p>
<pre>t.ConvertRot(p, LocalToWorld)
</pre>

		</span>
	
		
		<h1 id="Transform.Copy" class="hdr pkg hdr-method"><a href="#Transform.Copy" title="permalink">»</a>&nbsp;func (t *Transform) Copy() *Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Copy() *Transform</pre>
			<p>
Copy returns a new transform with all of it&#39;s values set equal to t (i.e. a
copy of this transform).
</p>

		</span>
	
		
		<h1 id="Transform.Destroy" class="hdr pkg hdr-method"><a href="#Transform.Destroy" title="permalink">»</a>&nbsp;func (t *Transform) Destroy() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Destroy()</pre>
			<p>
Destroy destroys this transform for use by other callees to NewTransform.
You must not use it after calling this method.
</p>

		</span>
	
		
		<h1 id="Transform.Equals" class="hdr pkg hdr-method"><a href="#Transform.Equals" title="permalink">»</a>&nbsp;func (t *Transform) Equals(other *Transform) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Equals(other *Transform) bool</pre>
			<p>
Equals tells if the two transforms are equal.
</p>

		</span>
	
		
		<h1 id="Transform.IsQuat" class="hdr pkg hdr-method"><a href="#Transform.IsQuat" title="permalink">»</a>&nbsp;func (t *Transform) IsQuat() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) IsQuat() bool</pre>
			<p>
IsQuat tells if this transform is currently utilizing quaternion or euler
rotation.
</p>
<p>
The last call to either SetQuat or SetRot is what effictively determines
whether quaternion or euler rotation will be used by this transform.
</p>

		</span>
	
		
		<h1 id="Transform.LocalMat4" class="hdr pkg hdr-method"><a href="#Transform.LocalMat4" title="permalink">»</a>&nbsp;func (t *Transform) LocalMat4() lmath.Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) LocalMat4() lmath.Mat4</pre>
			<p>
LocalMat4 returns a matrix describing the space that this transform defines.
It is the matrix that is built out of the components of this transform, it
does not include any parent transformation, etc.
</p>

		</span>
	
		
		<h1 id="Transform.Mat4" class="hdr pkg hdr-method"><a href="#Transform.Mat4" title="permalink">»</a>&nbsp;func (t *Transform) Mat4() lmath.Mat4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Mat4() lmath.Mat4</pre>
			<p>
Mat4 is short-hand for:
</p>
<pre>return t.Convert(LocalToWorld)
</pre>

		</span>
	
		
		<h1 id="Transform.New" class="hdr pkg hdr-method"><a href="#Transform.New" title="permalink">»</a>&nbsp;func (t *Transform) New() *Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) New() *Transform</pre>
			<p>
New returns a new transform whose child is this one. It is short-handed for:
</p>
<pre>ret := NewTransform()
ret.SetParent(t)
</pre>

		</span>
	
		
		<h1 id="Transform.Parent" class="hdr pkg hdr-method"><a href="#Transform.Parent" title="permalink">»</a>&nbsp;func (t *Transform) Parent() Transformable <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Parent() Transformable</pre>
			<p>
Parent returns the parent of this transform, as previously set.
</p>

		</span>
	
		
		<h1 id="Transform.Pos" class="hdr pkg hdr-method"><a href="#Transform.Pos" title="permalink">»</a>&nbsp;func (t *Transform) Pos() lmath.Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Pos() lmath.Vec3</pre>
			<p>
Pos returns the local position of this transform.
</p>

		</span>
	
		
		<h1 id="Transform.Quat" class="hdr pkg hdr-method"><a href="#Transform.Quat" title="permalink">»</a>&nbsp;func (t *Transform) Quat() lmath.Quat <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Quat() lmath.Quat</pre>
			<p>
Quat returns the quaternion rotation of this transform. If this transform is
instead using euler rotation (see IsQuat) then a quaternion is created from
the euler rotation of this transform and returned.
</p>
<p>
The last call to either SetQuat or SetRot is what effictively determines
whether quaternion or euler rotation will be used by this transform.
</p>

		</span>
	
		
		<h1 id="Transform.Reset" class="hdr pkg hdr-method"><a href="#Transform.Reset" title="permalink">»</a>&nbsp;func (t *Transform) Reset() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Reset()</pre>
			<p>
Reset sets all of the values of this transform to the default ones.
</p>

		</span>
	
		
		<h1 id="Transform.Rot" class="hdr pkg hdr-method"><a href="#Transform.Rot" title="permalink">»</a>&nbsp;func (t *Transform) Rot() lmath.Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Rot() lmath.Vec3</pre>
			<p>
Rot returns the euler rotation of this transform. If this transform is
instead using quaternion (see IsQuat) rotation then it is converted to euler
rotation and returned.
</p>
<p>
The last call to either SetQuat or SetRot is what effictively determines
whether quaternion or euler rotation will be used by this transform.
</p>

		</span>
	
		
		<h1 id="Transform.Scale" class="hdr pkg hdr-method"><a href="#Transform.Scale" title="permalink">»</a>&nbsp;func (t *Transform) Scale() lmath.Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Scale() lmath.Vec3</pre>
			<p>
Scale returns the local scacle of this transform.
</p>

		</span>
	
		
		<h1 id="Transform.SetParent" class="hdr pkg hdr-method"><a href="#Transform.SetParent" title="permalink">»</a>&nbsp;func (t *Transform) SetParent(p Transformable) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) SetParent(p Transformable)</pre>
			<p>
SetParent sets a parent transform for this transform to effectively inherit
from. This allows creating complex hierarchies of transformations.
</p>
<p>
e.g. setting the parent of a camera&#39;s transform to the player&#39;s transform
makes it such that the camera follows the player.
</p>

		</span>
	
		
		<h1 id="Transform.SetPos" class="hdr pkg hdr-method"><a href="#Transform.SetPos" title="permalink">»</a>&nbsp;func (t *Transform) SetPos(p lmath.Vec3) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) SetPos(p lmath.Vec3)</pre>
			<p>
SetPos sets the local position of this transform.
</p>

		</span>
	
		
		<h1 id="Transform.SetQuat" class="hdr pkg hdr-method"><a href="#Transform.SetQuat" title="permalink">»</a>&nbsp;func (t *Transform) SetQuat(q lmath.Quat) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) SetQuat(q lmath.Quat)</pre>
			<p>
SetQuat sets the quaternion rotation of this transform.
</p>
<p>
The last call to either SetQuat or SetRot is what effictively determines
whether quaternion or euler rotation will be used by this transform.
</p>

		</span>
	
		
		<h1 id="Transform.SetRot" class="hdr pkg hdr-method"><a href="#Transform.SetRot" title="permalink">»</a>&nbsp;func (t *Transform) SetRot(r lmath.Vec3) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) SetRot(r lmath.Vec3)</pre>
			<p>
SetRot sets the euler rotation of this transform in degrees about their
respective axis (e.g. if r.X == 45 then it is 45 degrees around the X
axis).
</p>
<p>
The last call to either SetQuat or SetRot is what effictively determines
whether quaternion or euler rotation will be used by this transform.
</p>

		</span>
	
		
		<h1 id="Transform.SetScale" class="hdr pkg hdr-method"><a href="#Transform.SetScale" title="permalink">»</a>&nbsp;func (t *Transform) SetScale(s lmath.Vec3) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) SetScale(s lmath.Vec3)</pre>
			<p>
SetScale sets the local scale of this transform (e.g. a scale of
lmath.Vec3{2, 1.5, 1} would make an object appear twice as large on the local
X axis, one and a half times larger on the local Y axis, and would not scale
on the local Z axis at all).
</p>

		</span>
	
		
		<h1 id="Transform.SetShear" class="hdr pkg hdr-method"><a href="#Transform.SetShear" title="permalink">»</a>&nbsp;func (t *Transform) SetShear(s lmath.Vec3) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) SetShear(s lmath.Vec3)</pre>
			<p>
SetShear sets the local shear of this transform.
</p>

		</span>
	
		
		<h1 id="Transform.Shear" class="hdr pkg hdr-method"><a href="#Transform.Shear" title="permalink">»</a>&nbsp;func (t *Transform) Shear() lmath.Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Shear() lmath.Vec3</pre>
			<p>
Shear returns the local shear of this transform.
</p>

		</span>
	
		
		<h1 id="Transform.Transform" class="hdr pkg hdr-method"><a href="#Transform.Transform" title="permalink">»</a>&nbsp;func (t *Transform) Transform() *Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t *Transform) Transform() *Transform</pre>
			<p>
Implements Transformable interface by simply returning t.
</p>

		</span>
	

	
	<h1 id="Transformable" class="hdr pkg hdr-type"><a href="#Transformable" title="permalink">»</a>&nbsp;type Transformable <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Transformable interface {
	Transform() *Transform
}</pre>
		<p>
Transformable represents a generic interface to any object that can return
it&#39;s transformation.
</p>

	</span>

	
	

	
	

	
	<h1 id="Vec3" class="hdr pkg hdr-type"><a href="#Vec3" title="permalink">»</a>&nbsp;type Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Vec3 struct {
	X, Y, Z float32
}</pre>
		<p>
Vec3 represents a 32-bit floating point three-component vector for
compatability with graphics hardware.
lmath.Vec3 should be used anywhere that an explicit 32-bit type is not
needed.
</p>

	</span>

	
	
		<h1 id="ConvertVec3" class="hdr pkg hdr-function"><a href="#ConvertVec3" title="permalink">»</a>&nbsp;func ConvertVec3(v lmath.Vec3) Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func ConvertVec3(v lmath.Vec3) Vec3</pre>
			<p>
ConvertVec3 converts the 64-bit lmath.Vec3 to a 32-bit Vec3 vector.
</p>

		</span>
	

	
	
		
		<h1 id="Vec3.Vec3" class="hdr pkg hdr-method"><a href="#Vec3.Vec3" title="permalink">»</a>&nbsp;func (v Vec3) Vec3() lmath.Vec3 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (v Vec3) Vec3() lmath.Vec3</pre>
			<p>
Vec3 converts this 32-bit Vec3 to a 64-bit lmath.Vec3 vector.
</p>

		</span>
	

	
	<h1 id="Vec4" class="hdr pkg hdr-type"><a href="#Vec4" title="permalink">»</a>&nbsp;type Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Vec4 struct {
	X, Y, Z, W float32
}</pre>
		<p>
Vec4 represents a 32-bit floating point four-component vector for
compatability with graphics hardware.
lmath.Vec4 should be used anywhere that an explicit 32-bit type is not
needed.
</p>

	</span>

	
	
		<h1 id="ConvertVec4" class="hdr pkg hdr-function"><a href="#ConvertVec4" title="permalink">»</a>&nbsp;func ConvertVec4(v lmath.Vec4) Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func ConvertVec4(v lmath.Vec4) Vec4</pre>
			<p>
ConvertVec4 converts the 64-bit lmath.Vec4 to a 32-bit Vec4 vector.
</p>

		</span>
	

	
	
		
		<h1 id="Vec4.Vec4" class="hdr pkg hdr-method"><a href="#Vec4.Vec4" title="permalink">»</a>&nbsp;func (v Vec4) Vec4() lmath.Vec4 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (v Vec4) Vec4() lmath.Vec4</pre>
			<p>
Vec4 converts this 32-bit Vec4 to a 64-bit lmath.Vec4 vector.
</p>

		</span>
	

	
	<h1 id="VertexAttrib" class="hdr pkg hdr-type"><a href="#VertexAttrib" title="permalink">»</a>&nbsp;type VertexAttrib <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type VertexAttrib struct {
	// The literal per-vertex data slice. It must be a slice whose length is
	// exactly the same as the mesh&#39;s Vertices slice (because it is literally
	// per-vertex data). The underlying type must be one of the following or
	// else the attribute may be ignored completely:
	//  []float32
	//  [][]float32
	//  []gfx.Vec3
	//  [][]gfx.Vec3
	//  []gfx.Mat4
	//  [][]gfx.Mat4
	//  []gfx.Vec4
	//  [][]gfx.Vec4
	Data	interface{}

	// Weather or not the per-vertex data (see the Data field) has changed
	// since the last time the mesh was loaded. If set to true the renderer
	// should take note and re-upload the data slice to the graphics hardware.
	Changed	bool
}</pre>
		<p>
VertexAttrib represents a per-vertex attribute.
</p>

	</span>

	
	

	
	
		
		<h1 id="VertexAttrib.Copy" class="hdr pkg hdr-method"><a href="#VertexAttrib.Copy" title="permalink">»</a>&nbsp;func (a VertexAttrib) Copy() VertexAttrib <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a VertexAttrib) Copy() VertexAttrib</pre>
			<p>
Copy returns a new copy of this vertex attribute data set. It makes a deep
copy of the underlying Data slice. Explicitly not copied is the Changed
boolean.
</p>

		</span>
	



<h1 id="package-files" class="hdr pkg hdr-files"><a href="#package-files" title="permalink">»</a>&nbsp;Package Files <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg files">
	<p>
	<a href="https:/github.com/azul3d/gfx/blob/dev/alphamode.go" title="view source">alphamode.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/blending.go" title="view source">blending.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/camera.go" title="view source">camera.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/cmp.go" title="view source">cmp.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/color.go" title="view source">color.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/doc.go" title="view source">doc.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/facecull.go" title="view source">facecull.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/mesh.go" title="view source">mesh.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/nil.go" title="view source">nil.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/object.go" title="view source">object.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/render.go" title="view source">render.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/rtt.go" title="view source">rtt.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/shader.go" title="view source">shader.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/sort.go" title="view source">sort.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/state.go" title="view source">state.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/stencil.go" title="view source">stencil.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/texfilter.go" title="view source">texfilter.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/texture.go" title="view source">texture.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/texwrap.go" title="view source">texwrap.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/transform.go" title="view source">transform.go</a>
	
	<a href="https:/github.com/azul3d/gfx/blob/dev/types.go" title="view source">types.go</a>
	</p>

	<h2><span class="linkarea">(<a href="#" id="tagged-files-toggle">show tagged files</a>)</span></h2>
	<span id="tagged-files">
		<h2>Test Files</h2>
		<p>
		<a href="https:/github.com/azul3d/gfx/blob/dev/nil_test.go" title="view source">nil_test.go</a>
		
		<a href="https:/github.com/azul3d/gfx/blob/dev/sort_test.go" title="view source">sort_test.go</a>
		
		<a href="https:/github.com/azul3d/gfx/blob/dev/transform_test.go" title="view source">transform_test.go</a>
		</p>
	</span>
</span>


<script>
$(function() {
	$("#tagged-files").slideUp();
	var toggle = true;
	$("#tagged-files-toggle").click(function(event) {
		event.preventDefault();
		toggle = !toggle;
		if(toggle) {
			$("#tagged-files").slideUp();
			$("#tagged-files-toggle").html("show tagged files");
		} else {
			$("#tagged-files").slideDown();
			$("#tagged-files-toggle").html("hide tagged files");
		}
	});
});
</script>

	</div>
</div>


<div id="footer">
	<div>© 2014 The Azul3D Authors, All Rights Reserved.</div>
	<div>Unless noted otherwise, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code is licensed under a BSD license.</div>
</div>


<script>
$(document).ready(function() {
	$("body").css("opacity", 0);

	 
	var ValidIpAddressRegex = "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$";
	var redirect = window.location.hostname != 'azul3d.org';
	if(location.hostname == "localhost" || location.hostname.search(ValidIpAddressRegex) != -1) {
		
		
		redirect = false;
	}
	if(redirect){
	    window.top.location.href = 'http://azul3d.org'; 
	}
});

$(window).ready(function() {
	var fadeIn = function(self, delay) {
		self.css("opacity", 0).delay(delay).animate({opacity: 1}, "slow");
	}

	var fromSameSite = document.referrer.indexOf(location.protocol + "//" + location.host) === 0;


	
	
	var longPage = $(document).height() > $(window).height() * 3;
	if(fromSameSite || longPage) {
		fadeIn($("body"), 10);
	} else {
		var workingIndex = 0;
		var speed = 75;
		$("#content").children().each(function(index) {
			fadeIn($(this), 1000 + (speed * workingIndex));
			workingIndex++;
			if($(this).hasClass("list")) {
				$(this).children().each(function(index) {
					fadeIn($(this), 1000 + (speed * workingIndex));
					workingIndex++;
				});
			}
		});

		var w = $("#shortbar").width();
		$("#shortbar").css({
			right: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			right: "0px",
			opacity: 1
			}, "slow");

		var w = $("#navigation").width();
		$("#navigation").css({
			left: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			left: "0px",
			opacity: 1
			}, "slow");

		fadeIn($("#logo"), 10);
		fadeIn($("body"), 10);
	}
})
</script>
	</body>
</html>



