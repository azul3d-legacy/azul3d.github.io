

<!DOCTYPE html>
<html lang="en">
	<head>
		
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<meta name="description" content="A 3D game engine written in Go!">
		<meta name="author" content="The Azul3D Authors">
		<title>Azul3D</title>
		<link rel="shortcut icon" href="/content/favicon.png"> 

		
		<link rel="stylesheet" type="text/css" href="/content/reset.css">

		
		<link href='http://fonts.googleapis.com/css?family=Audiowide' rel='stylesheet' type='text/css'>
		<link href='http://fonts.googleapis.com/css?family=Cutive+Mono' rel='stylesheet' type='text/css'>

		
		<link href='/content/dejavusans_book/stylesheet.css' rel='stylesheet' type='text/css'>

		
		<link href='/content/brandico/brandico.css' rel='stylesheet' type='text/css'>

		
		

		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

		
		<link rel="stylesheet" type="text/css" href="/content/stylesheet.css">
		<link rel="stylesheet" type="text/css" href="/content/mq.css">
	</head>
	<body>


<div id="top"></div>

































<div id="toparea">
	<div id="logo">
		<a href="/"><span class="biohazard">☣</span>
		<span>Azul3D</span></a>
	</div>

	<div id="shortbar">
		<a href="https://github.com/azul3d" target="_blank"><i class="icon-github menuIcon"></i><div class="title">GitHub</div></a>
		<a href="https://twitter.com/hashtag/azul3d" target="_blank"><i class="icon-twitter-bird menuIcon"></i><div class="title">Twitter</div></a>
		<a href="https://www.facebook.com/pages/Azul3D/651643168254798" target="_blank"><i class="icon-facebook menuIcon"></i><div class="title">Facebook</div></a>
		<a href="https://groups.google.com/forum/#!forum/azul3d" target="_blank" class="mail"><i class="menuIcon mailIcon">✉</i><div class="title">Mailing List</div></a>
	</div>
</div>

<div id="navigation">
	<h1>Navigation</h1>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/">Home</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/news">News</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/packages.html">Packages</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/doc/faq.html">FAQ</a></span></span>
	</span>
</div>


<div id="content-container">
	<div id="content" class="pkg-content">






<h1 class="hdr pkg hdr-general">Package chippy</h1>
<span class="section pkg general">
	
		<p><em>In Development</em></p>
	
	<span class="pkg import">import "azul3d.org/chippy.v0"</span>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#versions">Versions</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#overview">Overview</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#index">Index</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#package-files">Package Files</a></span></span>
	</span>
	
		<h2>WARNING!</h2>
		<span class="sub">
			
				<p>This version is the in-development -- <em><strong>unstable</strong></em> -- version of this package. Backwards incompatable changes will be made to this package in the future and as such <em>you should not use this version</em>! Please use the latest release <a href="/chippy.v1">here</a>.</p>
			
		</span>
	

	
</span>



<h1 id="versions" class="hdr pkg hdr-versions"><a href="#versions" title="permalink">»</a>&nbsp;Versions <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg versions">
	
		<p>You are viewing an older version of this package (v0).</p>
	
	<p>Other versions of this package are available as follows. Version zero (v0) is the in-development version of this package and should not generally be used (see <a href="/doc/versioning.html#development-versions">here</a> for more details).</p>
	<span class="list">
		
			
			
			
				
					<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="chippy.v1" title="azul3d.org/chippy.v1">v1</a> (latest version)</span></span>
				
			
		
			
			
			
				<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="chippy.v0" title="azul3d.org/chippy.v0">v0</a> (in development)</span></span>
			
		
	</span>
</span>



<h1 id="overview" class="hdr pkg hdr-overview"><a href="#overview" title="permalink">»</a>&nbsp;Overview <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg overview">
	<p>
Package chippy implements cross platform window management, and window
rendering access.
</p>
<h3 id="hdr-Thread_Safety">Thread Safety</h3>
<p>
Chippy is thread safe, and can be fully used from within multiple
goroutines without any worry about operating system threads, or locks, etc.
</p>
<p>
It should be explicitly noted that while Chippy and it&#39;s API&#39;s are thread
safe, anything to do with OpenGL needs special care regarding thread
safety.
</p>
<h3 id="hdr-OpenGL_Support">OpenGL Support</h3>
<p>
Creating both new and old style OpenGL contexts is supported (this allows
creating an OpenGL context of any version). Many platform specific OpenGL
functions are abstracted away for you (such as WGL, GLX, etc extensions).
Shared OpenGL contexts, multisampling, vertical sync toggling, etc are all
supported.
</p>
<p>
Chippy works with all OpenGL wrappers, it does not provide any OpenGL
wrappers itself (although azul3d.org/v1/native/gl has some good ones).
</p>
<p>
Although we handle the platform-specific parts of OpenGL for you, no magic
is performed: OpenGL still uses thread local storage so when working with
OpenGL&#39;s API you&#39;ll need to utilize runtime.LockOSThread() properly.
</p>
<h3 id="hdr-Microsoft_Windows_FAQ">Microsoft Windows FAQ</h3>
<p>
What versions of Windows are supported?
</p>
<pre>Chippy requires Windows XP or higher.

It might also work on Windows 2000 Professional/Server editions, but
support for these version is not tested actively.
</pre>
<p>
How do I add an application icon to my program?
</p>
<pre>You can place .syso files with the source of your main package, and the
6l/8l linker will link that file with your program.

Take an look at the &#34;app.rc&#34; file inside the chippy/tests/data folder for
more information. Also look at the single window test located in the
chippy/tests/chippy_window_single directory for an example of this.
</pre>
<p>
How do I stop the command prompt from appearing when my application starts?
</p>
<pre>You can stop the terminal from appearing by using the 8l/6l linker flag
&#34;-H windowsgui&#34; on your &#39;go install&#39; command, like so:

go install -ldflags &#34;-H windowsgui&#34; path/to/pkg
</pre>
<h3 id="hdr-Linux_X11_FAQ">Linux-X11 FAQ</h3>
<p>
What X extensions are needed?
</p>
<pre>GLX 1.4 (required, for OpenGL tasks, 1.4 is needed for multisampling)
XRandR 1.2 (optional, used for screen-mode switching, etc)
XInput 2.0 (required, for raw mouse input)
XKB 1.0 (required, for keyboard input)
</pre>
<p>
What about a pure Wayland client?
</p>
<pre>A pure Wayland implementation would be interesting and could be enabled
using a build-tag until Wayland becomes more main-stream, but for now
Wayland does have the ability to still run X applications so Chippy does
still work on Wayland.

A pure Wayland client is not a priority right now, but we are open to
working with a contributor who would like to add this feature.
</pre>

</span>


<h1 id="index" class="hdr pkg hdr-index"><a href="#index" title="permalink">»</a>&nbsp;Index <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg index">
	<span class="list">
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#constants">Constants</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#variables">Variables</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DisplayName">func DisplayName() string</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Exit">func Exit()</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Init">func Init() error</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#IsInit">func IsInit() bool</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MainLoop">func MainLoop()</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MainLoopFrames">func MainLoopFrames() chan func() bool</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RefreshScreens">func RefreshScreens()</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screens">func Screens() []*Screen</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SetDebugOutput">func SetDebugOutput(w io.Writer)</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SetDisplayName">func SetDisplayName(displayName string)</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SetWindowsKeyDisabled">func SetWindowsKeyDisabled(disabled bool)</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#WindowsKeyDisabled">func WindowsKeyDisabled() bool</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Blitable">type Blitable</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CloseEvent">type CloseEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CloseEvent.String">func (ev CloseEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CloseEvent.Time">func (ev CloseEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Cursor">type Cursor</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CursorPositionEvent">type CursorPositionEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CursorPositionEvent.String">func (ev CursorPositionEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CursorPositionEvent.Time">func (ev CursorPositionEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CursorWithinEvent">type CursorWithinEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CursorWithinEvent.String">func (ev CursorWithinEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CursorWithinEvent.Time">func (ev CursorWithinEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DestroyedEvent">type DestroyedEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DestroyedEvent.String">func (ev DestroyedEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DestroyedEvent.Time">func (ev DestroyedEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Event">type Event</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#FocusedEvent">type FocusedEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#FocusedEvent.String">func (ev FocusedEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#FocusedEvent.Time">func (ev FocusedEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GLConfig">type GLConfig</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GLChooseConfig">func GLChooseConfig(possible []*GLConfig, minConfig, maxConfig *GLConfig) *GLConfig</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GLConfig.Equals">func (c *GLConfig) Equals(other *GLConfig) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GLConfig.String">func (c *GLConfig) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GLContext">type GLContext</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GLContextFlags">type GLContextFlags</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GLRenderable">type GLRenderable</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MaximizedEvent">type MaximizedEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MaximizedEvent.String">func (ev MaximizedEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MaximizedEvent.Time">func (ev MaximizedEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MinimizedEvent">type MinimizedEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MinimizedEvent.String">func (ev MinimizedEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MinimizedEvent.Time">func (ev MinimizedEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeScreen">type NativeScreen</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeScreenMode">type NativeScreenMode</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow">type NativeWindow</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.Class">func (w *NativeWindow) Class() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.GLConfig">func (w *NativeWindow) GLConfig() *GLConfig</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.GLConfigs">func (w *NativeWindow) GLConfigs() (configs []*GLConfig)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.GLCreateContext">func (w *NativeWindow) GLCreateContext(glVersionMajor, glVersionMinor uint, flags GLContextFlags, share GLContext) (GLContext, error)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.GLDestroyContext">func (w *NativeWindow) GLDestroyContext(c GLContext)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.GLMakeCurrent">func (w *NativeWindow) GLMakeCurrent(c GLContext)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.GLSetConfig">func (w *NativeWindow) GLSetConfig(config *GLConfig)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.GLSetVerticalSync">func (w *NativeWindow) GLSetVerticalSync(mode VSyncMode)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.GLSwapBuffers">func (w *NativeWindow) GLSwapBuffers()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.GLVerticalSync">func (w *NativeWindow) GLVerticalSync() VSyncMode</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.HWND">func (w *NativeWindow) HWND() win32.HWND</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.PixelBlit">func (w *NativeWindow) PixelBlit(x, y uint, image *image.RGBA)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NativeWindow.PixelClear">func (w *NativeWindow) PixelClear(rect image.Rectangle)</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PaintEvent">type PaintEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PaintEvent.String">func (ev PaintEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PaintEvent.Time">func (ev PaintEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PositionEvent">type PositionEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PositionEvent.String">func (ev PositionEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PositionEvent.Time">func (ev PositionEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ResizedEvent">type ResizedEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ResizedEvent.String">func (ev ResizedEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ResizedEvent.Time">func (ev ResizedEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen">type Screen</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DefaultScreen">func DefaultScreen() *Screen</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen.Equals">func (s *Screen) Equals(other *Screen) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen.Mode">func (s *Screen) Mode() *ScreenMode</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen.Modes">func (s *Screen) Modes() []*ScreenMode</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen.Name">func (s *Screen) Name() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen.OriginalMode">func (s *Screen) OriginalMode() *ScreenMode</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen.PhysicalSize">func (s *Screen) PhysicalSize() (width float32, height float32)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen.Restore">func (s *Screen) Restore()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen.SetMode">func (s *Screen) SetMode(newMode *ScreenMode) error</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Screen.String">func (s *Screen) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ScreenChangedEvent">type ScreenChangedEvent</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ScreenChangedEvent.String">func (ev ScreenChangedEvent) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ScreenChangedEvent.Time">func (ev ScreenChangedEvent) Time() time.Time</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ScreenMode">type ScreenMode</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ScreenMode.BytesPerPixel">func (m *ScreenMode) BytesPerPixel() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ScreenMode.Equals">func (m *ScreenMode) Equals(other *ScreenMode) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ScreenMode.RefreshRate">func (m *ScreenMode) RefreshRate() float32</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ScreenMode.Resolution">func (m *ScreenMode) Resolution() (width, height int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ScreenMode.String">func (m *ScreenMode) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#VSyncMode">type VSyncMode</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#VSyncMode.String">func (mode VSyncMode) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#VSyncMode.Valid">func (mode VSyncMode) Valid() bool</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#W32GLContext">type W32GLContext</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window">type Window</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NewWindow">func NewWindow() *Window</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.AlwaysOnTop">func (w *Window) AlwaysOnTop() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.AspectRatio">func (w *Window) AspectRatio() float32</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.CloseEvents">func (w *Window) CloseEvents(ch chan Event)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Cursor">func (w *Window) Cursor() *Cursor</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.CursorGrabbed">func (w *Window) CursorGrabbed() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.CursorPosition">func (w *Window) CursorPosition() (x, y int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.CursorWithin">func (w *Window) CursorWithin() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Decorated">func (w *Window) Decorated() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Destroy">func (w *Window) Destroy()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Destroyed">func (w *Window) Destroyed() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Events">func (w *Window) Events() chan Event</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.EventsBuffer">func (w *Window) EventsBuffer(bufferSize int) chan Event</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Extents">func (w *Window) Extents() (left, right, bottom, top int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Focused">func (w *Window) Focused() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.FreeCursor">func (w *Window) FreeCursor(cursor *Cursor)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Fullscreen">func (w *Window) Fullscreen() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Icon">func (w *Window) Icon() image.Image</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Maximized">func (w *Window) Maximized() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.MaximumSize">func (w *Window) MaximumSize() (width, height int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Minimized">func (w *Window) Minimized() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.MinimumSize">func (w *Window) MinimumSize() (width, height int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Notify">func (w *Window) Notify()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Open">func (w *Window) Open(screen *Screen) error</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Opened">func (w *Window) Opened() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.OriginalScreen">func (w *Window) OriginalScreen() *Screen</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Position">func (w *Window) Position() (x, y int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.PrepareCursor">func (w *Window) PrepareCursor(cursor *Cursor)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Screen">func (w *Window) Screen() *Screen</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetAlwaysOnTop">func (w *Window) SetAlwaysOnTop(alwaysOnTop bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetAspectRatio">func (w *Window) SetAspectRatio(ratio float32)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetCursor">func (w *Window) SetCursor(cursor *Cursor)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetCursorGrabbed">func (w *Window) SetCursorGrabbed(grabbed bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetCursorPosition">func (w *Window) SetCursorPosition(x, y int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetDecorated">func (w *Window) SetDecorated(decorated bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetFullscreen">func (w *Window) SetFullscreen(fullscreen bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetIcon">func (w *Window) SetIcon(icon image.Image)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetMaximized">func (w *Window) SetMaximized(maximized bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetMaximumSize">func (w *Window) SetMaximumSize(width, height int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetMinimized">func (w *Window) SetMinimized(minimized bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetMinimumSize">func (w *Window) SetMinimumSize(width, height int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetPosition">func (w *Window) SetPosition(x, y int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetPositionCenter">func (w *Window) SetPositionCenter(screen *Screen)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetSize">func (w *Window) SetSize(width, height int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetTitle">func (w *Window) SetTitle(title string)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetTransparent">func (w *Window) SetTransparent(transparent bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.SetVisible">func (w *Window) SetVisible(visible bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Size">func (w *Window) Size() (width, height int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.String">func (w *Window) String() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Title">func (w *Window) Title() string</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Transparent">func (w *Window) Transparent() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Window.Visible">func (w *Window) Visible() bool</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#X11GLContext">type X11GLContext</a></span></span>
			
			
		
	</span>
</span>




<h1 id="constants" class="hdr pkg hdr-constants"><a href="#constants" title="permalink">»</a>&nbsp;Constants <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg constants">
	
		<pre>const (
	GLDebug	GLContextFlags	= iota
	GLForwardCompatible
	GLCoreProfile
	GLCompatibilityProfile
)</pre>
		<p></p>
	
		<pre>const (
	VerticalSync	VSyncMode	= iota
	NoVerticalSync
	AdaptiveVerticalSync
)</pre>
		<p></p>
	
</span>





<h1 id="variables" class="hdr pkg hdr-variables"><a href="#variables" title="permalink">»</a>&nbsp;Variables <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg variables">
	
		<pre>var (
	ErrInvalidGLXVersion	= errors.New(&#34;GLX version 1.4 is required but not available.&#34;)
	ErrInvalidXKBVersion	= errors.New(fmt.Sprintf(&#34;XKB version %d.%d is required but not available.&#34;, xkbMinMajor, xkbMinMinor))
)</pre>
		<p></p>
	
		<pre>var (
	// Could happen due to lack of hardware support for the screen mode, or the driver may reject
	// the screen mode as well, really this could be generically anything but is typically an
	// hardware or driver issue using the screen mode.
	//
	// You should never take away the screen mode as an option from the user; as it is possible the
	// user may change an configuration setting of some sort with their operating system that will
	// allow the screen mode to be used properly.
	ErrBadScreenMode	= errors.New(&#34;unable to switch screen mode; hardware or drivers do not support the mode.&#34;)

	// Only Microsoft Windows will ever return this error, systems that use DualView will sometimes
	// ignore screen mode change requests.
	ErrDualViewCapable	= errors.New(&#34;unable to switch screen mode; the system is DualView capable.&#34;)
)</pre>
		<p></p>
	
		<pre>var (
	// Describes the worst possible OpenGL frame buffer configuration, this is
	// typically used as a parameter to GLChooseConfig.
	GLWorstConfig	= &amp;GLConfig{
		Accelerated:	false,
		Transparent:	false,
		RedBits:	0,
		GreenBits:	0,
		BlueBits:	0,
		AlphaBits:	0,
		AccumRedBits:	0,
		AccumGreenBits:	0,
		AccumBlueBits:	0,
		AccumAlphaBits:	0,
		Samples:	0,
		AuxBuffers:	0,
		DepthBits:	0,
		StencilBits:	0,
		DoubleBuffered:	false,
		StereoScopic:	false,
	}

	// Describes the worst possible OpenGL frame buffer configuration while
	// still being hardware-accelerated by the graphics card, this is typically
	// used as a parameter to GLChooseConfig.
	GLWorstHWConfig	= &amp;GLConfig{
		Accelerated:	true,
		Transparent:	false,
		RedBits:	0,
		GreenBits:	0,
		BlueBits:	0,
		AlphaBits:	0,
		AccumRedBits:	0,
		AccumGreenBits:	0,
		AccumBlueBits:	0,
		AccumAlphaBits:	0,
		Samples:	0,
		AuxBuffers:	0,
		DepthBits:	0,
		StencilBits:	0,
		DoubleBuffered:	false,
		StereoScopic:	false,
	}

	// Describes the best possible OpenGL frame buffer configuration that does
	// not have any transparency, this is typically used as a parameter to
	// GLChooseConfig.
	GLBestConfig	= &amp;GLConfig{
		Accelerated:	true,
		Transparent:	true,
		RedBits:	255,
		GreenBits:	255,
		BlueBits:	255,
		AlphaBits:	255,
		AccumRedBits:	255,
		AccumGreenBits:	255,
		AccumBlueBits:	255,
		AccumAlphaBits:	255,
		Samples:	255,
		AuxBuffers:	255,
		DepthBits:	255,
		StencilBits:	255,
		DoubleBuffered:	true,
		StereoScopic:	false,
	}
)</pre>
		<p></p>
	
		<pre>var (
	ErrGLVersionNotSupported = errors.New(&#34;opengl version is not supported&#34;)
)</pre>
		<p></p>
	
</span>





	<h1 id="DisplayName" class="hdr pkg hdr-function"><a href="#DisplayName" title="permalink">»</a>&nbsp;func DisplayName() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func DisplayName() string</pre>
		<p>
DisplayName returns the display_name string, as it was passed into SetDisplayName.
</p>
<p>
This function is only available on Linux.
</p>

	</span>

	<h1 id="Exit" class="hdr pkg hdr-function"><a href="#Exit" title="permalink">»</a>&nbsp;func Exit() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Exit()</pre>
		<p>
Exit will exit the main loop previously entered via MainLoop(). All windows
will be destroyed, etc.
</p>
<p>
You may call Init() again after calling this function should you want to
re-gain access to the API.
</p>

	</span>

	<h1 id="Init" class="hdr pkg hdr-function"><a href="#Init" title="permalink">»</a>&nbsp;func Init() error <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Init() error</pre>
		<p>
Init initializes Chippy, returning an error if there is a problem initializing some
lower level part of Chippy, if an error was returned, it is disallowed to call any
other Chippy functions. (And any attempt to do so will cause the program to panic.)
</p>

	</span>

	<h1 id="IsInit" class="hdr pkg hdr-function"><a href="#IsInit" title="permalink">»</a>&nbsp;func IsInit() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func IsInit() bool</pre>
		<p>
IsInit returns whether Chippy has been initialized via a previous call to
Init().
</p>
<p>
IsInit() returns false if Destroy() was previously called.
</p>

	</span>

	<h1 id="MainLoop" class="hdr pkg hdr-function"><a href="#MainLoop" title="permalink">»</a>&nbsp;func MainLoop() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func MainLoop()</pre>
		<p>
MainLoop enters chippy&#39;s main loop.
</p>
<p>
This function *must* be called on the main thread (due to the restrictions
that some platforms place, I.e. Cocoa on OS-X)
</p>
<p>
It&#39;s best to place this function inside either your init or main function.
</p>
<p>
This function will not return until chippy.Exit() is called.
</p>
<p>
If chippy is not initialized (via an previous call to the Init() function)
then a panic will occur.
</p>

	</span>

	<h1 id="MainLoopFrames" class="hdr pkg hdr-function"><a href="#MainLoopFrames" title="permalink">»</a>&nbsp;func MainLoopFrames() chan func() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func MainLoopFrames() chan func() bool</pre>
		<p>
MainLoopFrames returns an channel of functions which return an boolean
status as to whether you should continue running the &#39;main loop&#39;.
</p>
<p>
Typically you would not use this function and would instead use the
MainLoop() function.
</p>
<p>
This is for advanced users where the main loop is required to be shared with
some other external library. I.e. this allows for communicative main loop
handling.
</p>
<p>
See the MainLoop() function source code in chippy.go for an example of using
this function properly.
</p>
<p>
This function should only really be called once (the same channel is always
returned).
</p>

	</span>

	<h1 id="RefreshScreens" class="hdr pkg hdr-function"><a href="#RefreshScreens" title="permalink">»</a>&nbsp;func RefreshScreens() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func RefreshScreens()</pre>
		<p>
RefreshScreens queries for all available screens, and updates the internal
cache returned by the Screens() function, such that the Screens() function
returns new set of attatched/detatched Screen devices.
</p>

	</span>

	<h1 id="Screens" class="hdr pkg hdr-function"><a href="#Screens" title="permalink">»</a>&nbsp;func Screens() []*Screen <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Screens() []*Screen</pre>
		<p>
Screens returns all available, attached, and activated screens possible.
Once this function is called, the result is cached such that future calls to
this function are faster and return the cached result.
</p>
<p>
To update the internal screen cache, see the RefreshScreens function.
</p>

	</span>

	<h1 id="SetDebugOutput" class="hdr pkg hdr-function"><a href="#SetDebugOutput" title="permalink">»</a>&nbsp;func SetDebugOutput(w io.Writer) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func SetDebugOutput(w io.Writer)</pre>
		<p>
SetDebugOutput specifies the io.Writer that debug output will be written to (ioutil.Discard by
default).
</p>

	</span>

	<h1 id="SetDisplayName" class="hdr pkg hdr-function"><a href="#SetDisplayName" title="permalink">»</a>&nbsp;func SetDisplayName(displayName string) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func SetDisplayName(displayName string)</pre>
		<p>
SetDisplayName sets the string that will be passed into XOpenDisplay; equivalent to the DISPLAY
environment variable on posix complaint systems.
</p>
<p>
If set, this is used in place of the default DISPLAY environment variable.
</p>
<p>
This function is only available on Linux.
</p>

	</span>

	<h1 id="SetWindowsKeyDisabled" class="hdr pkg hdr-function"><a href="#SetWindowsKeyDisabled" title="permalink">»</a>&nbsp;func SetWindowsKeyDisabled(disabled bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func SetWindowsKeyDisabled(disabled bool)</pre>
		
	</span>

	<h1 id="WindowsKeyDisabled" class="hdr pkg hdr-function"><a href="#WindowsKeyDisabled" title="permalink">»</a>&nbsp;func WindowsKeyDisabled() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func WindowsKeyDisabled() bool</pre>
		
	</span>





	
	<h1 id="Blitable" class="hdr pkg hdr-type"><a href="#Blitable" title="permalink">»</a>&nbsp;type Blitable <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Blitable interface {
	// PixelBlit blits the specified RGBA image onto the window, at the given X
	// and Y coordinates.
	PixelBlit(x, y uint, pixels *image.RGBA)

	// PixelClear clears the given rectangle on the window&#39;s client region.
	PixelClear(rect image.Rectangle)
}</pre>
		
	</span>

	
	

	
	

	
	<h1 id="CloseEvent" class="hdr pkg hdr-type"><a href="#CloseEvent" title="permalink">»</a>&nbsp;type CloseEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CloseEvent struct {
	T time.Time
}</pre>
		<p>
CloseEvent is an event where the user attempted to close the window, using
either the exit button, an quick-key combination like alt+F4, etc.
</p>

	</span>

	
	

	
	
		
		<h1 id="CloseEvent.String" class="hdr pkg hdr-method"><a href="#CloseEvent.String" title="permalink">»</a>&nbsp;func (ev CloseEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev CloseEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="CloseEvent.Time" class="hdr pkg hdr-method"><a href="#CloseEvent.Time" title="permalink">»</a>&nbsp;func (ev CloseEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev CloseEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="Cursor" class="hdr pkg hdr-type"><a href="#Cursor" title="permalink">»</a>&nbsp;type Cursor <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Cursor struct {
	// Cursor image, internally it will be converted to an RGBA image.
	Image	image.Image

	// Cursor Hotspot
	X, Y	uint
}</pre>
		<p>
Cursor represents the image and hotspot of an graphical mouse cursor.
</p>

	</span>

	
	

	
	

	
	<h1 id="CursorPositionEvent" class="hdr pkg hdr-type"><a href="#CursorPositionEvent" title="permalink">»</a>&nbsp;type CursorPositionEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CursorPositionEvent struct {
	// Position of cursor relative to the window&#39;s client region.
	X, Y	float64

	T	time.Time
}</pre>
		<p>
CursorPositionEvent is an event where the user moved the mouse cursor inside
the window&#39;s client region.
</p>

	</span>

	
	

	
	
		
		<h1 id="CursorPositionEvent.String" class="hdr pkg hdr-method"><a href="#CursorPositionEvent.String" title="permalink">»</a>&nbsp;func (ev CursorPositionEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev CursorPositionEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="CursorPositionEvent.Time" class="hdr pkg hdr-method"><a href="#CursorPositionEvent.Time" title="permalink">»</a>&nbsp;func (ev CursorPositionEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev CursorPositionEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="CursorWithinEvent" class="hdr pkg hdr-type"><a href="#CursorWithinEvent" title="permalink">»</a>&nbsp;type CursorWithinEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CursorWithinEvent struct {
	// Weather the mouse cursor is within the window&#39;s client region or not.
	Within	bool

	T	time.Time
}</pre>
		<p>
CursorWithinEvent is an event where the user moved the mouse cursor inside
or outside the window&#39;s client region.
</p>

	</span>

	
	

	
	
		
		<h1 id="CursorWithinEvent.String" class="hdr pkg hdr-method"><a href="#CursorWithinEvent.String" title="permalink">»</a>&nbsp;func (ev CursorWithinEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev CursorWithinEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="CursorWithinEvent.Time" class="hdr pkg hdr-method"><a href="#CursorWithinEvent.Time" title="permalink">»</a>&nbsp;func (ev CursorWithinEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev CursorWithinEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="DestroyedEvent" class="hdr pkg hdr-type"><a href="#DestroyedEvent" title="permalink">»</a>&nbsp;type DestroyedEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type DestroyedEvent struct {
	T time.Time
}</pre>
		<p>
DestroyedEvent is an event where the window was destroyed.
</p>

	</span>

	
	

	
	
		
		<h1 id="DestroyedEvent.String" class="hdr pkg hdr-method"><a href="#DestroyedEvent.String" title="permalink">»</a>&nbsp;func (ev DestroyedEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev DestroyedEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="DestroyedEvent.Time" class="hdr pkg hdr-method"><a href="#DestroyedEvent.Time" title="permalink">»</a>&nbsp;func (ev DestroyedEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev DestroyedEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="Event" class="hdr pkg hdr-type"><a href="#Event" title="permalink">»</a>&nbsp;type Event <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Event interface {
	Time() time.Time
}</pre>
		<p>
Event represents an event of some sort. The only requirement is that the
event specify the point in time at which it happened.
</p>
<p>
Normally you will use an type assertion or type switch to retrieve more
useful information from the underlying type.
</p>

	</span>

	
	

	
	

	
	<h1 id="FocusedEvent" class="hdr pkg hdr-type"><a href="#FocusedEvent" title="permalink">»</a>&nbsp;type FocusedEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type FocusedEvent struct {
	// Weather the window has focus or not.
	Focused	bool

	T	time.Time
}</pre>
		<p>
FocusedEvent is an event where the user changed the focus of the window.
</p>

	</span>

	
	

	
	
		
		<h1 id="FocusedEvent.String" class="hdr pkg hdr-method"><a href="#FocusedEvent.String" title="permalink">»</a>&nbsp;func (ev FocusedEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev FocusedEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="FocusedEvent.Time" class="hdr pkg hdr-method"><a href="#FocusedEvent.Time" title="permalink">»</a>&nbsp;func (ev FocusedEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev FocusedEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="GLConfig" class="hdr pkg hdr-type"><a href="#GLConfig" title="permalink">»</a>&nbsp;type GLConfig <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type GLConfig struct {

	// Tells whether this configuration is hardware accelerated or uses some
	// software implementation version of OpenGL.
	//
	// Note: Most software implementations are very low OpenGL versions. (I.e.
	// GL 1.1)
	Accelerated	bool

	// Tells whether or not this config will support the window being
	// transparent while using OpenGL rendering
	Transparent	bool

	// The number of bits that represent an color per pixel in the frame buffer.
	RedBits, GreenBits, BlueBits, AlphaBits	uint8

	// The number of bits that represent an color per pixel in the accumulation
	// buffer.
	//
	// Note: GLSL shaders can perform an much better job of anything you would
	// be trying to do with the accumulation buffer.
	AccumRedBits, AccumGreenBits, AccumBlueBits, AccumAlphaBits	uint8

	// Number of Multi Sample Anti Aliasing samples this configuration supports
	// (e.g. 2 for 2x MSAA, 16 for 16x MSAA, etc)
	Samples	uint8

	// The number of auxiliary buffers available.
	//
	// Note: Auxiliary buffers are very rarely supported on most OpenGL
	// implementations (or choosing a configuration with them causes
	// non-accelerated rendering).
	//
	// For more information about this see the following forum URL:
	//     http://www.opengl.org/discussion_boards/showthread.php/171060-auxiliary-buffers
	AuxBuffers	uint8

	// The number of bits that represent an pixel in the depth buffer.
	DepthBits	uint8

	// The number of bits that represent an pixel in the stencil buffer.
	StencilBits	uint8

	// Weather this frame buffer configuration is double buffered.
	DoubleBuffered	bool

	// Weather this frame buffer configuration is stereoscopic capable.
	StereoScopic	bool
	// contains filtered or unexported fields
}</pre>
		<p>
GLConfig represents an single opengl (frame buffer / pixel) configuration.
</p>

	</span>

	
	
		<h1 id="GLChooseConfig" class="hdr pkg hdr-function"><a href="#GLChooseConfig" title="permalink">»</a>&nbsp;func GLChooseConfig(possible []*GLConfig, minConfig, maxConfig *GLConfig) *GLConfig <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func GLChooseConfig(possible []*GLConfig, minConfig, maxConfig *GLConfig) *GLConfig</pre>
			<p>
GLChooseConfig chooses an appropriate configuration from the slice of
possible configurations.
</p>
<p>
The returned configuration will have at least minConfig&#39;s attributes, or nil
will be returned if there is no configuration that has at least minConfig&#39;s
attributes.
</p>
<p>
The returned configuration will have no greater than maxConfig&#39;s attributes,
or nil will be returned if there is no configuration that is below
maxConfig&#39;s attributes.
</p>
<p>
After the selection process excludes configurations below minConfig and
above maxConfig, the compatible configurations not excluded are sorted in
order of closest-to maxConfig in the order of the following configuration
attributes:
</p>
<pre>Accelerated
RedBits, GreenBits, BlueBits, AlphaBits
DoubleBuffered
Samples
DepthBits
StencilBits
StereoScopic
Transparent
AccumRedBits, AccumGreenBits, AccumBlueBits, AccumAlphaBits
AuxBuffers
</pre>
<p>
And the first configuration in the sorted list is returned. (I.e. you are
most likely to recieve a Accelerated configuration, then one with high bytes
per pixel, then one who is DoubleBuffered, Transparent, and so forth).
</p>
<p>
You may use the predefined GLWorstConfig and GLBestConfig variables if they
suite your case.
</p>

		</span>
	

	
	
		
		<h1 id="GLConfig.Equals" class="hdr pkg hdr-method"><a href="#GLConfig.Equals" title="permalink">»</a>&nbsp;func (c *GLConfig) Equals(other *GLConfig) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *GLConfig) Equals(other *GLConfig) bool</pre>
			<p>
Equals tells whether this GLConfig equals the other GLFrameBufferConfig, by
comparing each attribute.
</p>

		</span>
	
		
		<h1 id="GLConfig.String" class="hdr pkg hdr-method"><a href="#GLConfig.String" title="permalink">»</a>&nbsp;func (c *GLConfig) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *GLConfig) String() string</pre>
			
		</span>
	

	
	<h1 id="GLContext" class="hdr pkg hdr-type"><a href="#GLContext" title="permalink">»</a>&nbsp;type GLContext <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type GLContext interface {
}</pre>
		<p>
GLContext represents an OpenGL contect; although it represents any value it
represents an important idea of what it&#39;s data actually is.
</p>

	</span>

	
	

	
	

	
	<h1 id="GLContextFlags" class="hdr pkg hdr-type"><a href="#GLContextFlags" title="permalink">»</a>&nbsp;type GLContextFlags <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type GLContextFlags uint8</pre>
		
	</span>

	
	

	
	

	
	<h1 id="GLRenderable" class="hdr pkg hdr-type"><a href="#GLRenderable" title="permalink">»</a>&nbsp;type GLRenderable <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type GLRenderable interface {
	// GLConfigs returns all possible OpenGL configurations, these are valid
	// configurations that may be used in an call to GLSetConfig.
	GLConfigs() []*GLConfig

	// GLSetConfig sets the OpenGL framebuffer configuration, unlike other
	// window management libraries, this action may be performed multiple
	// times.
	//
	// The config parameter must be an *GLConfig that originally came from the
	// GLConfigs() function mainly do to the fact that it must be initialized
	// internally.
	GLSetConfig(config *GLConfig)

	// GLConfig returns the currently in use *GLConfig or nil, as it was
	// previously set via an call to GLSetConfig()
	GLConfig() *GLConfig

	// GLCreateContext creates an OpenGL context for the specified OpenGL
	// version, or returns an error in the event that we cannot create an
	// context for that version.
	//
	// The flags parameter may be any combination of the predifined flags, as
	// follows:
	//
	// GLDebug, you will receive an OpenGL debug context. *
	//
	// GLForwardCompatible, you will receive an OpenGL forward compatible
	// context. *
	//
	// GLCoreProfile, you will receive an OpenGL core context.
	//
	// GLCompatibilityProfile, you will receive an OpenGL compatibility
	// context.
	//
	// Only one of GLCoreProfile or GLCompatibilityProfile should be present.
	//
	// GLCompatabilityProfile will be used if neither GLCoreProfile or
	// GLCompatibilityProfile are present, or if both are present.
	//
	// * = It is not advised to use this flag in production.
	//
	// You must call GLSetConfig() before calling this function.
	//
	// If the error returned is not nil, it will either be an undefined error
	// (which may indicate an error with the user&#39;s graphics card, or drivers),
	// or will be ErrGLVersionNotSupported, which indicates that the requested
	// OpenGL version is not available.
	GLCreateContext(major, minor uint, flags GLContextFlags, share GLContext) (GLContext, error)

	// GLDestroyContext destroys the specified OpenGL context.
	//
	// The context to destroy must not be active in any thread, period.
	GLDestroyContext(c GLContext)

	// GLMakeCurrent makes the specified context the current, active OpenGL
	// context in the current operating system thread.
	//
	// To make the OpenGL context inactive, you may call this function using
	// nil as the context, which will release the context.
	//
	// This function may be called from any thread, but an OpenGL context may
	// only be active inside one thread at an time.
	GLMakeCurrent(c GLContext)

	// GLSwapBuffers swaps the front and back buffers of this Renderable.
	//
	// This function may only be called in the presence of an active OpenGL
	// context.
	//
	// If the GLConfig set previously via GLSetConfig() is not DoubleBuffered,
	// then this function is no-op.
	GLSwapBuffers()

	// GLSetVerticalSync sets the vertical refresh rate sync mode (vsync).
	//
	// This function should only be called in the presence of an active OpenGL
	// context or else the call may fail due to drivers or platforms that
	// require an active context (e.g. Mesa).
	GLSetVerticalSync(mode VSyncMode)
}</pre>
		
	</span>

	
	

	
	

	
	<h1 id="MaximizedEvent" class="hdr pkg hdr-type"><a href="#MaximizedEvent" title="permalink">»</a>&nbsp;type MaximizedEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type MaximizedEvent struct {
	// Weather or not the window is currently maximized.
	Maximized	bool

	T	time.Time
}</pre>
		<p>
MaximizedEvent is an event where the user maximized (or un-maximized) the
window.
</p>

	</span>

	
	

	
	
		
		<h1 id="MaximizedEvent.String" class="hdr pkg hdr-method"><a href="#MaximizedEvent.String" title="permalink">»</a>&nbsp;func (ev MaximizedEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev MaximizedEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="MaximizedEvent.Time" class="hdr pkg hdr-method"><a href="#MaximizedEvent.Time" title="permalink">»</a>&nbsp;func (ev MaximizedEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev MaximizedEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="MinimizedEvent" class="hdr pkg hdr-type"><a href="#MinimizedEvent" title="permalink">»</a>&nbsp;type MinimizedEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type MinimizedEvent struct {
	// Weather or not the window is currently minimized.
	Minimized	bool

	T	time.Time
}</pre>
		<p>
MinimizedEvent is an event where the user minimized (or un-minimized) the
window.
</p>

	</span>

	
	

	
	
		
		<h1 id="MinimizedEvent.String" class="hdr pkg hdr-method"><a href="#MinimizedEvent.String" title="permalink">»</a>&nbsp;func (ev MinimizedEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev MinimizedEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="MinimizedEvent.Time" class="hdr pkg hdr-method"><a href="#MinimizedEvent.Time" title="permalink">»</a>&nbsp;func (ev MinimizedEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev MinimizedEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="NativeScreen" class="hdr pkg hdr-type"><a href="#NativeScreen" title="permalink">»</a>&nbsp;type NativeScreen <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type NativeScreen struct {
	// contains filtered or unexported fields
}</pre>
		
	</span>

	
	

	
	

	
	<h1 id="NativeScreenMode" class="hdr pkg hdr-type"><a href="#NativeScreenMode" title="permalink">»</a>&nbsp;type NativeScreenMode <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type NativeScreenMode struct {
	// contains filtered or unexported fields
}</pre>
		
	</span>

	
	

	
	

	
	<h1 id="NativeWindow" class="hdr pkg hdr-type"><a href="#NativeWindow" title="permalink">»</a>&nbsp;type NativeWindow <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type NativeWindow struct {
	// contains filtered or unexported fields
}</pre>
		
	</span>

	
	

	
	
		
		<h1 id="NativeWindow.Class" class="hdr pkg hdr-method"><a href="#NativeWindow.Class" title="permalink">»</a>&nbsp;func (w *NativeWindow) Class() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) Class() string</pre>
			<p>
Class returns the window class string of this Window (lpClassName), this is of course, Windows
specific, and is only useful doing an small, select amount of things.
</p>

		</span>
	
		
		<h1 id="NativeWindow.GLConfig" class="hdr pkg hdr-method"><a href="#NativeWindow.GLConfig" title="permalink">»</a>&nbsp;func (w *NativeWindow) GLConfig() *GLConfig <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) GLConfig() *GLConfig</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.GLConfigs" class="hdr pkg hdr-method"><a href="#NativeWindow.GLConfigs" title="permalink">»</a>&nbsp;func (w *NativeWindow) GLConfigs() (configs []*GLConfig) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) GLConfigs() (configs []*GLConfig)</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.GLCreateContext" class="hdr pkg hdr-method"><a href="#NativeWindow.GLCreateContext" title="permalink">»</a>&nbsp;func (w *NativeWindow) GLCreateContext(glVersionMajor, glVersionMinor uint, flags GLContextFlags, share GLContext) (GLContext, error) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) GLCreateContext(glVersionMajor, glVersionMinor uint, flags GLContextFlags, share GLContext) (GLContext, error)</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.GLDestroyContext" class="hdr pkg hdr-method"><a href="#NativeWindow.GLDestroyContext" title="permalink">»</a>&nbsp;func (w *NativeWindow) GLDestroyContext(c GLContext) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) GLDestroyContext(c GLContext)</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.GLMakeCurrent" class="hdr pkg hdr-method"><a href="#NativeWindow.GLMakeCurrent" title="permalink">»</a>&nbsp;func (w *NativeWindow) GLMakeCurrent(c GLContext) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) GLMakeCurrent(c GLContext)</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.GLSetConfig" class="hdr pkg hdr-method"><a href="#NativeWindow.GLSetConfig" title="permalink">»</a>&nbsp;func (w *NativeWindow) GLSetConfig(config *GLConfig) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) GLSetConfig(config *GLConfig)</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.GLSetVerticalSync" class="hdr pkg hdr-method"><a href="#NativeWindow.GLSetVerticalSync" title="permalink">»</a>&nbsp;func (w *NativeWindow) GLSetVerticalSync(mode VSyncMode) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) GLSetVerticalSync(mode VSyncMode)</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.GLSwapBuffers" class="hdr pkg hdr-method"><a href="#NativeWindow.GLSwapBuffers" title="permalink">»</a>&nbsp;func (w *NativeWindow) GLSwapBuffers() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) GLSwapBuffers()</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.GLVerticalSync" class="hdr pkg hdr-method"><a href="#NativeWindow.GLVerticalSync" title="permalink">»</a>&nbsp;func (w *NativeWindow) GLVerticalSync() VSyncMode <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) GLVerticalSync() VSyncMode</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.HWND" class="hdr pkg hdr-method"><a href="#NativeWindow.HWND" title="permalink">»</a>&nbsp;func (w *NativeWindow) HWND() win32.HWND <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) HWND() win32.HWND</pre>
			<p>
HWND returns the win32 handle to this Window, and it&#39;s child render window HWND.
</p>
<p>
This is only useful when doing an few very select hack-ish things.
</p>

		</span>
	
		
		<h1 id="NativeWindow.PixelBlit" class="hdr pkg hdr-method"><a href="#NativeWindow.PixelBlit" title="permalink">»</a>&nbsp;func (w *NativeWindow) PixelBlit(x, y uint, image *image.RGBA) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) PixelBlit(x, y uint, image *image.RGBA)</pre>
			
		</span>
	
		
		<h1 id="NativeWindow.PixelClear" class="hdr pkg hdr-method"><a href="#NativeWindow.PixelClear" title="permalink">»</a>&nbsp;func (w *NativeWindow) PixelClear(rect image.Rectangle) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *NativeWindow) PixelClear(rect image.Rectangle)</pre>
			
		</span>
	

	
	<h1 id="PaintEvent" class="hdr pkg hdr-type"><a href="#PaintEvent" title="permalink">»</a>&nbsp;type PaintEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PaintEvent struct {
	// Rectangle that needs to be redrawn / has been damaged.
	Rectangle	image.Rectangle

	T	time.Time
}</pre>
		<p>
PaintEvent is an event where the pixels inside the window&#39;s client region
where damaged and need to be redrawn.
</p>

	</span>

	
	

	
	
		
		<h1 id="PaintEvent.String" class="hdr pkg hdr-method"><a href="#PaintEvent.String" title="permalink">»</a>&nbsp;func (ev PaintEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev PaintEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="PaintEvent.Time" class="hdr pkg hdr-method"><a href="#PaintEvent.Time" title="permalink">»</a>&nbsp;func (ev PaintEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev PaintEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="PositionEvent" class="hdr pkg hdr-type"><a href="#PositionEvent" title="permalink">»</a>&nbsp;type PositionEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PositionEvent struct {
	// Position of the window&#39;s client region.
	X, Y	int

	T	time.Time
}</pre>
		<p>
PositionEvent is an event where the user changed the position of the window.
</p>

	</span>

	
	

	
	
		
		<h1 id="PositionEvent.String" class="hdr pkg hdr-method"><a href="#PositionEvent.String" title="permalink">»</a>&nbsp;func (ev PositionEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev PositionEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="PositionEvent.Time" class="hdr pkg hdr-method"><a href="#PositionEvent.Time" title="permalink">»</a>&nbsp;func (ev PositionEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev PositionEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="ResizedEvent" class="hdr pkg hdr-type"><a href="#ResizedEvent" title="permalink">»</a>&nbsp;type ResizedEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ResizedEvent struct {
	// Size of the window&#39;s client region.
	Width, Height	int

	T	time.Time
}</pre>
		<p>
ResizedEvent is an event where the user changed the size of the window&#39;s
client region.
</p>

	</span>

	
	

	
	
		
		<h1 id="ResizedEvent.String" class="hdr pkg hdr-method"><a href="#ResizedEvent.String" title="permalink">»</a>&nbsp;func (ev ResizedEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev ResizedEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="ResizedEvent.Time" class="hdr pkg hdr-method"><a href="#ResizedEvent.Time" title="permalink">»</a>&nbsp;func (ev ResizedEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev ResizedEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="Screen" class="hdr pkg hdr-type"><a href="#Screen" title="permalink">»</a>&nbsp;type Screen <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Screen struct {
	*NativeScreen
	// contains filtered or unexported fields
}</pre>
		<p>
Screen represents an single physical screen device. It is only possible to
get an screen from either the Screens or DefaultScreen functions.
</p>

	</span>

	
	
		<h1 id="DefaultScreen" class="hdr pkg hdr-function"><a href="#DefaultScreen" title="permalink">»</a>&nbsp;func DefaultScreen() *Screen <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func DefaultScreen() *Screen</pre>
			<p>
DefaultScreen returns the &#39;default&#39; screen, this is determined by either the
window manager itself (as per an user&#39;s personal setup and configuration) or
will be best-guessed by Chippy.
</p>
<p>
It is possible for this function to return nil, in the highly unlikely event
that Screens() returns no screens at all, due to an user having none plugged
in or activated.
</p>

		</span>
	

	
	
		
		<h1 id="Screen.Equals" class="hdr pkg hdr-method"><a href="#Screen.Equals" title="permalink">»</a>&nbsp;func (s *Screen) Equals(other *Screen) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Screen) Equals(other *Screen) bool</pre>
			<p>
Equals compares this screen with the other screen, determining whether or
not they are the same physical screen.
</p>

		</span>
	
		
		<h1 id="Screen.Mode" class="hdr pkg hdr-method"><a href="#Screen.Mode" title="permalink">»</a>&nbsp;func (s *Screen) Mode() *ScreenMode <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Screen) Mode() *ScreenMode</pre>
			<p>
Mode returns the current screen mode in use by this screen, this will be
either the last screen mode set via SetMode, or the original screen mode
from OriginalMode in the event that no screen mode was previously set on
this screen.
</p>

		</span>
	
		
		<h1 id="Screen.Modes" class="hdr pkg hdr-method"><a href="#Screen.Modes" title="permalink">»</a>&nbsp;func (s *Screen) Modes() []*ScreenMode <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Screen) Modes() []*ScreenMode</pre>
			<p>
Modes returns all available screen modes on this screen, sorted by highest
resolution, then highest bytes per pixel, then highest refresh rate.
</p>

		</span>
	
		
		<h1 id="Screen.Name" class="hdr pkg hdr-method"><a href="#Screen.Name" title="permalink">»</a>&nbsp;func (s *Screen) Name() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Screen) Name() string</pre>
			<p>
Name returns an formatted string of the screens name, this is something that
the user should be able to relate on their own to the actual physical screen
device, this typically includes device brand name or model etc..
</p>

		</span>
	
		
		<h1 id="Screen.OriginalMode" class="hdr pkg hdr-method"><a href="#Screen.OriginalMode" title="permalink">»</a>&nbsp;func (s *Screen) OriginalMode() *ScreenMode <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Screen) OriginalMode() *ScreenMode</pre>
			<p>
OriginalMode returns the original screen mode of this screen, as it was when
this screen was created.
</p>

		</span>
	
		
		<h1 id="Screen.PhysicalSize" class="hdr pkg hdr-method"><a href="#Screen.PhysicalSize" title="permalink">»</a>&nbsp;func (s *Screen) PhysicalSize() (width float32, height float32) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Screen) PhysicalSize() (width float32, height float32)</pre>
			<p>
PhysicalSize returns the physical width and height of this screen, in
millimeters, or zero as both width and height in the event there is no way
to determine the physical size of this screen.
</p>

		</span>
	
		
		<h1 id="Screen.Restore" class="hdr pkg hdr-method"><a href="#Screen.Restore" title="permalink">»</a>&nbsp;func (s *Screen) Restore() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Screen) Restore()</pre>
			<p>
Restore is short-hand for:
</p>
<pre>s.SetMode(s.OriginalMode())
</pre>

		</span>
	
		
		<h1 id="Screen.SetMode" class="hdr pkg hdr-method"><a href="#Screen.SetMode" title="permalink">»</a>&nbsp;func (s *Screen) SetMode(newMode *ScreenMode) error <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Screen) SetMode(newMode *ScreenMode) error</pre>
			<p>
SetMode switches this screen to the specified screen mode, or returns an
error in the event that we where unable to switch the screen to the specified
screen mode.
</p>
<p>
The newMode parameter must be an screen mode that originally came from one
of the methods Modes(), Mode(), or OriginalMode(), or else this function
will panic.
</p>
<p>
If an error is returned, it will be either ErrBadScreenMode, or
ErrDualViewCapable.
</p>

		</span>
	
		
		<h1 id="Screen.String" class="hdr pkg hdr-method"><a href="#Screen.String" title="permalink">»</a>&nbsp;func (s *Screen) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Screen) String() string</pre>
			<p>
String returns an nice string representation of this Screen
</p>

		</span>
	

	
	<h1 id="ScreenChangedEvent" class="hdr pkg hdr-type"><a href="#ScreenChangedEvent" title="permalink">»</a>&nbsp;type ScreenChangedEvent <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ScreenChangedEvent struct {
	// Screen that the window is located on.
	Screen	*Screen

	T	time.Time
}</pre>
		<p>
ScreenChangedEvent is an event where the user moved the window onto an
different screen.
</p>

	</span>

	
	

	
	
		
		<h1 id="ScreenChangedEvent.String" class="hdr pkg hdr-method"><a href="#ScreenChangedEvent.String" title="permalink">»</a>&nbsp;func (ev ScreenChangedEvent) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev ScreenChangedEvent) String() string</pre>
			<p>
String returns an string representation of this event.
</p>

		</span>
	
		
		<h1 id="ScreenChangedEvent.Time" class="hdr pkg hdr-method"><a href="#ScreenChangedEvent.Time" title="permalink">»</a>&nbsp;func (ev ScreenChangedEvent) Time() time.Time <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (ev ScreenChangedEvent) Time() time.Time</pre>
			<p>
Time implements the generic event interface.
</p>

		</span>
	

	
	<h1 id="ScreenMode" class="hdr pkg hdr-type"><a href="#ScreenMode" title="permalink">»</a>&nbsp;type ScreenMode <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ScreenMode struct {
	*NativeScreenMode
	// contains filtered or unexported fields
}</pre>
		<p>
ScreenMode represents an single, unique, screen mode, with an resolution,
refresh rate, and bpp.
</p>
<p>
It is possible for multiple different ScreenMode&#39;s to exist with the same
resolution, each with different refresh rates or bytes per pixel,
respectively.
</p>

	</span>

	
	

	
	
		
		<h1 id="ScreenMode.BytesPerPixel" class="hdr pkg hdr-method"><a href="#ScreenMode.BytesPerPixel" title="permalink">»</a>&nbsp;func (m *ScreenMode) BytesPerPixel() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *ScreenMode) BytesPerPixel() int</pre>
			<p>
BytesPerPixel returns the number of bytes that represent an single pixel of this ScreenMode,
or 0 if the bytes per pixel is unable to be determined.
</p>

		</span>
	
		
		<h1 id="ScreenMode.Equals" class="hdr pkg hdr-method"><a href="#ScreenMode.Equals" title="permalink">»</a>&nbsp;func (m *ScreenMode) Equals(other *ScreenMode) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *ScreenMode) Equals(other *ScreenMode) bool</pre>
			<p>
Equals compares two ScreenMode(s) for equality. It does this by comparing resolutions,
refresh rates, and bytes per pixels.
</p>

		</span>
	
		
		<h1 id="ScreenMode.RefreshRate" class="hdr pkg hdr-method"><a href="#ScreenMode.RefreshRate" title="permalink">»</a>&nbsp;func (m *ScreenMode) RefreshRate() float32 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *ScreenMode) RefreshRate() float32</pre>
			<p>
RefreshRate returns the refresh rate of this ScreenMode, in hertz, or 0 if the refresh rate
is unable to be determined.
</p>

		</span>
	
		
		<h1 id="ScreenMode.Resolution" class="hdr pkg hdr-method"><a href="#ScreenMode.Resolution" title="permalink">»</a>&nbsp;func (m *ScreenMode) Resolution() (width, height int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *ScreenMode) Resolution() (width, height int)</pre>
			<p>
Resolution returns the width and height of this ScreenMode, in pixels.
</p>

		</span>
	
		
		<h1 id="ScreenMode.String" class="hdr pkg hdr-method"><a href="#ScreenMode.String" title="permalink">»</a>&nbsp;func (m *ScreenMode) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m *ScreenMode) String() string</pre>
			<p>
String returns an nice string representing this ScreenMode
</p>

		</span>
	

	
	<h1 id="VSyncMode" class="hdr pkg hdr-type"><a href="#VSyncMode" title="permalink">»</a>&nbsp;type VSyncMode <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type VSyncMode uint8</pre>
		<p>
VSyncMode represents an single vertical reresh rate sync mode.
</p>

	</span>

	
	

	
	
		
		<h1 id="VSyncMode.String" class="hdr pkg hdr-method"><a href="#VSyncMode.String" title="permalink">»</a>&nbsp;func (mode VSyncMode) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (mode VSyncMode) String() string</pre>
			<p>
String returns a string representation of this vertical sync mode.
</p>

		</span>
	
		
		<h1 id="VSyncMode.Valid" class="hdr pkg hdr-method"><a href="#VSyncMode.Valid" title="permalink">»</a>&nbsp;func (mode VSyncMode) Valid() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (mode VSyncMode) Valid() bool</pre>
			<p>
Valid tells if the vertical sync mode is one of the predefined constants
defined in this package or not.
</p>

		</span>
	

	
	<h1 id="W32GLContext" class="hdr pkg hdr-type"><a href="#W32GLContext" title="permalink">»</a>&nbsp;type W32GLContext <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type W32GLContext struct {
	// contains filtered or unexported fields
}</pre>
		
	</span>

	
	

	
	

	
	<h1 id="Window" class="hdr pkg hdr-type"><a href="#Window" title="permalink">»</a>&nbsp;type Window <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Window struct {
	*NativeWindow

	Keyboard	*keyboard.Watcher
	Mouse		*mouse.Watcher
	// contains filtered or unexported fields
}</pre>
		<p>
Window represents an single window, it will be non-visible untill the Open
function is called.
</p>

	</span>

	
	
		<h1 id="NewWindow" class="hdr pkg hdr-function"><a href="#NewWindow" title="permalink">»</a>&nbsp;func NewWindow() *Window <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func NewWindow() *Window</pre>
			
		</span>
	

	
	
		
		<h1 id="Window.AlwaysOnTop" class="hdr pkg hdr-method"><a href="#Window.AlwaysOnTop" title="permalink">»</a>&nbsp;func (w *Window) AlwaysOnTop() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) AlwaysOnTop() bool</pre>
			<p>
AlwaysOnTop tells whether the window is currently always on top of other
windows, due to an previous call to the SetAlwaysOnTop function, or due
to the user changing the always on top state directly through the window
manager itself.
</p>

		</span>
	
		
		<h1 id="Window.AspectRatio" class="hdr pkg hdr-method"><a href="#Window.AspectRatio" title="permalink">»</a>&nbsp;func (w *Window) AspectRatio() float32 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) AspectRatio() float32</pre>
			<p>
AspectRatio tells the aspect ratio that the window should try and keep
when the user resizes the window, as previously set via SetAspectRatio,
or the default of 0.
</p>
<p>
Note: If you want to determine the aspect ratio of the window, you
should instead calculate it from the Size() function, by dividing width
by height.
</p>
<p>
(Because if there was no previous call to SetAspectRatio, this function
will return 0, which is not the actual window aspect ratio.)
</p>

		</span>
	
		
		<h1 id="Window.CloseEvents" class="hdr pkg hdr-method"><a href="#Window.CloseEvents" title="permalink">»</a>&nbsp;func (w *Window) CloseEvents(ch chan Event) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) CloseEvents(ch chan Event)</pre>
			<p>
CloseEvents stops the specified channel from receiving any more window
events.
</p>
<p>
Call this function whenever you are done receiving window events from
the given channel.
</p>
<p>
This is important for channels which have an very large buffer size to
reduce memory consumption.
</p>

		</span>
	
		
		<h1 id="Window.Cursor" class="hdr pkg hdr-method"><a href="#Window.Cursor" title="permalink">»</a>&nbsp;func (w *Window) Cursor() *Cursor <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Cursor() *Cursor</pre>
			<p>
Cursor returns the currently in use cursor image, as previously set via
an call to SetCursor.
</p>
<p>
Changes made to this Image *after* an initial call to SetCursor will not
be reflected by the window unless you call SetCursor again.
</p>

		</span>
	
		
		<h1 id="Window.CursorGrabbed" class="hdr pkg hdr-method"><a href="#Window.CursorGrabbed" title="permalink">»</a>&nbsp;func (w *Window) CursorGrabbed() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) CursorGrabbed() bool</pre>
			<p>
CursorGrabbed tells whether the mouse cursor is currently grabbed, as
previously set via an call to the SetCursorGrabbed function.
</p>

		</span>
	
		
		<h1 id="Window.CursorPosition" class="hdr pkg hdr-method"><a href="#Window.CursorPosition" title="permalink">»</a>&nbsp;func (w *Window) CursorPosition() (x, y int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) CursorPosition() (x, y int)</pre>
			<p>
CursorPosition tells the current mouse cursor position, both x and y,
relative to the client region of this window (specified in pixels)
</p>

		</span>
	
		
		<h1 id="Window.CursorWithin" class="hdr pkg hdr-method"><a href="#Window.CursorWithin" title="permalink">»</a>&nbsp;func (w *Window) CursorWithin() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) CursorWithin() bool</pre>
			<p>
CursorWithin tells whether the mouse cursor is inside the window&#39;s
client region or not.
</p>

		</span>
	
		
		<h1 id="Window.Decorated" class="hdr pkg hdr-method"><a href="#Window.Decorated" title="permalink">»</a>&nbsp;func (w *Window) Decorated() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Decorated() bool</pre>
			<p>
Decorations tells whether this window has window decorations on, as
previously set by the SetDecorations function, or the default value of
true (on).
</p>

		</span>
	
		
		<h1 id="Window.Destroy" class="hdr pkg hdr-method"><a href="#Window.Destroy" title="permalink">»</a>&nbsp;func (w *Window) Destroy() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Destroy()</pre>
			<p>
Destroy destroys the window. It is closed, and is then considered to be in
an destroyed state.
</p>
<p>
After calling this function, the window is considered destroyed.
</p>
<p>
If the window is not currently open or is already destroyed then this
function is no-op.
</p>

		</span>
	
		
		<h1 id="Window.Destroyed" class="hdr pkg hdr-method"><a href="#Window.Destroyed" title="permalink">»</a>&nbsp;func (w *Window) Destroyed() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Destroyed() bool</pre>
			<p>
Destroyed tells whether there was an previous call to the Destroy function.
</p>

		</span>
	
		
		<h1 id="Window.Events" class="hdr pkg hdr-method"><a href="#Window.Events" title="permalink">»</a>&nbsp;func (w *Window) Events() chan Event <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Events() chan Event</pre>
			<p>
Events is short-hand for:
</p>
<pre>w.EventsBuffer(64)
</pre>

		</span>
	
		
		<h1 id="Window.EventsBuffer" class="hdr pkg hdr-method"><a href="#Window.EventsBuffer" title="permalink">»</a>&nbsp;func (w *Window) EventsBuffer(bufferSize int) chan Event <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) EventsBuffer(bufferSize int) chan Event</pre>
			<p>
EventsBuffer returns an new read-only channel over which window events will
be sent.
</p>
<p>
Events are sent in an non-blocking fashion. As such once the amount of
buffered items in the channel reaches the maximum, then events will stop
being sent.
</p>
<p>
You should ensure that the buffer size is large enough for you to read the
events in an short amount of time.
</p>

		</span>
	
		
		<h1 id="Window.Extents" class="hdr pkg hdr-method"><a href="#Window.Extents" title="permalink">»</a>&nbsp;func (w *Window) Extents() (left, right, bottom, top int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Extents() (left, right, bottom, top int)</pre>
			<p>
Extents returns how far the window region extends outward from the client
region of this window, in pixels.
</p>
<p>
If the window&#39;s extents are unknown, [0, 0, 0, 0] is returned.
</p>
<p>
If the window is not open yet, [0, 0, 0, 0] is returned.
</p>
<p>
If the window is destroyed, [0, 0, 0, 0] is returned.
</p>
<p>
None of the extents will ever be less than zero.
</p>

		</span>
	
		
		<h1 id="Window.Focused" class="hdr pkg hdr-method"><a href="#Window.Focused" title="permalink">»</a>&nbsp;func (w *Window) Focused() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Focused() bool</pre>
			<p>
Focused tells whether this window currently has focus, and is therefor
the current window that is being interacted with by the user.
</p>

		</span>
	
		
		<h1 id="Window.FreeCursor" class="hdr pkg hdr-method"><a href="#Window.FreeCursor" title="permalink">»</a>&nbsp;func (w *Window) FreeCursor(cursor *Cursor) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) FreeCursor(cursor *Cursor)</pre>
			<p>
FreeCursor removes the specified cursor from the internal cache. Cursors
are cached because it allows for SetCursor() operations to perform more
quickly without performing multiple copy operations underneath.
</p>
<p>
This allows you to simply use SetCursor() as often as you wish, for
instance creating cursor animations and such.
</p>
<p>
If the specified cursor is nil; an panic will occur.
</p>
<p>
If the specified cursor is the active cursor (previously set via
the SetCursor function); then the default cursor (nil) will be set and then
the specified cursor free&#39;d.
</p>

		</span>
	
		
		<h1 id="Window.Fullscreen" class="hdr pkg hdr-method"><a href="#Window.Fullscreen" title="permalink">»</a>&nbsp;func (w *Window) Fullscreen() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Fullscreen() bool</pre>
			<p>
Fullscreen tells whether the window is currently full screen, as
previously set by an call to the SetFullscreen function.
</p>

		</span>
	
		
		<h1 id="Window.Icon" class="hdr pkg hdr-method"><a href="#Window.Icon" title="permalink">»</a>&nbsp;func (w *Window) Icon() image.Image <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Icon() image.Image</pre>
			<p>
Icon returns the currently in use icon image, as previously set via an
call to SetIcon.
</p>
<p>
Changes made to this Image *after* an initial call to SetIcon will not
be reflected by the window unless you call SetIcon again.
</p>

		</span>
	
		
		<h1 id="Window.Maximized" class="hdr pkg hdr-method"><a href="#Window.Maximized" title="permalink">»</a>&nbsp;func (w *Window) Maximized() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Maximized() bool</pre>
			<p>
Maximized tells whether the window is currently maximized, as previously
set via an call to the SetMaximized function, or due to the user
changing the maximized status of the window directly through the window
manager, or the default value of false.
</p>

		</span>
	
		
		<h1 id="Window.MaximumSize" class="hdr pkg hdr-method"><a href="#Window.MaximumSize" title="permalink">»</a>&nbsp;func (w *Window) MaximumSize() (width, height int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) MaximumSize() (width, height int)</pre>
			<p>
MaximumSize tells the current maximum width and height of this windows
client region, as set previously via the SetMaximumSize function, or the
default values of width=0, height=0
</p>
<p>
Both width and height will be at least 1.
</p>

		</span>
	
		
		<h1 id="Window.Minimized" class="hdr pkg hdr-method"><a href="#Window.Minimized" title="permalink">»</a>&nbsp;func (w *Window) Minimized() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Minimized() bool</pre>
			<p>
Minimized tells whether the window is currently minimized, as previously
set via an call to the SetMinimized function, or due to the user
changing the minimized status of the window directly through the window
manager, or the default value of false.
</p>

		</span>
	
		
		<h1 id="Window.MinimumSize" class="hdr pkg hdr-method"><a href="#Window.MinimumSize" title="permalink">»</a>&nbsp;func (w *Window) MinimumSize() (width, height int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) MinimumSize() (width, height int)</pre>
			<p>
MinimumSize tells the current minimum width and height of this windows
client region, as set previously via the SetMinimumSize function, or the
default values of width=150, height=150.
</p>
<p>
Both width and height will be at least 1.
</p>

		</span>
	
		
		<h1 id="Window.Notify" class="hdr pkg hdr-method"><a href="#Window.Notify" title="permalink">»</a>&nbsp;func (w *Window) Notify() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Notify()</pre>
			<p>
Notify causes the window to notify the user that an event has happened
with the application, and they should look at the application.
</p>
<p>
Typically this is an small flashing animation, etc.
</p>

		</span>
	
		
		<h1 id="Window.Open" class="hdr pkg hdr-method"><a href="#Window.Open" title="permalink">»</a>&nbsp;func (w *Window) Open(screen *Screen) error <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Open(screen *Screen) error</pre>
			<p>
Open opens the window using the current settings, on the specified
screen, or returns an error in the event that we are unable to open the
window for some reason (the error will be descriptive).
</p>
<p>
If the window is already open this function is no-op.
</p>
<p>
If the window is destroyed, it&#39;s NativeWindow struct will be replaced with a
new one and the window will become valid again.
</p>

		</span>
	
		
		<h1 id="Window.Opened" class="hdr pkg hdr-method"><a href="#Window.Opened" title="permalink">»</a>&nbsp;func (w *Window) Opened() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Opened() bool</pre>
			<p>
Opened tells whether the window is currently open.
</p>
<p>
If the window is destroyed, the returned value will be false.
</p>

		</span>
	
		
		<h1 id="Window.OriginalScreen" class="hdr pkg hdr-method"><a href="#Window.OriginalScreen" title="permalink">»</a>&nbsp;func (w *Window) OriginalScreen() *Screen <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) OriginalScreen() *Screen</pre>
			<p>
OriginalScreen returns the screen that this window was created on at the
time Open() was called.
</p>

		</span>
	
		
		<h1 id="Window.Position" class="hdr pkg hdr-method"><a href="#Window.Position" title="permalink">»</a>&nbsp;func (w *Window) Position() (x, y int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Position() (x, y int)</pre>
			<p>
Position tells what the current x and y position of this window&#39;s client
region.
</p>

		</span>
	
		
		<h1 id="Window.PrepareCursor" class="hdr pkg hdr-method"><a href="#Window.PrepareCursor" title="permalink">»</a>&nbsp;func (w *Window) PrepareCursor(cursor *Cursor) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) PrepareCursor(cursor *Cursor)</pre>
			<p>
PrepareCursor prepares the specified cursor to be displayed, but does
not display it. This is useful when you wish to load each frame for an
cursor animation, but not cause the cursor to flicker while loading them
into the internal cache.
</p>
<p>
If the specified cursor is nil; an panic will occur.
</p>
<p>
If the window is not open or is destroyed; the cursor cannot be prepared and
this function is no-op.
</p>

		</span>
	
		
		<h1 id="Window.Screen" class="hdr pkg hdr-method"><a href="#Window.Screen" title="permalink">»</a>&nbsp;func (w *Window) Screen() *Screen <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Screen() *Screen</pre>
			<p>
Screen returns the current screen that this window is currently residing on.
</p>
<p>
This function will return the original screen the window was created on in
the event that we are unable to determine the current screen.
</p>

		</span>
	
		
		<h1 id="Window.SetAlwaysOnTop" class="hdr pkg hdr-method"><a href="#Window.SetAlwaysOnTop" title="permalink">»</a>&nbsp;func (w *Window) SetAlwaysOnTop(alwaysOnTop bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetAlwaysOnTop(alwaysOnTop bool)</pre>
			<p>
SetAlwaysOnTop specifies whether the window should be always on top of
other windows.
</p>
<p>
If the window is destroyed, this function will panic.
</p>

		</span>
	
		
		<h1 id="Window.SetAspectRatio" class="hdr pkg hdr-method"><a href="#Window.SetAspectRatio" title="permalink">»</a>&nbsp;func (w *Window) SetAspectRatio(ratio float32) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetAspectRatio(ratio float32)</pre>
			<p>
SetAspectRatio specifies the aspect ratio that the window should try to
keep when the user resizes the window.
</p>
<p>
If the ratio is zero, then the window will be allowed to resize freely,
without being restricted to an aspect ratio.
</p>

		</span>
	
		
		<h1 id="Window.SetCursor" class="hdr pkg hdr-method"><a href="#Window.SetCursor" title="permalink">»</a>&nbsp;func (w *Window) SetCursor(cursor *Cursor) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetCursor(cursor *Cursor)</pre>
			<p>
SetCursor specifies the cursor to become the default cursor while the
mouse is inside this window&#39;s client region.
</p>
<p>
If the cursor does not exist within the internal cache already -- it
will be cached using PrepareCursor() automatically. Once you are done
using the cursor, you should use the FreeCursor() function to remove the
cursor from the internal cache (the cursor can still be displayed again
after using FreeCursor(), it just will have to be loaded into the cache
again).
</p>

		</span>
	
		
		<h1 id="Window.SetCursorGrabbed" class="hdr pkg hdr-method"><a href="#Window.SetCursorGrabbed" title="permalink">»</a>&nbsp;func (w *Window) SetCursorGrabbed(grabbed bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetCursorGrabbed(grabbed bool)</pre>
			<p>
SetCursorGrabbed specifies whether the mouse cursor should be grabbed,
this means the cursor will be invisible, and will be forced to stay
within the client region of the window. This behavior is the same as you
would typically see in first person shooter games.
</p>
<p>
If the cursor is being released (false), then the original cursor
position will be restored to where it was originally at the time of the
last call to SetCursorGrabbed(true).
</p>

		</span>
	
		
		<h1 id="Window.SetCursorPosition" class="hdr pkg hdr-method"><a href="#Window.SetCursorPosition" title="permalink">»</a>&nbsp;func (w *Window) SetCursorPosition(x, y int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetCursorPosition(x, y int)</pre>
			<p>
SetCursorPosition sets the mouse cursor to the new position x and y,
specified in pixels relative to the client region of this window.
</p>
<p>
It is possible to move the cursor outside both the client region and
window region, either by specifying an negative number, or an positive
number larger than the window region.
</p>

		</span>
	
		
		<h1 id="Window.SetDecorated" class="hdr pkg hdr-method"><a href="#Window.SetDecorated" title="permalink">»</a>&nbsp;func (w *Window) SetDecorated(decorated bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetDecorated(decorated bool)</pre>
			<p>
SetDecorated specifies whether this window should have window
decorations, this includes the title bar, exit buttons, borders, system
menu buttons, icons, etc.
</p>
<p>
If the window is destroyed, this function will panic.
</p>

		</span>
	
		
		<h1 id="Window.SetFullscreen" class="hdr pkg hdr-method"><a href="#Window.SetFullscreen" title="permalink">»</a>&nbsp;func (w *Window) SetFullscreen(fullscreen bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetFullscreen(fullscreen bool)</pre>
			<p>
SetFullscreen specifies whether the window should be full screen,
consuming the entire screen&#39;s size, and being the only thing displayed
on the screen.
</p>
<p>
If the window is destroyed, this function will panic.
</p>

		</span>
	
		
		<h1 id="Window.SetIcon" class="hdr pkg hdr-method"><a href="#Window.SetIcon" title="permalink">»</a>&nbsp;func (w *Window) SetIcon(icon image.Image) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetIcon(icon image.Image)</pre>
			<p>
SetIcon specifies the window icon which should be displayed anywhere
that an window icon is needed, this typically includes in the title bar
decoration, or in the icon tray.
</p>
<p>
If the icon is nil; the default &#39;chippy&#39; icon is restored.
</p>

		</span>
	
		
		<h1 id="Window.SetMaximized" class="hdr pkg hdr-method"><a href="#Window.SetMaximized" title="permalink">»</a>&nbsp;func (w *Window) SetMaximized(maximized bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetMaximized(maximized bool)</pre>
			<p>
SetMaximized specifies whether the window should currently be maximized.
</p>

		</span>
	
		
		<h1 id="Window.SetMaximumSize" class="hdr pkg hdr-method"><a href="#Window.SetMaximumSize" title="permalink">»</a>&nbsp;func (w *Window) SetMaximumSize(width, height int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetMaximumSize(width, height int)</pre>
			<p>
SetMaximumSize specifies the maximum width and height that this windows
client region is allowed to have, the user will be disallowed to resize
the window any larger than this specified size.
</p>
<p>
If the size passed into both SetMaximumSize and SetMinimumSize are the
same, then the window will be non-resizable.
</p>
<p>
If either width or height are zero, then there will be no maximum size
restriction placed.
</p>
<p>
If the window is destroyed, this function will panic.
</p>

		</span>
	
		
		<h1 id="Window.SetMinimized" class="hdr pkg hdr-method"><a href="#Window.SetMinimized" title="permalink">»</a>&nbsp;func (w *Window) SetMinimized(minimized bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetMinimized(minimized bool)</pre>
			<p>
SetMinimized specifies whether the window should currently be minimized.
</p>

		</span>
	
		
		<h1 id="Window.SetMinimumSize" class="hdr pkg hdr-method"><a href="#Window.SetMinimumSize" title="permalink">»</a>&nbsp;func (w *Window) SetMinimumSize(width, height int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetMinimumSize(width, height int)</pre>
			<p>
SetMinimumSize specifies the minimum width and height that this windows
client region is allowed to have, the user will be disallowed to resize
the window any smaller than this specified size.
</p>
<p>
If either width or height are zero, then there will be no maximum size
restriction placed.
</p>
<p>
If the size passed into both SetMinimumSize and SetMaximumSize are the
same, then the window will be non-resizable.
</p>

		</span>
	
		
		<h1 id="Window.SetPosition" class="hdr pkg hdr-method"><a href="#Window.SetPosition" title="permalink">»</a>&nbsp;func (w *Window) SetPosition(x, y int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetPosition(x, y int)</pre>
			<p>
SetPosition specifies the new x and y position of this window&#39;s client
region, relative to the top-left corner of the screen, in pixels.
</p>
<p>
If the window is destroyed, this function will panic.
</p>

		</span>
	
		
		<h1 id="Window.SetPositionCenter" class="hdr pkg hdr-method"><a href="#Window.SetPositionCenter" title="permalink">»</a>&nbsp;func (w *Window) SetPositionCenter(screen *Screen) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetPositionCenter(screen *Screen)</pre>
			<p>
SetPositionCenter sets the window position such that it is perfectly in
the center of the specified screen.
</p>

		</span>
	
		
		<h1 id="Window.SetSize" class="hdr pkg hdr-method"><a href="#Window.SetSize" title="permalink">»</a>&nbsp;func (w *Window) SetSize(width, height int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetSize(width, height int)</pre>
			<p>
SetSize specifies the new width and height of this window&#39;s client
region, in pixels.
</p>
<p>
The window&#39;s size will be clamped such that it is always 1px wide/tall; and
never exceeds the bounds of the minimum or maximum size of the window if one
is specified.
</p>
<p>
If w.Size() is later called, it will return the identical (non-clamped)
values you provide here.
</p>

		</span>
	
		
		<h1 id="Window.SetTitle" class="hdr pkg hdr-method"><a href="#Window.SetTitle" title="permalink">»</a>&nbsp;func (w *Window) SetTitle(title string) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetTitle(title string)</pre>
			<p>
SetTitle sets the title of the window, this is shown anywhere where
there needs to be an string representation, typical places include the
window&#39;s Title Bar decoration, and in the icon tray (which displays
minimized windows, etc).
</p>
<p>
If the window is destroyed, this function will panic.
</p>

		</span>
	
		
		<h1 id="Window.SetTransparent" class="hdr pkg hdr-method"><a href="#Window.SetTransparent" title="permalink">»</a>&nbsp;func (w *Window) SetTransparent(transparent bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetTransparent(transparent bool)</pre>
			<p>
SetTransparent specifies whether this window should be transparent, used
in things like splash screens, etc.
</p>
<p>
Default: false
</p>

		</span>
	
		
		<h1 id="Window.SetVisible" class="hdr pkg hdr-method"><a href="#Window.SetVisible" title="permalink">»</a>&nbsp;func (w *Window) SetVisible(visible bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) SetVisible(visible bool)</pre>
			<p>
SetVisible specifies whether this window should be visibly seen by the
user, if false the window will appear simply gone (even though it
actually exists, and you may render to it, and at an later time show the
window again).
</p>
<p>
If the window is destroyed, this function will panic.
</p>

		</span>
	
		
		<h1 id="Window.Size" class="hdr pkg hdr-method"><a href="#Window.Size" title="permalink">»</a>&nbsp;func (w *Window) Size() (width, height int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Size() (width, height int)</pre>
			<p>
Size tells the current width and height of this window, as set
previously by an call to the SetSize function, or due to the user
resizing the window through the window manager itself.
</p>
<p>
Both width and height will be at least 1.
</p>

		</span>
	
		
		<h1 id="Window.String" class="hdr pkg hdr-method"><a href="#Window.String" title="permalink">»</a>&nbsp;func (w *Window) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) String() string</pre>
			<p>
String returns an string representation of this window.
</p>

		</span>
	
		
		<h1 id="Window.Title" class="hdr pkg hdr-method"><a href="#Window.Title" title="permalink">»</a>&nbsp;func (w *Window) Title() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Title() string</pre>
			<p>
Title returns the title of the window, as it was set by SetTitle, or the
default title: &#34;Chippy Window&#34;.
</p>

		</span>
	
		
		<h1 id="Window.Transparent" class="hdr pkg hdr-method"><a href="#Window.Transparent" title="permalink">»</a>&nbsp;func (w *Window) Transparent() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Transparent() bool</pre>
			<p>
Transparent tells whether this window is transparent, via an previous
call to SetTransparent()
</p>

		</span>
	
		
		<h1 id="Window.Visible" class="hdr pkg hdr-method"><a href="#Window.Visible" title="permalink">»</a>&nbsp;func (w *Window) Visible() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (w *Window) Visible() bool</pre>
			<p>
Visible tells whether this window is currently visible to the user, as
previously set by the SetVisible function, or the default value of true
(visible).
</p>

		</span>
	

	
	<h1 id="X11GLContext" class="hdr pkg hdr-type"><a href="#X11GLContext" title="permalink">»</a>&nbsp;type X11GLContext <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type X11GLContext struct {
	// contains filtered or unexported fields
}</pre>
		
	</span>

	
	

	
	



<h1 id="package-files" class="hdr pkg hdr-files"><a href="#package-files" title="permalink">»</a>&nbsp;Package Files <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg files">
	<p>
	<a href="https:/github.com/azul3d/chippy/blob/v0/blit.go" title="view source">blit.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/chippy.go" title="view source">chippy.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/defaultIcon.bin.go" title="view source">defaultIcon.bin.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/defaultIcon.init.go" title="view source">defaultIcon.init.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/doc.go" title="view source">doc.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/errors.go" title="view source">errors.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/glconfig.go" title="view source">glconfig.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/opengl.go" title="view source">opengl.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/screen.go" title="view source">screen.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/screenmode.go" title="view source">screenmode.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/types.go" title="view source">types.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/window.go" title="view source">window.go</a>
	
	<a href="https:/github.com/azul3d/chippy/blob/v0/windowevents.go" title="view source">windowevents.go</a>
	</p>

	<h2><span class="linkarea">(<a href="#" id="tagged-files-toggle">show tagged files</a>)</span></h2>
	<span id="tagged-files">
		<h2>Linux Files</h2>
		<p>
		<a href="https:/github.com/azul3d/chippy/blob/v0/chippy_linux.go" title="view source">chippy_linux.go</a>
		
		<a href="https:/github.com/azul3d/chippy/blob/v0/opengl_linux.go" title="view source">opengl_linux.go</a>
		
		<a href="https:/github.com/azul3d/chippy/blob/v0/screen_linux.go" title="view source">screen_linux.go</a>
		
		<a href="https:/github.com/azul3d/chippy/blob/v0/window_linux.go" title="view source">window_linux.go</a>
		</p>
	
		<h2>Windows Files</h2>
		<p>
		<a href="https:/github.com/azul3d/chippy/blob/v0/chippy_windows.go" title="view source">chippy_windows.go</a>
		
		<a href="https:/github.com/azul3d/chippy/blob/v0/opengl_windows.go" title="view source">opengl_windows.go</a>
		
		<a href="https:/github.com/azul3d/chippy/blob/v0/screen_windows.go" title="view source">screen_windows.go</a>
		
		<a href="https:/github.com/azul3d/chippy/blob/v0/window_windows.go" title="view source">window_windows.go</a>
		</p>
	</span>
</span>


<script>
$(function() {
	$("#tagged-files").slideUp();
	var toggle = true;
	$("#tagged-files-toggle").click(function(event) {
		event.preventDefault();
		toggle = !toggle;
		if(toggle) {
			$("#tagged-files").slideUp();
			$("#tagged-files-toggle").html("show tagged files");
		} else {
			$("#tagged-files").slideDown();
			$("#tagged-files-toggle").html("hide tagged files");
		}
	});
});
</script>

	</div>
</div>


<div id="footer">
	<div>© 2014 The Azul3D Authors, All Rights Reserved.</div>
	<div>Unless noted otherwise, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code is licensed under a BSD license.</div>
</div>


<script>
$(document).ready(function() {
	$("body").css("opacity", 0);

	 
	var ValidIpAddressRegex = "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$";
	var redirect = window.location.hostname != 'azul3d.org';
	if(location.hostname == "localhost" || location.hostname.search(ValidIpAddressRegex) != -1) {
		
		
		redirect = false;
	}
	if(redirect){
	    window.top.location.href = 'http://azul3d.org'; 
	}
});

$(window).ready(function() {
	var fadeIn = function(self, delay) {
		self.css("opacity", 0).delay(delay).animate({opacity: 1}, "slow");
	}

	var fromSameSite = document.referrer.indexOf(location.protocol + "//" + location.host) === 0;


	
	
	var longPage = $(document).height() > $(window).height() * 3;
	if(fromSameSite || longPage) {
		fadeIn($("body"), 10);
	} else {
		var workingIndex = 0;
		var speed = 75;
		$("#content").children().each(function(index) {
			fadeIn($(this), 1000 + (speed * workingIndex));
			workingIndex++;
			if($(this).hasClass("list")) {
				$(this).children().each(function(index) {
					fadeIn($(this), 1000 + (speed * workingIndex));
					workingIndex++;
				});
			}
		});

		var w = $("#shortbar").width();
		$("#shortbar").css({
			right: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			right: "0px",
			opacity: 1
			}, "slow");

		var w = $("#navigation").width();
		$("#navigation").css({
			left: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			left: "0px",
			opacity: 1
			}, "slow");

		fadeIn($("#logo"), 10);
		fadeIn($("body"), 10);
	}
})
</script>
	</body>
</html>



