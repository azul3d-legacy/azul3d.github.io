

<!DOCTYPE html>
<html lang="en">
	<head>
		
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<meta name="description" content="A 3D game engine written in Go!">
		<meta name="author" content="The Azul3D Authors">

		
		<link rel="image_src" href="http://azul3d.org/content/symbol_256x256.png">
		<meta property="og:image" content="http://azul3d.org/content/symbol_256x256.png">

		
			<title>Azul3D</title>
		
		<link rel="shortcut icon" href="/content/favicon.png"> 

		
		<link rel="stylesheet" type="text/css" href="/content/reset.css">

		
		<link href='//fonts.googleapis.com/css?family=Audiowide' rel='stylesheet' type='text/css'>
		<link href='//fonts.googleapis.com/css?family=Cutive+Mono' rel='stylesheet' type='text/css'>

		
		<link href='/content/dejavusans_book/stylesheet.css' rel='stylesheet' type='text/css'>

		
		<link href='/content/brandico/brandico.css' rel='stylesheet' type='text/css'>

		
		

		
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

		
		<link rel="stylesheet" type="text/css" href="/content/stylesheet.css">
		<link rel="stylesheet" type="text/css" href="/content/mq.css">
	</head>
	<body>


<div id="top"></div>






































<div id="toparea">
	<div id="logo">
		<a href="/"><span class="biohazard">☣</span>
		<span>Azul3D</span></a>
	</div>

	<div id="shortbar">
		<a href="https://github.com/azul3d" target="_blank"><i class="icon-github menuIcon"></i><div class="title">GitHub</div></a>
		<a href="https://twitter.com/hashtag/azul3d" target="_blank"><i class="icon-twitter-bird menuIcon"></i><div class="title">Twitter</div></a>
		<a href="https://www.facebook.com/pages/Azul3D/651643168254798" target="_blank"><i class="icon-facebook menuIcon"></i><div class="title">Facebook</div></a>
		<a href="https://groups.google.com/forum/#!forum/azul3d" target="_blank" class="mail"><i class="menuIcon mailIcon">✉</i><div class="title">Mailing List</div></a>
	</div>
</div>

<div id="navigation">
	<h1>Navigation</h1>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/">Home</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/news">News</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/packages.html">Packages</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/doc">Doc</a> | <a href="/doc/faq.html">FAQ</a></span></span>
	</span>
</div>


<div id="content-container">
	<div id="content" class="pkg-content">






<h1 class="hdr pkg hdr-general">Package audio</h1>
<span class="section pkg general">
	
		<p><em>In Development</em></p>
	
	<span class="pkg import">import "azul3d.org/audio.dev"</span>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#versions">Versions</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#overview">Overview</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#index">Index</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#package-files">Package Files</a></span></span>
	</span>
	
		<h2>WARNING!</h2>
		<span class="sub">
			
				<p>This version is the in-development -- <em><strong>unstable</strong></em> -- version of this package. Backwards incompatible changes will be made to this package in the future and as such <em>you should not use this version</em>! Please use the latest release <a href="/audio.v1">here</a>.</p>
			
		</span>
	

	
</span>



<h1 id="versions" class="hdr pkg hdr-versions"><a href="#versions" title="permalink">»</a>&nbsp;Versions <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg versions">
	
		<p>You are viewing an older version of this package (dev).</p>
	
	<p>Other versions of this package are available as follows. <em>Dev</em> is the in-development version of this package and should not generally be used (see <a href="/doc/versioning.html#development-versions">here</a> for more details).</p>
	<span class="list">
		
			
			
			
				
					<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="audio.v1" title="azul3d.org/audio.v1">v1</a> (latest version)</span></span>
				
			
		
			
			
			
				<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="audio.dev" title="azul3d.org/audio.dev">dev</a> (in development)</span></span>
			
		
	</span>
</span>



<h1 id="overview" class="hdr pkg hdr-overview"><a href="#overview" title="permalink">»</a>&nbsp;Overview <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg overview">
	<p>
Package audio implements various audio types and interfaces.
</p>
<p>
This package aims to be like the &#39;image&#39; package, except for audio.
</p>

</span>


<h1 id="index" class="hdr pkg hdr-index"><a href="#index" title="permalink">»</a>&nbsp;Index <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg index">
	<span class="list">
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#variables">Variables</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Copy">func Copy(dst Writer, src Reader) (written int64, err error)</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RegisterFormat">func RegisterFormat(name, magic string, newDecoder func(r interface{}) (Decoder, error))</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALaw">type ALaw</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16ToALaw">func PCM16ToALaw(s PCM16) ALaw</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALawSamples">type ALawSamples</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALawSamples.At">func (p ALawSamples) At(i int) F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALawSamples.Cap">func (p ALawSamples) Cap() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALawSamples.CopyTo">func (p ALawSamples) CopyTo(dst Slice) int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALawSamples.Len">func (p ALawSamples) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALawSamples.Make">func (p ALawSamples) Make(length, capacity int) Slice</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALawSamples.Set">func (p ALawSamples) Set(i int, s F64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALawSamples.Slice">func (p ALawSamples) Slice(low, high int) Slice</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer">type Buffer</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NewBuffer">func NewBuffer(buf Slice) *Buffer</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.Grow">func (b *Buffer) Grow(n int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.Len">func (b *Buffer) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.Next">func (b *Buffer) Next(n int) Slice</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.Read">func (b *Buffer) Read(p Slice) (n int, err error)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.ReadFrom">func (b *Buffer) ReadFrom(r Reader) (n int64, err error)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.ReadSample">func (b *Buffer) ReadSample() (c F64, err error)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.Reset">func (b *Buffer) Reset()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.Samples">func (b *Buffer) Samples() Slice</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.Seek">func (b *Buffer) Seek(offset uint64) error</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.Truncate">func (b *Buffer) Truncate(n int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.Write">func (b *Buffer) Write(p Slice) (n int, err error)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.WriteSample">func (b *Buffer) WriteSample(c F64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Buffer.WriteTo">func (b *Buffer) WriteTo(w Writer) (n int64, err error)</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Config">type Config</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Config.String">func (c Config) String() string</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Decoder">type Decoder</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#NewDecoder">func NewDecoder(r interface{}) (Decoder, string, error)</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Encoder">type Encoder</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F32">type F32</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F32Samples">type F32Samples</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F32Samples.At">func (p F32Samples) At(i int) F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F32Samples.Cap">func (p F32Samples) Cap() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F32Samples.CopyTo">func (p F32Samples) CopyTo(dst Slice) int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F32Samples.Len">func (p F32Samples) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F32Samples.Make">func (p F32Samples) Make(length, capacity int) Slice</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F32Samples.Set">func (p F32Samples) Set(i int, s F64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F32Samples.Slice">func (p F32Samples) Slice(low, high int) Slice</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64">type F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16ToF64">func PCM16ToF64(s PCM16) F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32ToF64">func PCM32ToF64(s PCM32) F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8ToF64">func PCM8ToF64(s PCM8) F64</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64Samples">type F64Samples</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64Samples.At">func (p F64Samples) At(i int) F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64Samples.Cap">func (p F64Samples) Cap() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64Samples.CopyTo">func (p F64Samples) CopyTo(dst Slice) int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64Samples.Len">func (p F64Samples) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64Samples.Make">func (p F64Samples) Make(length, capacity int) Slice</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64Samples.Set">func (p F64Samples) Set(i int, s F64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64Samples.Slice">func (p F64Samples) Slice(low, high int) Slice</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLaw">type MuLaw</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16ToMuLaw">func PCM16ToMuLaw(s PCM16) MuLaw</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLawSamples">type MuLawSamples</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLawSamples.At">func (p MuLawSamples) At(i int) F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLawSamples.Cap">func (p MuLawSamples) Cap() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLawSamples.CopyTo">func (p MuLawSamples) CopyTo(dst Slice) int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLawSamples.Len">func (p MuLawSamples) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLawSamples.Make">func (p MuLawSamples) Make(length, capacity int) Slice</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLawSamples.Set">func (p MuLawSamples) Set(i int, s F64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLawSamples.Slice">func (p MuLawSamples) Slice(low, high int) Slice</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16">type PCM16</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ALawToPCM16">func ALawToPCM16(s ALaw) PCM16</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64ToPCM16">func F64ToPCM16(s F64) PCM16</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MuLawToPCM16">func MuLawToPCM16(s MuLaw) PCM16</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16Samples">type PCM16Samples</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16Samples.At">func (p PCM16Samples) At(i int) F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16Samples.Cap">func (p PCM16Samples) Cap() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16Samples.CopyTo">func (p PCM16Samples) CopyTo(dst Slice) int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16Samples.Len">func (p PCM16Samples) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16Samples.Make">func (p PCM16Samples) Make(length, capacity int) Slice</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16Samples.Set">func (p PCM16Samples) Set(i int, s F64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM16Samples.Slice">func (p PCM16Samples) Slice(low, high int) Slice</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32">type PCM32</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64ToPCM32">func F64ToPCM32(s F64) PCM32</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32Samples">type PCM32Samples</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32Samples.At">func (p PCM32Samples) At(i int) F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32Samples.Cap">func (p PCM32Samples) Cap() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32Samples.CopyTo">func (p PCM32Samples) CopyTo(dst Slice) int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32Samples.Len">func (p PCM32Samples) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32Samples.Make">func (p PCM32Samples) Make(length, capacity int) Slice</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32Samples.Set">func (p PCM32Samples) Set(i int, s F64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM32Samples.Slice">func (p PCM32Samples) Slice(low, high int) Slice</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8">type PCM8</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#F64ToPCM8">func F64ToPCM8(s F64) PCM8</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8Samples">type PCM8Samples</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8Samples.At">func (p PCM8Samples) At(i int) F64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8Samples.Cap">func (p PCM8Samples) Cap() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8Samples.CopyTo">func (p PCM8Samples) CopyTo(dst Slice) int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8Samples.Len">func (p PCM8Samples) Len() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8Samples.Make">func (p PCM8Samples) Make(length, capacity int) Slice</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8Samples.Set">func (p PCM8Samples) Set(i int, s F64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PCM8Samples.Slice">func (p PCM8Samples) Slice(low, high int) Slice</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ReadSeeker">type ReadSeeker</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Reader">type Reader</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ReaderFrom">type ReaderFrom</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Slice">type Slice</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Writer">type Writer</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#WriterTo">type WriterTo</a></span></span>
			
			
		
	</span>
</span>








<h1 id="variables" class="hdr pkg hdr-variables"><a href="#variables" title="permalink">»</a>&nbsp;Variables <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg variables">
	
		<pre>var EOS = errors.New(&#34;end of stream&#34;)</pre>
		<p>EOS is the error returned by Read when no more input is available. Functions
should return EOS only to signal a graceful end of input. If the EOS occurs
unexpectedly in a structured data stream, the appropriate error is either
ErrUnexpectedEOS or some other error giving more detail.
</p>
	
		<pre>var ErrFormat = errors.New(&#34;audio: unknown format&#34;)</pre>
		<p>ErrFormat specifies an error where the format of the audio data is unknown
of by the registered formats of this package.
</p>
	
		<pre>var ErrInvalidData = errors.New(&#34;audio: input data is invalid or corrupt&#34;)</pre>
		<p>ErrInvalidData represents an error for decoding input data that is invalid
or corrupted for some reason.
</p>
	
		<pre>var ErrShortWrite = errors.New(&#34;short write&#34;)</pre>
		<p>ErrShortWrite means that a write accepted fewer bytes than requested but
failed to return an explicit error.
</p>
	
		<pre>var ErrUnexpectedEOS = errors.New(&#34;unexpected end of stream&#34;)</pre>
		<p>ErrUnexpectedEOS means that EOS was encountered in the middle of reading a
fixed-size block or data structure.
</p>
	
</span>





	<h1 id="Copy" class="hdr pkg hdr-function"><a href="#Copy" title="permalink">»</a>&nbsp;func Copy(dst Writer, src Reader) (written int64, err error) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Copy(dst Writer, src Reader) (written int64, err error)</pre>
		<p>
Copy copies from src to dst until either EOS is reached on src or an
error occurs.  It returns the number of samples copied and the first error
encountered while copying, if any.
</p>
<p>
A successful Copy returns err == nil, not err == EOS. Because Copy is
defined to read from src until EOS, it does not treat an EOS from Read as
an error to be reported.
</p>
<p>
If src implements the WriterTo interface, the copy is implemented by calling
src.WriteTo(dst). Otherwise, if dst implements the ReaderFrom interface, the
copy is implemented by calling dst.ReadFrom(src).
</p>

	</span>

	<h1 id="RegisterFormat" class="hdr pkg hdr-function"><a href="#RegisterFormat" title="permalink">»</a>&nbsp;func RegisterFormat(name, magic string, newDecoder func(r interface{}) (Decoder, error)) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func RegisterFormat(name, magic string, newDecoder func(r interface{}) (Decoder, error))</pre>
		<p>
RegisterFormat registers an image format for use by NewDecoder().
</p>
<p>
Name is the name of the format, like &#34;wav&#34; or &#34;ogg&#34;.
</p>
<p>
Magic is the magic prefix that identifies the format&#39;s encoding. The magic
string can contain &#34;?&#34; wildcards that each match any one byte.
</p>
<p>
newDecoder is the function that returns either [Decoder, nil] or
[nil, ErrInvalidData] upon being called where the returned decoder is used
to decode the io.Reader or io.ReadSeeker&#39;s encoded audio data.
</p>

	</span>





	
	<h1 id="ALaw" class="hdr pkg hdr-type"><a href="#ALaw" title="permalink">»</a>&nbsp;type ALaw <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ALaw uint8</pre>
		<p>
ALaw represents an uint8 alaw encoded audio sample.
</p>

	</span>

	
	
		<h1 id="PCM16ToALaw" class="hdr pkg hdr-function"><a href="#PCM16ToALaw" title="permalink">»</a>&nbsp;func PCM16ToALaw(s PCM16) ALaw <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func PCM16ToALaw(s PCM16) ALaw</pre>
			<p>
PCM16ToALaw converts an PCM16 encoded audio sample to an ALaw encoded audio
sample.
</p>

		</span>
	

	
	

	
	<h1 id="ALawSamples" class="hdr pkg hdr-type"><a href="#ALawSamples" title="permalink">»</a>&nbsp;type ALawSamples <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ALawSamples []ALaw</pre>
		<p>
ALawSamples represents an slice of ALaw encoded audio samples.
</p>

	</span>

	
	

	
	
		
		<h1 id="ALawSamples.At" class="hdr pkg hdr-method"><a href="#ALawSamples.At" title="permalink">»</a>&nbsp;func (p ALawSamples) At(i int) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p ALawSamples) At(i int) F64</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="ALawSamples.Cap" class="hdr pkg hdr-method"><a href="#ALawSamples.Cap" title="permalink">»</a>&nbsp;func (p ALawSamples) Cap() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p ALawSamples) Cap() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="ALawSamples.CopyTo" class="hdr pkg hdr-method"><a href="#ALawSamples.CopyTo" title="permalink">»</a>&nbsp;func (p ALawSamples) CopyTo(dst Slice) int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p ALawSamples) CopyTo(dst Slice) int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="ALawSamples.Len" class="hdr pkg hdr-method"><a href="#ALawSamples.Len" title="permalink">»</a>&nbsp;func (p ALawSamples) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p ALawSamples) Len() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="ALawSamples.Make" class="hdr pkg hdr-method"><a href="#ALawSamples.Make" title="permalink">»</a>&nbsp;func (p ALawSamples) Make(length, capacity int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p ALawSamples) Make(length, capacity int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="ALawSamples.Set" class="hdr pkg hdr-method"><a href="#ALawSamples.Set" title="permalink">»</a>&nbsp;func (p ALawSamples) Set(i int, s F64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p ALawSamples) Set(i int, s F64)</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="ALawSamples.Slice" class="hdr pkg hdr-method"><a href="#ALawSamples.Slice" title="permalink">»</a>&nbsp;func (p ALawSamples) Slice(low, high int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p ALawSamples) Slice(low, high int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	

	
	<h1 id="Buffer" class="hdr pkg hdr-type"><a href="#Buffer" title="permalink">»</a>&nbsp;type Buffer <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Buffer struct {
	// contains filtered or unexported fields
}</pre>
		<p>
A Buffer is a variable-sized buffer of audio samples with Read and Write
methods. Buffers must be allocated via the NewBuffer function.
</p>

	</span>

	
	
		<h1 id="NewBuffer" class="hdr pkg hdr-function"><a href="#NewBuffer" title="permalink">»</a>&nbsp;func NewBuffer(buf Slice) *Buffer <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func NewBuffer(buf Slice) *Buffer</pre>
			<p>
NewBuffer creates and initializes a new Buffer using buf as its initial
contents. The buffer will internally use the given slice, buf, which also
defines the sample storage type. NewBuffer is intended to prepare a Buffer
to read existing data. It can also be used to size the internal buffer for
writing. To do that, buf should have the desired capacity but a length of
zero.
</p>

		</span>
	

	
	
		
		<h1 id="Buffer.Grow" class="hdr pkg hdr-method"><a href="#Buffer.Grow" title="permalink">»</a>&nbsp;func (b *Buffer) Grow(n int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) Grow(n int)</pre>
			<p>
Grow grows the buffer&#39;s capacity, if necessary, to guarantee space for
another n samples. After Grow(n), at least n samples can be written to the
buffer without another allocation.
If n is negative, Grow will panic.
</p>

		</span>
	
		
		<h1 id="Buffer.Len" class="hdr pkg hdr-method"><a href="#Buffer.Len" title="permalink">»</a>&nbsp;func (b *Buffer) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) Len() int</pre>
			<p>
Len returns the number of samples of the unread portion of the buffer;
b.Len() == b.Samples().Len().
</p>

		</span>
	
		
		<h1 id="Buffer.Next" class="hdr pkg hdr-method"><a href="#Buffer.Next" title="permalink">»</a>&nbsp;func (b *Buffer) Next(n int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) Next(n int) Slice</pre>
			<p>
Next returns a slice containing the next n samples from the buffer,
advancing the buffer as if the samples had been returned by Read.
If there are fewer than n samples in the buffer, Next returns the entire buffer.
The slice is only valid until the next call to a read or write method.
</p>

		</span>
	
		
		<h1 id="Buffer.Read" class="hdr pkg hdr-method"><a href="#Buffer.Read" title="permalink">»</a>&nbsp;func (b *Buffer) Read(p Slice) (n int, err error) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) Read(p Slice) (n int, err error)</pre>
			<p>
Read reads the next p.Len() samples from the buffer or until the buffer
is drained.  The return value n is the number of samples read.  If the
buffer has no data to return, err is EOS (unless len(p) is zero);
otherwise it is nil.
</p>

		</span>
	
		
		<h1 id="Buffer.ReadFrom" class="hdr pkg hdr-method"><a href="#Buffer.ReadFrom" title="permalink">»</a>&nbsp;func (b *Buffer) ReadFrom(r Reader) (n int64, err error) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) ReadFrom(r Reader) (n int64, err error)</pre>
			<p>
ReadFrom reads data from r until EOS and appends it to the buffer, growing
the buffer as needed. The return value n is the number of samples read. Any
error except EOS encountered during the read is also returned.
</p>

		</span>
	
		
		<h1 id="Buffer.ReadSample" class="hdr pkg hdr-method"><a href="#Buffer.ReadSample" title="permalink">»</a>&nbsp;func (b *Buffer) ReadSample() (c F64, err error) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) ReadSample() (c F64, err error)</pre>
			<p>
ReadSample reads and returns the next sample from the buffer.
If no sample is available, it returns error EOS.
</p>

		</span>
	
		
		<h1 id="Buffer.Reset" class="hdr pkg hdr-method"><a href="#Buffer.Reset" title="permalink">»</a>&nbsp;func (b *Buffer) Reset() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) Reset()</pre>
			<p>
Reset resets the buffer so it has no content.
b.Reset() is the same as b.Truncate(0).
</p>

		</span>
	
		
		<h1 id="Buffer.Samples" class="hdr pkg hdr-method"><a href="#Buffer.Samples" title="permalink">»</a>&nbsp;func (b *Buffer) Samples() Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) Samples() Slice</pre>
			<p>
Samples returns a slice of the unread portion of the buffer. If the caller
changes the contents of the returned slice, the contents of the buffer will
change, provided there are no intervening method calls on the Buffer.
</p>

		</span>
	
		
		<h1 id="Buffer.Seek" class="hdr pkg hdr-method"><a href="#Buffer.Seek" title="permalink">»</a>&nbsp;func (b *Buffer) Seek(offset uint64) error <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) Seek(offset uint64) error</pre>
			<p>
Seek seeks to the specified sample number, relative to the start of the
stream. As such, subsequent Read() calls on the Buffer, begin reading at
the specified sample.
</p>
<p>
If offset &gt; b.Len(), then the offset is unchanged and the seek operation
fails returning error == EOS.
</p>

		</span>
	
		
		<h1 id="Buffer.Truncate" class="hdr pkg hdr-method"><a href="#Buffer.Truncate" title="permalink">»</a>&nbsp;func (b *Buffer) Truncate(n int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) Truncate(n int)</pre>
			<p>
Truncate discards all but the first n unread samples from the buffer.
It panics if n is negative or greater than the length of the buffer.
</p>

		</span>
	
		
		<h1 id="Buffer.Write" class="hdr pkg hdr-method"><a href="#Buffer.Write" title="permalink">»</a>&nbsp;func (b *Buffer) Write(p Slice) (n int, err error) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) Write(p Slice) (n int, err error)</pre>
			<p>
Write appends the contents of p to the buffer, growing the buffer as
needed. The return value n is the length of p; err is always nil.
</p>

		</span>
	
		
		<h1 id="Buffer.WriteSample" class="hdr pkg hdr-method"><a href="#Buffer.WriteSample" title="permalink">»</a>&nbsp;func (b *Buffer) WriteSample(c F64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) WriteSample(c F64)</pre>
			<p>
WriteSample appends the sample c to the buffer, growing the buffer as needed.
</p>

		</span>
	
		
		<h1 id="Buffer.WriteTo" class="hdr pkg hdr-method"><a href="#Buffer.WriteTo" title="permalink">»</a>&nbsp;func (b *Buffer) WriteTo(w Writer) (n int64, err error) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Buffer) WriteTo(w Writer) (n int64, err error)</pre>
			<p>
WriteTo writes data to w until the buffer is drained or an error occurs.
The return value n is the number of samples written; it always fits into an
int, but it is int64 to match the WriterTo interface. Any error
encountered during the write is also returned.
</p>

		</span>
	

	
	<h1 id="Config" class="hdr pkg hdr-type"><a href="#Config" title="permalink">»</a>&nbsp;type Config <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Config struct {
	// SampleRate is the number of audio samples that the stream is played or
	// recorded at.
	//
	// E.g. 44100 would be compact disc quality.
	SampleRate	int

	// Channels is the number of channels the stream contains.
	Channels	int
}</pre>
		<p>
Config represents an audio stream&#39;s configuration, like its sample rate and
number of interleaved channels.
</p>

	</span>

	
	

	
	
		
		<h1 id="Config.String" class="hdr pkg hdr-method"><a href="#Config.String" title="permalink">»</a>&nbsp;func (c Config) String() string <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c Config) String() string</pre>
			<p>
String returns an string representation of this audio config.
</p>

		</span>
	

	
	<h1 id="Decoder" class="hdr pkg hdr-type"><a href="#Decoder" title="permalink">»</a>&nbsp;type Decoder <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Decoder interface {
	ReadSeeker

	// Config returns the audio stream configuration of this decoder. It may
	// block until at least the configuration part of the stream has been read.
	Config() Config
}</pre>
		<p>
Decoder is the generic audio decoder interface, for use with the
RegisterFormat() function.
</p>

	</span>

	
	
		<h1 id="NewDecoder" class="hdr pkg hdr-function"><a href="#NewDecoder" title="permalink">»</a>&nbsp;func NewDecoder(r interface{}) (Decoder, string, error) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func NewDecoder(r interface{}) (Decoder, string, error)</pre>
			<p>
NewDecoder returns a decoder which can be used to decode the encoded audio
data stored in the io.Reader or io.ReadSeeker, &#39;r&#39;.
</p>
<p>
The string returned is the format name used during format registration.
</p>
<p>
Format registration is typically done by the init method of the codec-
specific package.
</p>

		</span>
	

	
	

	
	<h1 id="Encoder" class="hdr pkg hdr-type"><a href="#Encoder" title="permalink">»</a>&nbsp;type Encoder <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Encoder interface {
	Writer

	// Close closes the audio encoder, and finalizes the encoding process.
	// It must be called, or else the encoding process may not finish, and
	// the encoded data may be incomplete.
	//
	// Writing data to a closed encoder causes an encoder-specific behavior,
	// but most often a panic will occur.
	Close() error
}</pre>
		<p>
Encoder is the generic audio encoder interface.
</p>

	</span>

	
	

	
	

	
	<h1 id="F32" class="hdr pkg hdr-type"><a href="#F32" title="permalink">»</a>&nbsp;type F32 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type F32 float32</pre>
		<p>
F32 represents a 32-bit floating-point linear audio sample in the range
of -1 to +1.
</p>

	</span>

	
	

	
	

	
	<h1 id="F32Samples" class="hdr pkg hdr-type"><a href="#F32Samples" title="permalink">»</a>&nbsp;type F32Samples <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type F32Samples []F32</pre>
		<p>
F32Samples represents a slice of F32 encoded audio samples.
</p>

	</span>

	
	

	
	
		
		<h1 id="F32Samples.At" class="hdr pkg hdr-method"><a href="#F32Samples.At" title="permalink">»</a>&nbsp;func (p F32Samples) At(i int) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F32Samples) At(i int) F64</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F32Samples.Cap" class="hdr pkg hdr-method"><a href="#F32Samples.Cap" title="permalink">»</a>&nbsp;func (p F32Samples) Cap() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F32Samples) Cap() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F32Samples.CopyTo" class="hdr pkg hdr-method"><a href="#F32Samples.CopyTo" title="permalink">»</a>&nbsp;func (p F32Samples) CopyTo(dst Slice) int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F32Samples) CopyTo(dst Slice) int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F32Samples.Len" class="hdr pkg hdr-method"><a href="#F32Samples.Len" title="permalink">»</a>&nbsp;func (p F32Samples) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F32Samples) Len() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F32Samples.Make" class="hdr pkg hdr-method"><a href="#F32Samples.Make" title="permalink">»</a>&nbsp;func (p F32Samples) Make(length, capacity int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F32Samples) Make(length, capacity int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F32Samples.Set" class="hdr pkg hdr-method"><a href="#F32Samples.Set" title="permalink">»</a>&nbsp;func (p F32Samples) Set(i int, s F64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F32Samples) Set(i int, s F64)</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F32Samples.Slice" class="hdr pkg hdr-method"><a href="#F32Samples.Slice" title="permalink">»</a>&nbsp;func (p F32Samples) Slice(low, high int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F32Samples) Slice(low, high int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	

	
	<h1 id="F64" class="hdr pkg hdr-type"><a href="#F64" title="permalink">»</a>&nbsp;type F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type F64 float64</pre>
		<p>
F64 represents a 64-bit floating-point linear audio sample in the range
of -1 to +1.
</p>

	</span>

	
	
		<h1 id="PCM16ToF64" class="hdr pkg hdr-function"><a href="#PCM16ToF64" title="permalink">»</a>&nbsp;func PCM16ToF64(s PCM16) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func PCM16ToF64(s PCM16) F64</pre>
			<p>
PCM16ToF64 converts a PCM16 encoded audio sample to F64.
</p>

		</span>
	
		<h1 id="PCM32ToF64" class="hdr pkg hdr-function"><a href="#PCM32ToF64" title="permalink">»</a>&nbsp;func PCM32ToF64(s PCM32) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func PCM32ToF64(s PCM32) F64</pre>
			<p>
PCM32ToF64 converts a PCM32 encoded audio sample to F64.
</p>

		</span>
	
		<h1 id="PCM8ToF64" class="hdr pkg hdr-function"><a href="#PCM8ToF64" title="permalink">»</a>&nbsp;func PCM8ToF64(s PCM8) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func PCM8ToF64(s PCM8) F64</pre>
			<p>
PCM8ToF64 converts a PCM8 encoded audio sample to F64.
</p>

		</span>
	

	
	

	
	<h1 id="F64Samples" class="hdr pkg hdr-type"><a href="#F64Samples" title="permalink">»</a>&nbsp;type F64Samples <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type F64Samples []F64</pre>
		<p>
F64Samples represents a slice of F64 encoded audio samples.
</p>

	</span>

	
	

	
	
		
		<h1 id="F64Samples.At" class="hdr pkg hdr-method"><a href="#F64Samples.At" title="permalink">»</a>&nbsp;func (p F64Samples) At(i int) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F64Samples) At(i int) F64</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F64Samples.Cap" class="hdr pkg hdr-method"><a href="#F64Samples.Cap" title="permalink">»</a>&nbsp;func (p F64Samples) Cap() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F64Samples) Cap() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F64Samples.CopyTo" class="hdr pkg hdr-method"><a href="#F64Samples.CopyTo" title="permalink">»</a>&nbsp;func (p F64Samples) CopyTo(dst Slice) int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F64Samples) CopyTo(dst Slice) int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F64Samples.Len" class="hdr pkg hdr-method"><a href="#F64Samples.Len" title="permalink">»</a>&nbsp;func (p F64Samples) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F64Samples) Len() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F64Samples.Make" class="hdr pkg hdr-method"><a href="#F64Samples.Make" title="permalink">»</a>&nbsp;func (p F64Samples) Make(length, capacity int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F64Samples) Make(length, capacity int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F64Samples.Set" class="hdr pkg hdr-method"><a href="#F64Samples.Set" title="permalink">»</a>&nbsp;func (p F64Samples) Set(i int, s F64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F64Samples) Set(i int, s F64)</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="F64Samples.Slice" class="hdr pkg hdr-method"><a href="#F64Samples.Slice" title="permalink">»</a>&nbsp;func (p F64Samples) Slice(low, high int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p F64Samples) Slice(low, high int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	

	
	<h1 id="MuLaw" class="hdr pkg hdr-type"><a href="#MuLaw" title="permalink">»</a>&nbsp;type MuLaw <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type MuLaw uint8</pre>
		<p>
MuLaw represents an uint8 mulaw encoded audio sample.
</p>

	</span>

	
	
		<h1 id="PCM16ToMuLaw" class="hdr pkg hdr-function"><a href="#PCM16ToMuLaw" title="permalink">»</a>&nbsp;func PCM16ToMuLaw(s PCM16) MuLaw <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func PCM16ToMuLaw(s PCM16) MuLaw</pre>
			<p>
PCM16ToMuLaw converts from a PCM16 encoded audio sample to an MuLaw encoded
audio sample.
</p>

		</span>
	

	
	

	
	<h1 id="MuLawSamples" class="hdr pkg hdr-type"><a href="#MuLawSamples" title="permalink">»</a>&nbsp;type MuLawSamples <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type MuLawSamples []MuLaw</pre>
		<p>
MuLawSamples represents an slice of MuLaw encoded audio samples.
</p>

	</span>

	
	

	
	
		
		<h1 id="MuLawSamples.At" class="hdr pkg hdr-method"><a href="#MuLawSamples.At" title="permalink">»</a>&nbsp;func (p MuLawSamples) At(i int) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p MuLawSamples) At(i int) F64</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="MuLawSamples.Cap" class="hdr pkg hdr-method"><a href="#MuLawSamples.Cap" title="permalink">»</a>&nbsp;func (p MuLawSamples) Cap() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p MuLawSamples) Cap() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="MuLawSamples.CopyTo" class="hdr pkg hdr-method"><a href="#MuLawSamples.CopyTo" title="permalink">»</a>&nbsp;func (p MuLawSamples) CopyTo(dst Slice) int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p MuLawSamples) CopyTo(dst Slice) int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="MuLawSamples.Len" class="hdr pkg hdr-method"><a href="#MuLawSamples.Len" title="permalink">»</a>&nbsp;func (p MuLawSamples) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p MuLawSamples) Len() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="MuLawSamples.Make" class="hdr pkg hdr-method"><a href="#MuLawSamples.Make" title="permalink">»</a>&nbsp;func (p MuLawSamples) Make(length, capacity int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p MuLawSamples) Make(length, capacity int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="MuLawSamples.Set" class="hdr pkg hdr-method"><a href="#MuLawSamples.Set" title="permalink">»</a>&nbsp;func (p MuLawSamples) Set(i int, s F64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p MuLawSamples) Set(i int, s F64)</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="MuLawSamples.Slice" class="hdr pkg hdr-method"><a href="#MuLawSamples.Slice" title="permalink">»</a>&nbsp;func (p MuLawSamples) Slice(low, high int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p MuLawSamples) Slice(low, high int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	

	
	<h1 id="PCM16" class="hdr pkg hdr-type"><a href="#PCM16" title="permalink">»</a>&nbsp;type PCM16 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PCM16 int16</pre>
		<p>
PCM16 represents a signed 16-bit linear PCM audio sample.
</p>

	</span>

	
	
		<h1 id="ALawToPCM16" class="hdr pkg hdr-function"><a href="#ALawToPCM16" title="permalink">»</a>&nbsp;func ALawToPCM16(s ALaw) PCM16 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func ALawToPCM16(s ALaw) PCM16</pre>
			<p>
ALawToPCM16 converts an ALaw encoded audio sample to an PCM16 encoded audio
sample.
</p>

		</span>
	
		<h1 id="F64ToPCM16" class="hdr pkg hdr-function"><a href="#F64ToPCM16" title="permalink">»</a>&nbsp;func F64ToPCM16(s F64) PCM16 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func F64ToPCM16(s F64) PCM16</pre>
			<p>
F64ToPCM16 converts a F64 encoded audio sample to PCM16.
</p>

		</span>
	
		<h1 id="MuLawToPCM16" class="hdr pkg hdr-function"><a href="#MuLawToPCM16" title="permalink">»</a>&nbsp;func MuLawToPCM16(s MuLaw) PCM16 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func MuLawToPCM16(s MuLaw) PCM16</pre>
			<p>
MuLawToPCM16 converts from an MuLaw encoded audio sample to an PCM16 encoded
audio sample.
</p>

		</span>
	

	
	

	
	<h1 id="PCM16Samples" class="hdr pkg hdr-type"><a href="#PCM16Samples" title="permalink">»</a>&nbsp;type PCM16Samples <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PCM16Samples []PCM16</pre>
		<p>
PCM16Samples represents a slice of PCM16 encoded audio samples.
</p>

	</span>

	
	

	
	
		
		<h1 id="PCM16Samples.At" class="hdr pkg hdr-method"><a href="#PCM16Samples.At" title="permalink">»</a>&nbsp;func (p PCM16Samples) At(i int) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM16Samples) At(i int) F64</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM16Samples.Cap" class="hdr pkg hdr-method"><a href="#PCM16Samples.Cap" title="permalink">»</a>&nbsp;func (p PCM16Samples) Cap() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM16Samples) Cap() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM16Samples.CopyTo" class="hdr pkg hdr-method"><a href="#PCM16Samples.CopyTo" title="permalink">»</a>&nbsp;func (p PCM16Samples) CopyTo(dst Slice) int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM16Samples) CopyTo(dst Slice) int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM16Samples.Len" class="hdr pkg hdr-method"><a href="#PCM16Samples.Len" title="permalink">»</a>&nbsp;func (p PCM16Samples) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM16Samples) Len() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM16Samples.Make" class="hdr pkg hdr-method"><a href="#PCM16Samples.Make" title="permalink">»</a>&nbsp;func (p PCM16Samples) Make(length, capacity int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM16Samples) Make(length, capacity int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM16Samples.Set" class="hdr pkg hdr-method"><a href="#PCM16Samples.Set" title="permalink">»</a>&nbsp;func (p PCM16Samples) Set(i int, s F64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM16Samples) Set(i int, s F64)</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM16Samples.Slice" class="hdr pkg hdr-method"><a href="#PCM16Samples.Slice" title="permalink">»</a>&nbsp;func (p PCM16Samples) Slice(low, high int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM16Samples) Slice(low, high int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	

	
	<h1 id="PCM32" class="hdr pkg hdr-type"><a href="#PCM32" title="permalink">»</a>&nbsp;type PCM32 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PCM32 int32</pre>
		<p>
PCM32 represents a signed 32-bit linear PCM audio sample.
</p>

	</span>

	
	
		<h1 id="F64ToPCM32" class="hdr pkg hdr-function"><a href="#F64ToPCM32" title="permalink">»</a>&nbsp;func F64ToPCM32(s F64) PCM32 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func F64ToPCM32(s F64) PCM32</pre>
			<p>
F64ToPCM32 converts a F64 encoded audio sample to PCM32.
</p>

		</span>
	

	
	

	
	<h1 id="PCM32Samples" class="hdr pkg hdr-type"><a href="#PCM32Samples" title="permalink">»</a>&nbsp;type PCM32Samples <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PCM32Samples []PCM32</pre>
		<p>
PCM32Samples represents a slice of PCM32 encoded audio samples.
</p>

	</span>

	
	

	
	
		
		<h1 id="PCM32Samples.At" class="hdr pkg hdr-method"><a href="#PCM32Samples.At" title="permalink">»</a>&nbsp;func (p PCM32Samples) At(i int) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM32Samples) At(i int) F64</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM32Samples.Cap" class="hdr pkg hdr-method"><a href="#PCM32Samples.Cap" title="permalink">»</a>&nbsp;func (p PCM32Samples) Cap() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM32Samples) Cap() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM32Samples.CopyTo" class="hdr pkg hdr-method"><a href="#PCM32Samples.CopyTo" title="permalink">»</a>&nbsp;func (p PCM32Samples) CopyTo(dst Slice) int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM32Samples) CopyTo(dst Slice) int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM32Samples.Len" class="hdr pkg hdr-method"><a href="#PCM32Samples.Len" title="permalink">»</a>&nbsp;func (p PCM32Samples) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM32Samples) Len() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM32Samples.Make" class="hdr pkg hdr-method"><a href="#PCM32Samples.Make" title="permalink">»</a>&nbsp;func (p PCM32Samples) Make(length, capacity int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM32Samples) Make(length, capacity int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM32Samples.Set" class="hdr pkg hdr-method"><a href="#PCM32Samples.Set" title="permalink">»</a>&nbsp;func (p PCM32Samples) Set(i int, s F64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM32Samples) Set(i int, s F64)</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM32Samples.Slice" class="hdr pkg hdr-method"><a href="#PCM32Samples.Slice" title="permalink">»</a>&nbsp;func (p PCM32Samples) Slice(low, high int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM32Samples) Slice(low, high int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	

	
	<h1 id="PCM8" class="hdr pkg hdr-type"><a href="#PCM8" title="permalink">»</a>&nbsp;type PCM8 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PCM8 uint8</pre>
		<p>
PCM8 represents an unsigned 8-bit linear PCM audio sample.
</p>

	</span>

	
	
		<h1 id="F64ToPCM8" class="hdr pkg hdr-function"><a href="#F64ToPCM8" title="permalink">»</a>&nbsp;func F64ToPCM8(s F64) PCM8 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func F64ToPCM8(s F64) PCM8</pre>
			<p>
F64ToPCM8 converts a F64 encoded audio sample to PCM8.
</p>

		</span>
	

	
	

	
	<h1 id="PCM8Samples" class="hdr pkg hdr-type"><a href="#PCM8Samples" title="permalink">»</a>&nbsp;type PCM8Samples <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PCM8Samples []PCM8</pre>
		<p>
PCM8Samples represents a slice of PCM8 encoded audio samples.
</p>

	</span>

	
	

	
	
		
		<h1 id="PCM8Samples.At" class="hdr pkg hdr-method"><a href="#PCM8Samples.At" title="permalink">»</a>&nbsp;func (p PCM8Samples) At(i int) F64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM8Samples) At(i int) F64</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM8Samples.Cap" class="hdr pkg hdr-method"><a href="#PCM8Samples.Cap" title="permalink">»</a>&nbsp;func (p PCM8Samples) Cap() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM8Samples) Cap() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM8Samples.CopyTo" class="hdr pkg hdr-method"><a href="#PCM8Samples.CopyTo" title="permalink">»</a>&nbsp;func (p PCM8Samples) CopyTo(dst Slice) int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM8Samples) CopyTo(dst Slice) int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM8Samples.Len" class="hdr pkg hdr-method"><a href="#PCM8Samples.Len" title="permalink">»</a>&nbsp;func (p PCM8Samples) Len() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM8Samples) Len() int</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM8Samples.Make" class="hdr pkg hdr-method"><a href="#PCM8Samples.Make" title="permalink">»</a>&nbsp;func (p PCM8Samples) Make(length, capacity int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM8Samples) Make(length, capacity int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM8Samples.Set" class="hdr pkg hdr-method"><a href="#PCM8Samples.Set" title="permalink">»</a>&nbsp;func (p PCM8Samples) Set(i int, s F64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM8Samples) Set(i int, s F64)</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	
		
		<h1 id="PCM8Samples.Slice" class="hdr pkg hdr-method"><a href="#PCM8Samples.Slice" title="permalink">»</a>&nbsp;func (p PCM8Samples) Slice(low, high int) Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (p PCM8Samples) Slice(low, high int) Slice</pre>
			<p>
Implements Slice interface.
</p>

		</span>
	

	
	<h1 id="ReadSeeker" class="hdr pkg hdr-type"><a href="#ReadSeeker" title="permalink">»</a>&nbsp;type ReadSeeker <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ReadSeeker interface {
	Reader

	// Seek seeks to the specified sample number, relative to the start of the
	// stream. As such, subsequent Read() calls on the Reader, begin reading at
	// the specified sample.
	//
	// If any error is returned, it means it was impossible to seek to the
	// specified audio sample for some reason, and that the current playhead is
	// unchanged.
	Seek(sample uint64) error
}</pre>
		<p>
ReadSeeker is the generic seekable audio reader interface.
</p>

	</span>

	
	

	
	

	
	<h1 id="Reader" class="hdr pkg hdr-type"><a href="#Reader" title="permalink">»</a>&nbsp;type Reader <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Reader interface {
	// Read tries to read into the audio slice, b, filling it with at max
	// b.Len() audio samples.
	//
	// Returned is the number of samples that where read into the slice, and
	// an error if any occurred.
	//
	// It is possible for the number of samples read to be non-zero; and for an
	// error to be returned at the same time (E.g. read 300 audio samples, but
	// also encountered EOS).
	Read(b Slice) (read int, e error)
}</pre>
		<p>
Reader is a generic interface which describes any type who can have audio
samples read from it into an audio slice.
</p>

	</span>

	
	

	
	

	
	<h1 id="ReaderFrom" class="hdr pkg hdr-type"><a href="#ReaderFrom" title="permalink">»</a>&nbsp;type ReaderFrom <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ReaderFrom interface {
	ReadFrom(r Reader) (n int64, err error)
}</pre>
		<p>
ReaderFrom is the interface that wraps the ReadFrom method.
</p>
<p>
ReadFrom reads data from r until EOS or error. The return value n is the
number of bytes read. Any error except EOS encountered during the read is
also returned.
</p>
<p>
The Copy function uses ReaderFrom if available.
</p>

	</span>

	
	

	
	

	
	<h1 id="Slice" class="hdr pkg hdr-type"><a href="#Slice" title="permalink">»</a>&nbsp;type Slice <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Slice interface {
	// Len returns the number of elements in the slice.
	//
	// Equivalent slice syntax:
	//
	//  len(b)
	Len() int

	// Cap returns the number of elements in the slice.
	//
	// Equivalent slice syntax:
	//
	//  cap(b)
	Cap() int

	// Set sets the specified index in the slice to the specified F64 encoded
	// audio sample, s.
	//
	// If the slice&#39;s audio samples are not stored in F64 encoding, then the
	// sample should be converted to the slice&#39;s internal format and then
	// stored.
	//
	// Just like slices, slice indices must be non-negative; and no greater
	// than (Len() - 1), or else a panic may occur.
	//
	// Equivalent slice syntax:
	//
	//  b[index] = s
	//   -&gt; b.Set(index, s)
	//
	Set(index int, s F64)

	// At returns the F64 encoded audio sample at the specified index in the
	// slice.
	//
	// If the slice&#39;s audio samples are not stored in F64 encoding, then the
	// sample should be converted to F64 encoding, and subsequently returned.
	//
	// Just like slices, slice indices must be non-negative; and no greater
	// than (Len() - 1), or else a panic may occur.
	//
	// Equivalent slice syntax:
	//
	//  b[index]
	//   -&gt; b.At(index)
	//
	At(index int) F64

	// Slice returns a new slice of the slice, using the low and high
	// parameters.
	//
	// Equivalent slice syntax:
	//
	//  b[low:high]
	//   -&gt; b.Slice(low, high)
	//
	//  b[2:]
	//   -&gt; b.Slice(2, a.Len())
	//
	//  b[:3]
	//   -&gt; b.Slice(0, 3)
	//
	//  b[:]
	//   -&gt; b.Slice(0, a.Len())
	//
	Slice(low, high int) Slice

	// Make creates and returns a new slice of this slices type. This allows
	// allocating a new slice of exactly the same type for lossless copying of
	// data without knowing about the underlying type.
	//
	// It is exactly the same syntax as the make builtin:
	//
	//  make(MuLawSamples, len, cap)
	//
	// Where cap cannot be less than len.
	Make(length, capacity int) Slice

	// CopyTo operates exactly like the copy builtin, but this slice is always
	// the source operand. Equivalent slice syntax:
	//
	//  copy(dst, src)
	//   -&gt; src.CopyTo(dst)
	//
	CopyTo(dst Slice) int
}</pre>
		<p>
Slice is a generic audio slice, it can conceptually be thought of as a
slice of some audio encoding type.
</p>
<p>
Conversion between two encoded audio slices is as simple as:
</p>
<pre>dst, ok := src.(MuLawSamples)
if !ok {
    // Create a new slice of the target encoding and copy the samples over
    // because src is not MuLaw encoded.
    dst = make(MuLawSamples, src.Len())
    src.CopyTo(dst)
}
</pre>

	</span>

	
	

	
	

	
	<h1 id="Writer" class="hdr pkg hdr-type"><a href="#Writer" title="permalink">»</a>&nbsp;type Writer <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Writer interface {
	// Write attempts to write all, b.Len(), samples in the slice to the
	// writer.
	//
	// Returned is the number of samples from the slice that where wrote to
	// the writer, and an error if any occured.
	//
	// If the number of samples wrote is less than buf.Len() then the returned
	// error must be non-nil. If any error occurs it should be considered fatal
	// with regards to the writer: no more data can be subsequently wrote after
	// an error.
	Write(b Slice) (wrote int, err error)
}</pre>
		<p>
Writer is a generic interface which describes any type who can have audio
samples written from an audio slice into it.
</p>

	</span>

	
	

	
	

	
	<h1 id="WriterTo" class="hdr pkg hdr-type"><a href="#WriterTo" title="permalink">»</a>&nbsp;type WriterTo <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type WriterTo interface {
	WriteTo(w Writer) (n int64, err error)
}</pre>
		<p>
WriterTo is the interface that wraps the WriteTo method.
</p>
<p>
WriteTo writes data to w until there&#39;s no more data to write or when an
error occurs. The return value n is the number of samples written. Any error
encountered during the write is also returned.
</p>
<p>
The Copy function uses WriterTo if available.
</p>

	</span>

	
	

	
	



<h1 id="package-files" class="hdr pkg hdr-files"><a href="#package-files" title="permalink">»</a>&nbsp;Package Files <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg files">
	<p>
	<a href="https:/github.com/azul3d/audio/blob/dev/alaw.go" title="view source">alaw.go</a>
	
	<a href="https:/github.com/azul3d/audio/blob/dev/audio.go" title="view source">audio.go</a>
	
	<a href="https:/github.com/azul3d/audio/blob/dev/buffer.go" title="view source">buffer.go</a>
	
	<a href="https:/github.com/azul3d/audio/blob/dev/doc.go" title="view source">doc.go</a>
	
	<a href="https:/github.com/azul3d/audio/blob/dev/float.go" title="view source">float.go</a>
	
	<a href="https:/github.com/azul3d/audio/blob/dev/format.go" title="view source">format.go</a>
	
	<a href="https:/github.com/azul3d/audio/blob/dev/io.go" title="view source">io.go</a>
	
	<a href="https:/github.com/azul3d/audio/blob/dev/mulaw.go" title="view source">mulaw.go</a>
	
	<a href="https:/github.com/azul3d/audio/blob/dev/pcm.go" title="view source">pcm.go</a>
	
	<a href="https:/github.com/azul3d/audio/blob/dev/slice.go" title="view source">slice.go</a>
	</p>

	<h2><span class="linkarea">(<a href="#" id="tagged-files-toggle">show tagged files</a>)</span></h2>
	<span id="tagged-files">
		<h2>Test Files</h2>
		<p>
		<a href="https:/github.com/azul3d/audio/blob/dev/io_test.go" title="view source">io_test.go</a>
		</p>
	</span>
</span>


<script>
$(function() {
	$("#tagged-files").slideUp();
	var toggle = true;
	$("#tagged-files-toggle").click(function(event) {
		event.preventDefault();
		toggle = !toggle;
		if(toggle) {
			$("#tagged-files").slideUp();
			$("#tagged-files-toggle").html("show tagged files");
		} else {
			$("#tagged-files").slideDown();
			$("#tagged-files-toggle").html("hide tagged files");
		}
	});
});
</script>

	</div>
</div>


<div id="footer">
	<div>© 2014 The Azul3D Authors, All Rights Reserved.</div>
	<div><a href="/doc/license.html">License</a> | <a href="/doc/authors.html">Authors</a></div>
</div>


<script>
$(document).ready(function() {
	$("body").css("opacity", 0);

	 
	var ValidIpAddressRegex = "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$";
	var redirect = window.location.hostname != 'azul3d.org';
	if(location.hostname == "localhost" || location.hostname.search(ValidIpAddressRegex) != -1) {
		
		
		redirect = false;
	}
	if(redirect){
	    window.top.location.href = 'http://azul3d.org'; 
	}
});

$(window).ready(function() {
	var fadeIn = function(self, delay) {
		self.css("opacity", 0).delay(delay).animate({opacity: 1}, "slow");
	}

	var fromSameSite = document.referrer.indexOf(location.protocol + "//" + location.host) === 0;


	
	
	var longPage = $(document).height() > $(window).height() * 3;
	if(fromSameSite || longPage) {
		fadeIn($("body"), 10);
	} else {
		var workingIndex = 0;
		var speed = 75;
		$("#content").children().each(function(index) {
			fadeIn($(this), 1000 + (speed * workingIndex));
			workingIndex++;
			if($(this).hasClass("list")) {
				$(this).children().each(function(index) {
					fadeIn($(this), 1000 + (speed * workingIndex));
					workingIndex++;
				});
			}
		});

		var w = $("#shortbar").width();
		$("#shortbar").css({
			right: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			right: "0px",
			opacity: 1
			}, "slow");

		var w = $("#navigation").width();
		$("#navigation").css({
			left: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			left: "0px",
			opacity: 1
			}, "slow");

		fadeIn($("#logo"), 10);
		fadeIn($("body"), 10);
	}
})
</script>
	</body>
</html>



