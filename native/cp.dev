

<!DOCTYPE html>
<html lang="en">
	<head>
		
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<meta name="description" content="A 3D game engine written in Go!">
		<meta name="author" content="The Azul3D Authors">
		<title>Azul3D</title>
		<link rel="shortcut icon" href="/content/favicon.png"> 

		
		<link rel="stylesheet" type="text/css" href="/content/reset.css">

		
		<link href='http://fonts.googleapis.com/css?family=Audiowide' rel='stylesheet' type='text/css'>
		<link href='http://fonts.googleapis.com/css?family=Cutive+Mono' rel='stylesheet' type='text/css'>

		
		<link href='/content/dejavusans_book/stylesheet.css' rel='stylesheet' type='text/css'>

		
		<link href='/content/brandico/brandico.css' rel='stylesheet' type='text/css'>

		
		

		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

		
		<link rel="stylesheet" type="text/css" href="/content/stylesheet.css">
		<link rel="stylesheet" type="text/css" href="/content/mq.css">
	</head>
	<body>


<div id="top"></div>






































<div id="toparea">
	<div id="logo">
		<a href="/"><span class="biohazard">☣</span>
		<span>Azul3D</span></a>
	</div>

	<div id="shortbar">
		<a href="https://github.com/azul3d" target="_blank"><i class="icon-github menuIcon"></i><div class="title">GitHub</div></a>
		<a href="https://twitter.com/hashtag/azul3d" target="_blank"><i class="icon-twitter-bird menuIcon"></i><div class="title">Twitter</div></a>
		<a href="https://www.facebook.com/pages/Azul3D/651643168254798" target="_blank"><i class="icon-facebook menuIcon"></i><div class="title">Facebook</div></a>
		<a href="https://groups.google.com/forum/#!forum/azul3d" target="_blank" class="mail"><i class="menuIcon mailIcon">✉</i><div class="title">Mailing List</div></a>
	</div>
</div>

<div id="navigation">
	<h1>Navigation</h1>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/">Home</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/news">News</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/packages.html">Packages</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="/doc/faq.html">FAQ</a></span></span>
	</span>
</div>


<div id="content-container">
	<div id="content" class="pkg-content">






<h1 class="hdr pkg hdr-general">Package cp</h1>
<span class="section pkg general">
	
		<p><em>In Development</em></p>
	
	<span class="pkg import">import "azul3d.org/native/cp.dev"</span>
	<span class="list">
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#versions">Versions</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#overview">Overview</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#index">Index</a></span></span>
		<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#package-files">Package Files</a></span></span>
	</span>
	
		<h2>WARNING!</h2>
		<span class="sub">
			
				<p>This version is the in-development -- <em><strong>unstable</strong></em> -- version of this package. Backwards incompatible changes will be made to this package in the future and as such <em>you should not use this version</em>! Please use the latest release <a href="/native/cp.v1">here</a>.</p>
			
		</span>
	

	
</span>



<h1 id="versions" class="hdr pkg hdr-versions"><a href="#versions" title="permalink">»</a>&nbsp;Versions <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg versions">
	
		<p>You are viewing an older version of this package (dev).</p>
	
	<p>Other versions of this package are available as follows. <em>Dev</em> is the in-development version of this package and should not generally be used (see <a href="/doc/versioning.html#development-versions">here</a> for more details).</p>
	<span class="list">
		
			
			
			
				
					<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="native/cp.v1" title="azul3d.org/native/cp.v1">v1</a> (latest version)</span></span>
				
			
		
			
			
			
				<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="native/cp.dev" title="azul3d.org/native/cp.dev">dev</a> (in development)</span></span>
			
		
	</span>
</span>



<h1 id="overview" class="hdr pkg hdr-overview"><a href="#overview" title="permalink">»</a>&nbsp;Overview <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg overview">
	<p>
Package cp is a wrapper for the Chipmunk 2D Physics Engine.
</p>
<p>
More information about Chipmunk can be found at:
</p>
<pre><a href="http://chipmunk-physics.net/">http://chipmunk-physics.net/</a>
</pre>
<p>
This package uses the Chipmunk library, and as such it is also bound by it&#39;s
license which can be found at:
</p>
<pre><a href="https://github.com/slembcke/Chipmunk2D/blob/master/LICENSE.txt">https://github.com/slembcke/Chipmunk2D/blob/master/LICENSE.txt</a>
</pre>

</span>


<h1 id="index" class="hdr pkg hdr-index"><a href="#index" title="permalink">»</a>&nbsp;Index <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg index">
	<span class="list">
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#constants">Constants</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#variables">Variables</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#AreaForCircle">func AreaForCircle(r1, r2 float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#AreaForPoly">func AreaForPoly(verts []Vect, radius float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#AreaForSegment">func AreaForSegment(a, b Vect, radius float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BodyUpdatePosition">func BodyUpdatePosition(b *Body, dt float64)</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BodyUpdateVelocity">func BodyUpdateVelocity(b *Body, gravity Vect, damping, dt float64)</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ConvexHull">func ConvexHull(count int, verts, result *Vect, first *int, tol float64) int</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Fabs">func Fabs(f float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Fclamp">func Fclamp(f, min, max float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Fclamp01">func Fclamp01(f float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Flerp">func Flerp(f1, f2, t float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Flerpconst">func Flerpconst(f1, f2, d float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Fmax">func Fmax(a, b float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Fmin">func Fmin(a, b float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MomentForBox">func MomentForBox(m, width, height float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MomentForBox2">func MomentForBox2(m float64, box BB) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MomentForCircle">func MomentForCircle(m, r1, r2 float64, offset Vect) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MomentForPoly">func MomentForPoly(m float64, verts []Vect, offset Vect, radius float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#MomentForSegment">func MomentForSegment(m float64, a, b Vect, radius float64) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vcross">func Vcross(v1, v2 Vect) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vdist">func Vdist(v1, v2 Vect) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vdistsq">func Vdistsq(v1, v2 Vect) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Veql">func Veql(v1, v2 Vect) bool</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vlength">func Vlength(v Vect) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vlengthsq">func Vlengthsq(v Vect) float64</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vnear">func Vnear(v1, v2 Vect, dist float64) bool</a></span></span>
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vtoangle">func Vtoangle(v Vect) float64</a></span></span>
		
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter">type Arbiter</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.CallWildcardBeginA">func (a *Arbiter) CallWildcardBeginA(space *Space) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.CallWildcardBeginB">func (a *Arbiter) CallWildcardBeginB(space *Space) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.CallWildcardPostSolveA">func (a *Arbiter) CallWildcardPostSolveA(space *Space)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.CallWildcardPostSolveB">func (a *Arbiter) CallWildcardPostSolveB(space *Space)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.CallWildcardPreSolveA">func (a *Arbiter) CallWildcardPreSolveA(space *Space) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.CallWildcardPreSolveB">func (a *Arbiter) CallWildcardPreSolveB(space *Space) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.CallWildcardSeparateA">func (a *Arbiter) CallWildcardSeparateA(space *Space)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.CallWildcardSeparateB">func (a *Arbiter) CallWildcardSeparateB(space *Space)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.ContactPointSet">func (a *Arbiter) ContactPointSet() *ContactPointSet</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.Count">func (a *Arbiter) Count() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.Depth">func (a *Arbiter) Depth(i int) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.Friction">func (a *Arbiter) Friction() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.GetNormal">func (a *Arbiter) GetNormal() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.Ignore">func (a *Arbiter) Ignore() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.IsFirstContact">func (a *Arbiter) IsFirstContact() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.IsRemoval">func (a *Arbiter) IsRemoval() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.Point1">func (a *Arbiter) Point1(i int) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.Point2">func (a *Arbiter) Point2(i int) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.Restitution">func (a *Arbiter) Restitution() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.SetContactPointSet">func (a *Arbiter) SetContactPointSet(set *ContactPointSet)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.SetFriction">func (a *Arbiter) SetFriction(friction float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.SetRestitution">func (a *Arbiter) SetRestitution(restitution float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.SetSurfaceVelocity">func (a *Arbiter) SetSurfaceVelocity(vr Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.SetUserData">func (a *Arbiter) SetUserData(i interface{})</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.Shapes">func (arb *Arbiter) Shapes() (a, b *Shape)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.SurfaceVelocity">func (a *Arbiter) SurfaceVelocity() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.TotalImpulse">func (a *Arbiter) TotalImpulse() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.TotalKE">func (a *Arbiter) TotalKE() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Arbiter.UserData">func (a *Arbiter) UserData() interface{}</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Array">type Array</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB">type BB</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BBNew">func BBNew(l, b, r, t float64) BB</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BBNewForCircle">func BBNewForCircle(p Vect, r float64) BB</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BBNewForExtents">func BBNewForExtents(c Vect, hw, hh float64) BB</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.Area">func (bb BB) Area() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.Center">func (bb BB) Center() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.ClampVect">func (bb BB) ClampVect(v Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.ContainsBB">func (bb BB) ContainsBB(other BB) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.ContainsVect">func (bb BB) ContainsVect(v Vect) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.Expand">func (bb BB) Expand(v Vect) BB</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.Intersects">func (a BB) Intersects(b BB) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.IntersectsSegment">func (bb BB) IntersectsSegment(a, b Vect) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.Merge">func (a BB) Merge(b BB) BB</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.MergedArea">func (a BB) MergedArea(b BB) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.SegmentQuery">func (bb BB) SegmentQuery(a, b Vect) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BB.WrapVect">func (bb BB) WrapVect(v Vect) Vect</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Bitmask">type Bitmask</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body">type Body</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BodyNew">func BodyNew(mass, moment float64) *Body</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BodyNewKinematic">func BodyNewKinematic() *Body</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BodyNewStatic">func BodyNewStatic() *Body</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Activate">func (b *Body) Activate()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.ActivateStatic">func (b *Body) ActivateStatic(filter *Shape)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Angle">func (b *Body) Angle() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.AngularVelocity">func (b *Body) AngularVelocity() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.ApplyForceAtLocalPoint">func (b *Body) ApplyForceAtLocalPoint(force, point Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.ApplyForceAtWorldPoint">func (b *Body) ApplyForceAtWorldPoint(force, point Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.ApplyImpulseAtLocalPoint">func (b *Body) ApplyImpulseAtLocalPoint(impulse, point Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.ApplyImpulseAtWorldPoint">func (b *Body) ApplyImpulseAtWorldPoint(impulse, point Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.BoxShapeNew">func (b *Body) BoxShapeNew(width, height, radius float64) *Shape</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.BoxShapeNew2">func (b *Body) BoxShapeNew2(box BB, radius float64) *Shape</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.CenterOfGravity">func (b *Body) CenterOfGravity() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.CircleShapeNew">func (b *Body) CircleShapeNew(radius float64, offset Vect) *Shape</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.EachArbiter">func (b *Body) EachArbiter(f func(b *Body, a *Arbiter))</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.EachConstraint">func (b *Body) EachConstraint(f func(b *Body, c *Constraint))</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.EachShape">func (b *Body) EachShape(f func(b *Body, s *Shape))</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Force">func (b *Body) Force() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Free">func (b *Body) Free()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.IsSleeping">func (b *Body) IsSleeping() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.KineticEnergy">func (b *Body) KineticEnergy() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.LocalToWorld">func (b *Body) LocalToWorld(point Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Mass">func (b *Body) Mass() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Moment">func (b *Body) Moment() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.PolyShapeNew">func (b *Body) PolyShapeNew(verts []Vect, transform Transform, radius float64) *Shape</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Position">func (b *Body) Position() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Rotation">func (b *Body) Rotation() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SegmentShapeNew">func (bd *Body) SegmentShapeNew(a, b Vect, radius float64) *Shape</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetAngle">func (b *Body) SetAngle(a float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetAngularVelocity">func (b *Body) SetAngularVelocity(angularVelocity float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetCenterOfGravity">func (b *Body) SetCenterOfGravity(cog Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetForce">func (b *Body) SetForce(force Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetMass">func (b *Body) SetMass(m float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetMoment">func (b *Body) SetMoment(i float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetPosition">func (b *Body) SetPosition(pos Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetPositionUpdateFunc">func (b *Body) SetPositionUpdateFunc(f BodyPositionFunc)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetTorque">func (b *Body) SetTorque(torque float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetType">func (b *Body) SetType(t BodyType)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetUserData">func (b *Body) SetUserData(userData interface{})</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetVelocity">func (b *Body) SetVelocity(velocity Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SetVelocityUpdateFunc">func (b *Body) SetVelocityUpdateFunc(f BodyVelocityFunc)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Sleep">func (b *Body) Sleep()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.SleepWithGroup">func (b *Body) SleepWithGroup(group *Body)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Space">func (b *Body) Space() *Space</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Torque">func (b *Body) Torque() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Type">func (b *Body) Type() BodyType</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.UserData">func (b *Body) UserData() interface{}</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.Velocity">func (b *Body) Velocity() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.VelocityAtLocalPoint">func (b *Body) VelocityAtLocalPoint(point Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.VelocityAtWorldPoint">func (b *Body) VelocityAtWorldPoint(point Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Body.WorldToLocal">func (b *Body) WorldToLocal(point Vect) Vect</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BodyPositionFunc">type BodyPositionFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BodyType">type BodyType</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#BodyVelocityFunc">type BodyVelocityFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CircleShape">type CircleShape</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CollisionBeginFunc">type CollisionBeginFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CollisionHandler">type CollisionHandler</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CollisionID">type CollisionID</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CollisionPostSolveFunc">type CollisionPostSolveFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CollisionPreSolveFunc">type CollisionPreSolveFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CollisionSeparateFunc">type CollisionSeparateFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CollisionType">type CollisionType</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint">type Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DampedRotarySpringNew">func DampedRotarySpringNew(a, b *Body, restAngle, stiffness, damping float64) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DampedSpringNew">func DampedSpringNew(a, b *Body, anchorA, anchorB Vect, restLength, stiffness, damping float64) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GearJointNew">func GearJointNew(a, b *Body, phase, ratio float64) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GrooveJointNew">func GrooveJointNew(a, b *Body, grooveA, grooveB, anchorB Vect) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PinJointNew">func PinJointNew(a, b *Body, anchorA, anchorB Vect) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PivotJointNew">func PivotJointNew(a, b *Body, pivot Vect) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PivotJointNew2">func PivotJointNew2(a, b *Body, anchorA, anchorB Vect) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RatchetJointNew">func RatchetJointNew(a, b *Body, phase, ratchet float64) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RotaryLimitJointNew">func RotaryLimitJointNew(a, b *Body, min, max float64) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SimpleMotorNew">func SimpleMotorNew(a, b *Body, rate float64) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SlideJointNew">func SlideJointNew(a, b *Body, anchorA, anchorB Vect, min, max float64) *Constraint</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.BodyA">func (c *Constraint) BodyA() *Body</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.BodyB">func (c *Constraint) BodyB() *Body</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.CollideBodies">func (c *Constraint) CollideBodies() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedRotarySpringDamping">func (c *Constraint) DampedRotarySpringDamping() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedRotarySpringRestAngle">func (c *Constraint) DampedRotarySpringRestAngle() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedRotarySpringSetDamping">func (c *Constraint) DampedRotarySpringSetDamping(damping float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedRotarySpringSetStiffness">func (c *Constraint) DampedRotarySpringSetStiffness(stiffness float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedRotarySpringSetTorqueFunc">func (c *Constraint) DampedRotarySpringSetTorqueFunc(f func(spring *Constraint, relativeAngle float64) float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedRotarySpringStiffness">func (c *Constraint) DampedRotarySpringStiffness() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedRotarySpringTorqueFunc">func (c *Constraint) DampedRotarySpringTorqueFunc() func(spring *Constraint, relativeAngle float64) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringAnchorA">func (c *Constraint) DampedSpringAnchorA() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringAnchorB">func (c *Constraint) DampedSpringAnchorB() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringDamping">func (c *Constraint) DampedSpringDamping() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringForceFunc">func (c *Constraint) DampedSpringForceFunc() func(spring *Constraint, dist float64) float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringRestLength">func (c *Constraint) DampedSpringRestLength() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringSetAnchorA">func (c *Constraint) DampedSpringSetAnchorA(anchorA Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringSetAnchorB">func (c *Constraint) DampedSpringSetAnchorB(anchorA Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringSetDamping">func (c *Constraint) DampedSpringSetDamping(damping float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringSetForceFunc">func (c *Constraint) DampedSpringSetForceFunc(f func(spring *Constraint, dist float64) float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringSetRestLength">func (c *Constraint) DampedSpringSetRestLength(restLength float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringSetStiffness">func (c *Constraint) DampedSpringSetStiffness(stiffness float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.DampedSpringStiffness">func (c *Constraint) DampedSpringStiffness() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.ErrorBias">func (c *Constraint) ErrorBias() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.Free">func (c *Constraint) Free()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GearJointPhase">func (c *Constraint) GearJointPhase() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GearJointRatio">func (c *Constraint) GearJointRatio() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GearJointSetPhase">func (c *Constraint) GearJointSetPhase(phase float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GearJointSetRatio">func (c *Constraint) GearJointSetRatio(ratio float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GrooveJointAnchorB">func (c *Constraint) GrooveJointAnchorB() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GrooveJointGrooveA">func (c *Constraint) GrooveJointGrooveA() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GrooveJointGrooveB">func (c *Constraint) GrooveJointGrooveB() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GrooveJointSetAnchorB">func (c *Constraint) GrooveJointSetAnchorB(grooveB Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GrooveJointSetGrooveA">func (c *Constraint) GrooveJointSetGrooveA(grooveA Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.GrooveJointSetGrooveB">func (c *Constraint) GrooveJointSetGrooveB(grooveB Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.Impulse">func (c *Constraint) Impulse() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsDampedRotarySpring">func (c *Constraint) IsDampedRotarySpring() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsDampedSpring">func (c *Constraint) IsDampedSpring() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsGearJoint">func (c *Constraint) IsGearJoint() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsGrooveJoint">func (c *Constraint) IsGrooveJoint() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsPinJoint">func (c *Constraint) IsPinJoint() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsPivotJoint">func (c *Constraint) IsPivotJoint() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsRatchetJoint">func (c *Constraint) IsRatchetJoint() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsRotaryLimitJoint">func (c *Constraint) IsRotaryLimitJoint() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsSimpleMotor">func (c *Constraint) IsSimpleMotor() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.IsSlideJoint">func (c *Constraint) IsSlideJoint() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.MaxBias">func (c *Constraint) MaxBias() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.MaxForce">func (c *Constraint) MaxForce() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PinJointAnchorA">func (c *Constraint) PinJointAnchorA() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PinJointAnchorB">func (c *Constraint) PinJointAnchorB() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PinJointDist">func (c *Constraint) PinJointDist() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PinJointSetAnchorA">func (c *Constraint) PinJointSetAnchorA(anchorA Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PinJointSetAnchorB">func (c *Constraint) PinJointSetAnchorB(anchorB Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PinJointSetDist">func (c *Constraint) PinJointSetDist(dist float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PivotJointAnchorA">func (c *Constraint) PivotJointAnchorA() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PivotJointAnchorB">func (c *Constraint) PivotJointAnchorB() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PivotJointSetAnchorA">func (c *Constraint) PivotJointSetAnchorA(anchorA Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PivotJointSetAnchorB">func (c *Constraint) PivotJointSetAnchorB(anchorB Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PostSolveFunc">func (c *Constraint) PostSolveFunc() func(*Constraint, *Space)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.PreSolveFunc">func (c *Constraint) PreSolveFunc() func(*Constraint, *Space)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RatchetJointAngle">func (c *Constraint) RatchetJointAngle() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RatchetJointPhase">func (c *Constraint) RatchetJointPhase() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RatchetJointRatchet">func (c *Constraint) RatchetJointRatchet() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RatchetJointSetAngle">func (c *Constraint) RatchetJointSetAngle(angle float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RatchetJointSetPhase">func (c *Constraint) RatchetJointSetPhase(phase float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RatchetJointSetRatchet">func (c *Constraint) RatchetJointSetRatchet(ratchet float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RotaryLimitJointMax">func (c *Constraint) RotaryLimitJointMax() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RotaryLimitJointMin">func (c *Constraint) RotaryLimitJointMin() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RotaryLimitJointSetMax">func (c *Constraint) RotaryLimitJointSetMax(max float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RotaryLimitJointSetMin">func (c *Constraint) RotaryLimitJointSetMin(min float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.RotarySpringSetRestAngle">func (c *Constraint) RotarySpringSetRestAngle(restAngle float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SetCollideBodies">func (c *Constraint) SetCollideBodies(collideBodies bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SetErrorBias">func (c *Constraint) SetErrorBias(errorBias float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SetMaxBias">func (c *Constraint) SetMaxBias(maxBias float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SetMaxForce">func (c *Constraint) SetMaxForce(maxForce float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SetPostSolveFunc">func (c *Constraint) SetPostSolveFunc(f func(*Constraint, *Space))</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SetPreSolveFunc">func (c *Constraint) SetPreSolveFunc(f func(*Constraint, *Space))</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SetUserData">func (c *Constraint) SetUserData(i interface{})</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SimpleMotorRate">func (c *Constraint) SimpleMotorRate() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SimpleMotorSetRate">func (c *Constraint) SimpleMotorSetRate(rate float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SlideJointAnchorA">func (c *Constraint) SlideJointAnchorA() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SlideJointAnchorB">func (c *Constraint) SlideJointAnchorB() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SlideJointMax">func (c *Constraint) SlideJointMax() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SlideJointMin">func (c *Constraint) SlideJointMin() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SlideJointSetAnchorA">func (c *Constraint) SlideJointSetAnchorA(anchorA Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SlideJointSetAnchorB">func (c *Constraint) SlideJointSetAnchorB(anchorB Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SlideJointSetMax">func (c *Constraint) SlideJointSetMax(max float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.SlideJointSetMin">func (c *Constraint) SlideJointSetMin(min float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.Space">func (c *Constraint) Space() *Space</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Constraint.UserData">func (c *Constraint) UserData() interface{}</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ConstraintPostSolveFunc">type ConstraintPostSolveFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ConstraintPreSolveFunc">type ConstraintPreSolveFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ContactBufferHeader">type ContactBufferHeader</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ContactPoint">type ContactPoint</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ContactPointSet">type ContactPointSet</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DampedRotarySpring">type DampedRotarySpring</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DampedSpring">type DampedSpring</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#DataPointer">type DataPointer</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GearJoint">type GearJoint</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#GrooveJoint">type GrooveJoint</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Group">type Group</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#HashSet">type HashSet</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#HashValue">type HashValue</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Int">type Int</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat2x2">type Mat2x2</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat2x2New">func Mat2x2New(a, b, c, d float64) Mat2x2</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Mat2x2.Transform">func (m Mat2x2) Transform(v Vect) Vect</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PinJoint">type PinJoint</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PivotJoint">type PivotJoint</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PointQueryInfo">type PointQueryInfo</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#PolyShape">type PolyShape</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RatchetJoint">type RatchetJoint</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#RotaryLimitJoint">type RotaryLimitJoint</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SegmentQueryInfo">type SegmentQueryInfo</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SegmentShape">type SegmentShape</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape">type Shape</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Area">func (s *Shape) Area() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.BB">func (s *Shape) BB() BB</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Body">func (s *Shape) Body() *Body</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.CacheBB">func (s *Shape) CacheBB() BB</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.CenterOfGravity">func (s *Shape) CenterOfGravity() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.CircleOffset">func (s *Shape) CircleOffset() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.CircleRadius">func (s *Shape) CircleRadius() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.CircleShapeSetOffset">func (shape *Shape) CircleShapeSetOffset(offset Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.CircleShapeSetRadius">func (shape *Shape) CircleShapeSetRadius(radius float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.CollisionType">func (s *Shape) CollisionType() CollisionType</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Density">func (s *Shape) Density() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Elasticity">func (s *Shape) Elasticity() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Filter">func (s *Shape) Filter() ShapeFilter</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Free">func (s *Shape) Free()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Friction">func (s *Shape) Friction() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Mass">func (s *Shape) Mass() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Moment">func (s *Shape) Moment() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.PointQuery">func (s *Shape) PointQuery(p Vect) (out *PointQueryInfo, d float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.PolyCount">func (s *Shape) PolyCount() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.PolyRadius">func (s *Shape) PolyRadius() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.PolyShapeSetRadius">func (shape *Shape) PolyShapeSetRadius(radius float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.PolyShapeSetVerts">func (shape *Shape) PolyShapeSetVerts(verts []Vect, transform Transform)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.PolyShapeSetVertsRaw">func (shape *Shape) PolyShapeSetVertsRaw(verts []Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.PolyVert">func (s *Shape) PolyVert(index int) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SegmentA">func (s *Shape) SegmentA() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SegmentB">func (s *Shape) SegmentB() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SegmentNormal">func (s *Shape) SegmentNormal() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SegmentQuery">func (s *Shape) SegmentQuery(a, b Vect, radius float64) (info *SegmentQueryInfo, ret bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SegmentRadius">func (s *Shape) SegmentRadius() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SegmentSetNeighbors">func (s *Shape) SegmentSetNeighbors(prev, next Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SegmentShapeSetEndpoints">func (shape *Shape) SegmentShapeSetEndpoints(a, b Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SegmentShapeSetRadius">func (shape *Shape) SegmentShapeSetRadius(radius float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Sensor">func (s *Shape) Sensor() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetBody">func (s *Shape) SetBody(b *Body)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetCollisionType">func (s *Shape) SetCollisionType(collisionType CollisionType)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetDensity">func (s *Shape) SetDensity(density float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetElasticity">func (s *Shape) SetElasticity(elasticity float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetFilter">func (s *Shape) SetFilter(filter ShapeFilter)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetFriction">func (s *Shape) SetFriction(friction float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetMass">func (s *Shape) SetMass(mass float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetSensor">func (s *Shape) SetSensor(sensor bool)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetSurfaceVelocity">func (s *Shape) SetSurfaceVelocity(surfaceVelocity Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SetUserData">func (s *Shape) SetUserData(i interface{})</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.ShapesCollide">func (a *Shape) ShapesCollide(b *Shape) ContactPointSet</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Space">func (s *Shape) Space() *Space</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.SurfaceVelocity">func (s *Shape) SurfaceVelocity() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.Update">func (s *Shape) Update(transform Transform) BB</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Shape.UserData">func (s *Shape) UserData() interface{}</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ShapeFilter">type ShapeFilter</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ShapeFilterNew">func ShapeFilterNew(group Group, categories, mask Bitmask) ShapeFilter</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SimpleMotorJoint">type SimpleMotorJoint</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SlideJoint">type SlideJoint</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space">type Space</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceNew">func SpaceNew() *Space</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.AddBody">func (s *Space) AddBody(body *Body) *Body</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.AddCollisionHandler">func (s *Space) AddCollisionHandler(a, b CollisionType, handler *CollisionHandler)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.AddConstraint">func (s *Space) AddConstraint(constraint *Constraint) *Constraint</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.AddDefaultCollisionHandler">func (s *Space) AddDefaultCollisionHandler()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.AddPostStepCallback">func (s *Space) AddPostStepCallback(f func())</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.AddShape">func (s *Space) AddShape(shape *Shape) *Shape</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.AddWildcardHandler">func (s *Space) AddWildcardHandler(t CollisionType, handler *CollisionHandler)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.BBQuery">func (s *Space) BBQuery(bb BB, filter ShapeFilter, f SpaceBBQueryFunc, data interface{})</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.CollisionBias">func (s *Space) CollisionBias() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.CollisionPersistence">func (s *Space) CollisionPersistence() Timestamp</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.CollisionSlop">func (s *Space) CollisionSlop() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.ContainsBody">func (s *Space) ContainsBody(body *Body) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.ContainsConstraint">func (s *Space) ContainsConstraint(constraint *Constraint) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.ContainsShape">func (s *Space) ContainsShape(shape *Shape) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.CurrentTimeStep">func (s *Space) CurrentTimeStep() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.Damping">func (s *Space) Damping() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.DebugDraw">func (s *Space) DebugDraw(options *SpaceDebugDrawOptions)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.EachBody">func (s *Space) EachBody(space *Space, f func(b *Body))</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.EachConstraint">func (s *Space) EachConstraint(space *Space, f func(c *Constraint))</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.EachShape">func (s *Space) EachShape(space *Space, f func(s *Shape))</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.Free">func (s *Space) Free()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.Gravity">func (s *Space) Gravity() Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.IdleSpeedThreshold">func (s *Space) IdleSpeedThreshold() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.IsLocked">func (s *Space) IsLocked() bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.Iterations">func (s *Space) Iterations() int</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.PointQuery">func (s *Space) PointQuery(point Vect, maxDistance float64, filter ShapeFilter, f SpacePointQueryFunc, data interface{})</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.PointQueryNearest">func (s *Space) PointQueryNearest(point Vect, maxDistance float64, filter ShapeFilter) (shape *Shape, out *PointQueryInfo)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.ReindexShape">func (s *Space) ReindexShape(shape *Shape)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.ReindexShapesForBody">func (s *Space) ReindexShapesForBody(body *Body)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.ReindexStatic">func (s *Space) ReindexStatic()</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.RemoveBody">func (s *Space) RemoveBody(body *Body)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.RemoveConstraint">func (s *Space) RemoveConstraint(constraint *Constraint)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.RemoveShape">func (s *Space) RemoveShape(shape *Shape)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SegmentQuery">func (s *Space) SegmentQuery(start, end Vect, radius float64, filter ShapeFilter, f SpaceSegmentQueryFunc, data interface{})</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SegmentQueryFirst">func (s *Space) SegmentQueryFirst(start, end Vect, radius float64, filter ShapeFilter) (shape *Shape, out *SegmentQueryInfo)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SetCollisionBias">func (s *Space) SetCollisionBias(collisionBias float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SetCollisionPersistence">func (s *Space) SetCollisionPersistence(collisionPersistence Timestamp)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SetCollisionSlop">func (s *Space) SetCollisionSlop(collisionSlop float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SetDamping">func (s *Space) SetDamping(damping float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SetGravity">func (s *Space) SetGravity(gravity Vect)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SetIdleSpeedThreshold">func (s *Space) SetIdleSpeedThreshold(idleSpeedThreshold float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SetIterations">func (s *Space) SetIterations(iterations int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SetSleepTimeThreshold">func (s *Space) SetSleepTimeThreshold(sleepTimeThreshold float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SetUserData">func (s *Space) SetUserData(i interface{})</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.ShapeQuery">func (s *Space) ShapeQuery(shape *Shape, f SpaceShapeQueryFunc, data interface{}) bool</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.SleepTimeThreshold">func (s *Space) SleepTimeThreshold() float64</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.StaticBody">func (s *Space) StaticBody() *Body</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.Step">func (s *Space) Step(dt float64)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.UseSpatialHash">func (s *Space) UseSpatialHash(dim float64, count int)</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Space.UserData">func (s *Space) UserData() interface{}</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceArbiterApplyImpulseFunc">type SpaceArbiterApplyImpulseFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceBBQueryFunc">type SpaceBBQueryFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceDebugColor">type SpaceDebugColor</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceDebugDrawCircleImpl">type SpaceDebugDrawCircleImpl</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceDebugDrawColorForShapeImpl">type SpaceDebugDrawColorForShapeImpl</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceDebugDrawDotImpl">type SpaceDebugDrawDotImpl</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceDebugDrawFatSegmentImpl">type SpaceDebugDrawFatSegmentImpl</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceDebugDrawFlags">type SpaceDebugDrawFlags</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceDebugDrawOptions">type SpaceDebugDrawOptions</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceDebugDrawPolygonImpl">type SpaceDebugDrawPolygonImpl</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceDebugDrawSegmentImpl">type SpaceDebugDrawSegmentImpl</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpacePointQueryFunc">type SpacePointQueryFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceSegmentQueryFunc">type SpaceSegmentQueryFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#SpaceShapeQueryFunc">type SpaceShapeQueryFunc</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Timestamp">type Timestamp</a></span></span>
			
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform">type Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TransformAxialScale">func TransformAxialScale(axis, pivot Vect, scale float64) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TransformBoneScale">func TransformBoneScale(v0, v1 Vect) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TransformNew">func TransformNew(a, b, c, d, tx, ty float64) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TransformNewTranspose">func TransformNewTranspose(a, c, tx, b, d, ty float64) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TransformOrtho">func TransformOrtho(bb BB) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TransformRigid">func TransformRigid(translate Vect, radians float64) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TransformRotate">func TransformRotate(radians float64) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TransformScale">func TransformScale(scaleX, scaleY float64) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#TransformTranslate">func TransformTranslate(translate Vect) Transform</a></span></span>
			
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.BB">func (t Transform) BB(bb BB) BB</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Inverse">func (t Transform) Inverse() Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Mult">func (t1 Transform) Mult(t2 Transform) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Point">func (t Transform) Point(p Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.RigidInverse">func (t Transform) RigidInverse() Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Vect">func (t Transform) Vect(v Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.Wrap">func (outer Transform) Wrap(inner Transform) Transform</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Transform.WrapInverse">func (outer Transform) WrapInverse(inner Transform) Transform</a></span></span>
			
		
			<span class="item"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vect">type Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#CentroidForPoly">func CentroidForPoly(verts []Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#ClosetPointOnSegment">func ClosetPointOnSegment(p, a, b Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#V">func V(x, y float64) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vadd">func Vadd(v1, v2 Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vdot">func Vdot(v1, v2 Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vforangle">func Vforangle(a float64) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vlerp">func Vlerp(v1, v2 Vect, t float64) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vlerpconst">func Vlerpconst(v1, v2 Vect, d float64) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vmult">func Vmult(v Vect, s float64) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vneg">func Vneg(v Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vnormalize">func Vnormalize(v Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vperp">func Vperp(v Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vproject">func Vproject(v1, v2 Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vrotate">func Vrotate(v1, v2 Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vrperp">func Vrperp(v Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vslerp">func Vslerp(v1, v2 Vect, t float64) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vslerpconst">func Vslerpconst(v1, v2 Vect, a float64) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vsub">func Vsub(v1, v2 Vect) Vect</a></span></span>
			
				<span class="item indent"><span class="biohazard">☣</span>&nbsp;&nbsp;<span class="content"><a href="#Vunrotate">func Vunrotate(v1, v2 Vect) Vect</a></span></span>
			
			
		
	</span>
</span>




<h1 id="constants" class="hdr pkg hdr-constants"><a href="#constants" title="permalink">»</a>&nbsp;Constants <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg constants">
	
		<pre>const (
	// Value for cpShape.group signifying that a shape is in no group.
	NO_GROUP	= C.CP_NO_GROUP

	// Value for cpShape.layers signifying that a shape is in every layer.
	ALL_CATEGORIES	= C.CP_ALL_CATEGORIES

	// cpCollisionType value internally reserved for hashing wildcard handlers.
	WILDCARD_COLLISION_TYPE	= C.CP_WILDCARD_COLLISION_TYPE
)</pre>
		<p></p>
	
		<pre>const (
	MAX_CONTACTS_PER_ARBITER = C.CP_MAX_CONTACTS_PER_ARBITER
)</pre>
		<p></p>
	
		<pre>const (
	BODY_TYPE_DYNAMIC	BodyType	= C.CP_BODY_TYPE_DYNAMIC
	BODY_TYPE_KINEMATIC	BodyType	= C.CP_BODY_TYPE_KINEMATIC
	BODY_TYPE_STATIC	BodyType	= C.CP_BODY_TYPE_STATIC
)</pre>
		<p></p>
	
		<pre>const (
	SPACE_DEBUG_DRAW_SHAPES			SpaceDebugDrawFlags	= C.CP_SPACE_DEBUG_DRAW_SHAPES
	SPACE_DEBUG_DRAW_CONSTRAINTS		SpaceDebugDrawFlags	= C.CP_SPACE_DEBUG_DRAW_CONSTRAINTS
	SPACE_DEBUG_DRAW_COLLISION_POINTS	SpaceDebugDrawFlags	= C.CP_SPACE_DEBUG_DRAW_COLLISION_POINTS
)</pre>
		<p></p>
	
</span>





<h1 id="variables" class="hdr pkg hdr-variables"><a href="#variables" title="permalink">»</a>&nbsp;Variables <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg variables">
	
		<pre>var (
	SHAPE_FILTER_ALL	= ShapeFilter{NO_GROUP, ALL_CATEGORIES, ALL_CATEGORIES}
	SHAPE_FILTER_NONE	= ShapeFilter{NO_GROUP, 0 &amp;^ ALL_CATEGORIES, 0 &amp;^ ALL_CATEGORIES}
)</pre>
		<p></p>
	
		<pre>var (
	TransformIdentity = Transform{1, 0, 0, 1, 0, 0}
)</pre>
		<p>Identity transform matrix.
</p>
	
		<pre>var (
	// Version string.
	VersionString = C.GoString(C.cpVersionString)
)</pre>
		<p></p>
	
		<pre>var (
	// The zero vector.
	Vzero = Vect{0, 0}
)</pre>
		<p></p>
	
</span>





	<h1 id="AreaForCircle" class="hdr pkg hdr-function"><a href="#AreaForCircle" title="permalink">»</a>&nbsp;func AreaForCircle(r1, r2 float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func AreaForCircle(r1, r2 float64) float64</pre>
		<p>
Calculate area of a hollow circle.
</p>
<p>
r1 and  r2 are the inner and outer diameters. A solid circle has an inner diameter of 0.
</p>

	</span>

	<h1 id="AreaForPoly" class="hdr pkg hdr-function"><a href="#AreaForPoly" title="permalink">»</a>&nbsp;func AreaForPoly(verts []Vect, radius float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func AreaForPoly(verts []Vect, radius float64) float64</pre>
		<p>
Calculate the signed area of a polygon. A Clockwise winding gives positive
area.
</p>
<p>
This is probably backwards from what you expect, but matches Chipmunk&#39;s the
winding for poly shapes.
</p>

	</span>

	<h1 id="AreaForSegment" class="hdr pkg hdr-function"><a href="#AreaForSegment" title="permalink">»</a>&nbsp;func AreaForSegment(a, b Vect, radius float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func AreaForSegment(a, b Vect, radius float64) float64</pre>
		<p>
Calculate the area of a fattened (capsule shaped) line segment.
</p>

	</span>

	<h1 id="BodyUpdatePosition" class="hdr pkg hdr-function"><a href="#BodyUpdatePosition" title="permalink">»</a>&nbsp;func BodyUpdatePosition(b *Body, dt float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func BodyUpdatePosition(b *Body, dt float64)</pre>
		<p>
Default position integration function.
</p>

	</span>

	<h1 id="BodyUpdateVelocity" class="hdr pkg hdr-function"><a href="#BodyUpdateVelocity" title="permalink">»</a>&nbsp;func BodyUpdateVelocity(b *Body, gravity Vect, damping, dt float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func BodyUpdateVelocity(b *Body, gravity Vect, damping, dt float64)</pre>
		<p>
Default velocity integration function..
</p>

	</span>

	<h1 id="ConvexHull" class="hdr pkg hdr-function"><a href="#ConvexHull" title="permalink">»</a>&nbsp;func ConvexHull(count int, verts, result *Vect, first *int, tol float64) int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func ConvexHull(count int, verts, result *Vect, first *int, tol float64) int</pre>
		<p>
Calculate the convex hull of a given set of points. Returns the count of points in the hull.
</p>
<pre>result must be a pointer to a  cpVect array with at least  count elements.
If  verts ==  result, then  verts will be reduced inplace.

first is an optional pointer to an integer to store where the first vertex
in the hull came from (i.e. verts[first] == result[0])

tol is the allowed amount to shrink the hull when simplifying it. A
tolerance of 0.0 creates an exact hull.
</pre>

	</span>

	<h1 id="Fabs" class="hdr pkg hdr-function"><a href="#Fabs" title="permalink">»</a>&nbsp;func Fabs(f float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Fabs(f float64) float64</pre>
		<p>
Return the absolute value of a cpFloat.
</p>

	</span>

	<h1 id="Fclamp" class="hdr pkg hdr-function"><a href="#Fclamp" title="permalink">»</a>&nbsp;func Fclamp(f, min, max float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Fclamp(f, min, max float64) float64</pre>
		<p>
Clamp f to be between min and max.
</p>

	</span>

	<h1 id="Fclamp01" class="hdr pkg hdr-function"><a href="#Fclamp01" title="permalink">»</a>&nbsp;func Fclamp01(f float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Fclamp01(f float64) float64</pre>
		<p>
Clamp f to be between 0 and 1.
</p>

	</span>

	<h1 id="Flerp" class="hdr pkg hdr-function"><a href="#Flerp" title="permalink">»</a>&nbsp;func Flerp(f1, f2, t float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Flerp(f1, f2, t float64) float64</pre>
		<p>
Linearly interpolate (or extrapolate) between f1 and f2 by t percent.
</p>

	</span>

	<h1 id="Flerpconst" class="hdr pkg hdr-function"><a href="#Flerpconst" title="permalink">»</a>&nbsp;func Flerpconst(f1, f2, d float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Flerpconst(f1, f2, d float64) float64</pre>
		<p>
Linearly interpolate from f1 to f2 by no more than d.
</p>

	</span>

	<h1 id="Fmax" class="hdr pkg hdr-function"><a href="#Fmax" title="permalink">»</a>&nbsp;func Fmax(a, b float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Fmax(a, b float64) float64</pre>
		<p>
Return the max of two cpFloats.
</p>

	</span>

	<h1 id="Fmin" class="hdr pkg hdr-function"><a href="#Fmin" title="permalink">»</a>&nbsp;func Fmin(a, b float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Fmin(a, b float64) float64</pre>
		<p>
Return the min of two cpFloats.
</p>

	</span>

	<h1 id="MomentForBox" class="hdr pkg hdr-function"><a href="#MomentForBox" title="permalink">»</a>&nbsp;func MomentForBox(m, width, height float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func MomentForBox(m, width, height float64) float64</pre>
		<p>
Calculate the moment of inertia for a solid box.
</p>

	</span>

	<h1 id="MomentForBox2" class="hdr pkg hdr-function"><a href="#MomentForBox2" title="permalink">»</a>&nbsp;func MomentForBox2(m float64, box BB) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func MomentForBox2(m float64, box BB) float64</pre>
		<p>
Calculate the moment of inertia for a solid box.
</p>

	</span>

	<h1 id="MomentForCircle" class="hdr pkg hdr-function"><a href="#MomentForCircle" title="permalink">»</a>&nbsp;func MomentForCircle(m, r1, r2 float64, offset Vect) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func MomentForCircle(m, r1, r2 float64, offset Vect) float64</pre>
		<p>
Calculate the moment of inertia for a circle.
</p>
<p>
r1 and r2 are the inner and outer diameters. A solid circle has an inner diameter of 0.
</p>

	</span>

	<h1 id="MomentForPoly" class="hdr pkg hdr-function"><a href="#MomentForPoly" title="permalink">»</a>&nbsp;func MomentForPoly(m float64, verts []Vect, offset Vect, radius float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func MomentForPoly(m float64, verts []Vect, offset Vect, radius float64) float64</pre>
		<p>
Calculate the moment of inertia for a solid polygon shape assuming it&#39;s
center of gravity is at it&#39;s centroid. The offset is added to each vertex.
</p>

	</span>

	<h1 id="MomentForSegment" class="hdr pkg hdr-function"><a href="#MomentForSegment" title="permalink">»</a>&nbsp;func MomentForSegment(m float64, a, b Vect, radius float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func MomentForSegment(m float64, a, b Vect, radius float64) float64</pre>
		<p>
Calculate the moment of inertia for a line segment.
</p>
<p>
Beveling radius is not supported.
</p>

	</span>

	<h1 id="Vcross" class="hdr pkg hdr-function"><a href="#Vcross" title="permalink">»</a>&nbsp;func Vcross(v1, v2 Vect) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Vcross(v1, v2 Vect) float64</pre>
		<p>
2D vector cross product analog.
</p>
<p>
The cross product of 2D vectors results in a 3D vector with only a z
component.
</p>
<p>
This function returns the magnitude of the z value.
</p>

	</span>

	<h1 id="Vdist" class="hdr pkg hdr-function"><a href="#Vdist" title="permalink">»</a>&nbsp;func Vdist(v1, v2 Vect) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Vdist(v1, v2 Vect) float64</pre>
		<p>
Returns the distance between v1 and v2.
</p>

	</span>

	<h1 id="Vdistsq" class="hdr pkg hdr-function"><a href="#Vdistsq" title="permalink">»</a>&nbsp;func Vdistsq(v1, v2 Vect) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Vdistsq(v1, v2 Vect) float64</pre>
		<p>
Returns the squared distance between v1 and v2. Faster than cpvdist() when you only need to compare distances.
</p>

	</span>

	<h1 id="Veql" class="hdr pkg hdr-function"><a href="#Veql" title="permalink">»</a>&nbsp;func Veql(v1, v2 Vect) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Veql(v1, v2 Vect) bool</pre>
		<p>
Check if two vectors are equal. (Be careful when comparing floating point numbers!)
</p>

	</span>

	<h1 id="Vlength" class="hdr pkg hdr-function"><a href="#Vlength" title="permalink">»</a>&nbsp;func Vlength(v Vect) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Vlength(v Vect) float64</pre>
		<p>
Returns the length of v.
</p>

	</span>

	<h1 id="Vlengthsq" class="hdr pkg hdr-function"><a href="#Vlengthsq" title="permalink">»</a>&nbsp;func Vlengthsq(v Vect) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Vlengthsq(v Vect) float64</pre>
		<p>
Returns the squared length of v. Faster than cpvlength() when you only need
to compare lengths.
</p>

	</span>

	<h1 id="Vnear" class="hdr pkg hdr-function"><a href="#Vnear" title="permalink">»</a>&nbsp;func Vnear(v1, v2 Vect, dist float64) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Vnear(v1, v2 Vect, dist float64) bool</pre>
		<p>
Returns true if the distance between v1 and v2 is less than dist.
</p>

	</span>

	<h1 id="Vtoangle" class="hdr pkg hdr-function"><a href="#Vtoangle" title="permalink">»</a>&nbsp;func Vtoangle(v Vect) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
		<pre>func Vtoangle(v Vect) float64</pre>
		<p>
Returns the angular direction v is pointing in (in radians).
</p>

	</span>





	
	<h1 id="Arbiter" class="hdr pkg hdr-type"><a href="#Arbiter" title="permalink">»</a>&nbsp;type Arbiter <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Arbiter struct {
	// contains filtered or unexported fields
}</pre>
		<p>
The Arbiter struct controls pairs of colliding shapes.
</p>
<p>
They are also used in conjuction with collision handler callbacks allowing
you to retrieve information on the collision and control it.
</p>

	</span>

	
	

	
	
		
		<h1 id="Arbiter.CallWildcardBeginA" class="hdr pkg hdr-method"><a href="#Arbiter.CallWildcardBeginA" title="permalink">»</a>&nbsp;func (a *Arbiter) CallWildcardBeginA(space *Space) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) CallWildcardBeginA(space *Space) bool</pre>
			
		</span>
	
		
		<h1 id="Arbiter.CallWildcardBeginB" class="hdr pkg hdr-method"><a href="#Arbiter.CallWildcardBeginB" title="permalink">»</a>&nbsp;func (a *Arbiter) CallWildcardBeginB(space *Space) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) CallWildcardBeginB(space *Space) bool</pre>
			
		</span>
	
		
		<h1 id="Arbiter.CallWildcardPostSolveA" class="hdr pkg hdr-method"><a href="#Arbiter.CallWildcardPostSolveA" title="permalink">»</a>&nbsp;func (a *Arbiter) CallWildcardPostSolveA(space *Space) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) CallWildcardPostSolveA(space *Space)</pre>
			
		</span>
	
		
		<h1 id="Arbiter.CallWildcardPostSolveB" class="hdr pkg hdr-method"><a href="#Arbiter.CallWildcardPostSolveB" title="permalink">»</a>&nbsp;func (a *Arbiter) CallWildcardPostSolveB(space *Space) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) CallWildcardPostSolveB(space *Space)</pre>
			
		</span>
	
		
		<h1 id="Arbiter.CallWildcardPreSolveA" class="hdr pkg hdr-method"><a href="#Arbiter.CallWildcardPreSolveA" title="permalink">»</a>&nbsp;func (a *Arbiter) CallWildcardPreSolveA(space *Space) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) CallWildcardPreSolveA(space *Space) bool</pre>
			
		</span>
	
		
		<h1 id="Arbiter.CallWildcardPreSolveB" class="hdr pkg hdr-method"><a href="#Arbiter.CallWildcardPreSolveB" title="permalink">»</a>&nbsp;func (a *Arbiter) CallWildcardPreSolveB(space *Space) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) CallWildcardPreSolveB(space *Space) bool</pre>
			
		</span>
	
		
		<h1 id="Arbiter.CallWildcardSeparateA" class="hdr pkg hdr-method"><a href="#Arbiter.CallWildcardSeparateA" title="permalink">»</a>&nbsp;func (a *Arbiter) CallWildcardSeparateA(space *Space) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) CallWildcardSeparateA(space *Space)</pre>
			
		</span>
	
		
		<h1 id="Arbiter.CallWildcardSeparateB" class="hdr pkg hdr-method"><a href="#Arbiter.CallWildcardSeparateB" title="permalink">»</a>&nbsp;func (a *Arbiter) CallWildcardSeparateB(space *Space) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) CallWildcardSeparateB(space *Space)</pre>
			
		</span>
	
		
		<h1 id="Arbiter.ContactPointSet" class="hdr pkg hdr-method"><a href="#Arbiter.ContactPointSet" title="permalink">»</a>&nbsp;func (a *Arbiter) ContactPointSet() *ContactPointSet <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) ContactPointSet() *ContactPointSet</pre>
			<p>
Return a contact set from an arbiter.
</p>

		</span>
	
		
		<h1 id="Arbiter.Count" class="hdr pkg hdr-method"><a href="#Arbiter.Count" title="permalink">»</a>&nbsp;func (a *Arbiter) Count() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) Count() int</pre>
			<p>
Get the number of contact points for this arbiter.
</p>

		</span>
	
		
		<h1 id="Arbiter.Depth" class="hdr pkg hdr-method"><a href="#Arbiter.Depth" title="permalink">»</a>&nbsp;func (a *Arbiter) Depth(i int) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) Depth(i int) float64</pre>
			<p>
Get the depth of the  ith contact point.
</p>

		</span>
	
		
		<h1 id="Arbiter.Friction" class="hdr pkg hdr-method"><a href="#Arbiter.Friction" title="permalink">»</a>&nbsp;func (a *Arbiter) Friction() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) Friction() float64</pre>
			
		</span>
	
		
		<h1 id="Arbiter.GetNormal" class="hdr pkg hdr-method"><a href="#Arbiter.GetNormal" title="permalink">»</a>&nbsp;func (a *Arbiter) GetNormal() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) GetNormal() Vect</pre>
			<p>
Get the normal of the collision.
</p>

		</span>
	
		
		<h1 id="Arbiter.Ignore" class="hdr pkg hdr-method"><a href="#Arbiter.Ignore" title="permalink">»</a>&nbsp;func (a *Arbiter) Ignore() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) Ignore() bool</pre>
			
		</span>
	
		
		<h1 id="Arbiter.IsFirstContact" class="hdr pkg hdr-method"><a href="#Arbiter.IsFirstContact" title="permalink">»</a>&nbsp;func (a *Arbiter) IsFirstContact() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) IsFirstContact() bool</pre>
			<p>
Returns true if this is the first step a pair of objects started colliding.
</p>

		</span>
	
		
		<h1 id="Arbiter.IsRemoval" class="hdr pkg hdr-method"><a href="#Arbiter.IsRemoval" title="permalink">»</a>&nbsp;func (a *Arbiter) IsRemoval() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) IsRemoval() bool</pre>
			<p>
Returns true if in separate callback due to a shape being removed from the space.
</p>

		</span>
	
		
		<h1 id="Arbiter.Point1" class="hdr pkg hdr-method"><a href="#Arbiter.Point1" title="permalink">»</a>&nbsp;func (a *Arbiter) Point1(i int) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) Point1(i int) Vect</pre>
			<p>
Get the position of the  ith contact point on the surface of the first shape.
</p>

		</span>
	
		
		<h1 id="Arbiter.Point2" class="hdr pkg hdr-method"><a href="#Arbiter.Point2" title="permalink">»</a>&nbsp;func (a *Arbiter) Point2(i int) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) Point2(i int) Vect</pre>
			<p>
Get the position of the  ith contact point on the surface of the second shape.
</p>

		</span>
	
		
		<h1 id="Arbiter.Restitution" class="hdr pkg hdr-method"><a href="#Arbiter.Restitution" title="permalink">»</a>&nbsp;func (a *Arbiter) Restitution() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) Restitution() float64</pre>
			
		</span>
	
		
		<h1 id="Arbiter.SetContactPointSet" class="hdr pkg hdr-method"><a href="#Arbiter.SetContactPointSet" title="permalink">»</a>&nbsp;func (a *Arbiter) SetContactPointSet(set *ContactPointSet) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) SetContactPointSet(set *ContactPointSet)</pre>
			<p>
Replace the contact point set for an arbiter.
</p>
<p>
This can be a very powerful feature, but use it with caution!
</p>

		</span>
	
		
		<h1 id="Arbiter.SetFriction" class="hdr pkg hdr-method"><a href="#Arbiter.SetFriction" title="permalink">»</a>&nbsp;func (a *Arbiter) SetFriction(friction float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) SetFriction(friction float64)</pre>
			
		</span>
	
		
		<h1 id="Arbiter.SetRestitution" class="hdr pkg hdr-method"><a href="#Arbiter.SetRestitution" title="permalink">»</a>&nbsp;func (a *Arbiter) SetRestitution(restitution float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) SetRestitution(restitution float64)</pre>
			
		</span>
	
		
		<h1 id="Arbiter.SetSurfaceVelocity" class="hdr pkg hdr-method"><a href="#Arbiter.SetSurfaceVelocity" title="permalink">»</a>&nbsp;func (a *Arbiter) SetSurfaceVelocity(vr Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) SetSurfaceVelocity(vr Vect)</pre>
			<p>
Override the relative surface velocity of the two shapes in contact.
</p>
<p>
By default this is calculated to be the difference of the two surface
velocities clamped to the tangent plane.
</p>

		</span>
	
		
		<h1 id="Arbiter.SetUserData" class="hdr pkg hdr-method"><a href="#Arbiter.SetUserData" title="permalink">»</a>&nbsp;func (a *Arbiter) SetUserData(i interface{}) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) SetUserData(i interface{})</pre>
			
		</span>
	
		
		<h1 id="Arbiter.Shapes" class="hdr pkg hdr-method"><a href="#Arbiter.Shapes" title="permalink">»</a>&nbsp;func (arb *Arbiter) Shapes() (a, b *Shape) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (arb *Arbiter) Shapes() (a, b *Shape)</pre>
			<p>
Return the colliding shapes involved for this arbiter.
</p>
<p>
The order of their cpSpace.collision_type values will match
the order set when the collision handler was registered.
</p>

		</span>
	
		
		<h1 id="Arbiter.SurfaceVelocity" class="hdr pkg hdr-method"><a href="#Arbiter.SurfaceVelocity" title="permalink">»</a>&nbsp;func (a *Arbiter) SurfaceVelocity() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) SurfaceVelocity() Vect</pre>
			<p>
Get the relative surface velocity of the two shapes in contact.
</p>

		</span>
	
		
		<h1 id="Arbiter.TotalImpulse" class="hdr pkg hdr-method"><a href="#Arbiter.TotalImpulse" title="permalink">»</a>&nbsp;func (a *Arbiter) TotalImpulse() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) TotalImpulse() Vect</pre>
			<p>
Calculate the total impulse including the friction that was applied by this arbiter.
This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback.
</p>

		</span>
	
		
		<h1 id="Arbiter.TotalKE" class="hdr pkg hdr-method"><a href="#Arbiter.TotalKE" title="permalink">»</a>&nbsp;func (a *Arbiter) TotalKE() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) TotalKE() float64</pre>
			<p>
Calculate the amount of energy lost in a collision including static, but not dynamic friction.
This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback.
</p>

		</span>
	
		
		<h1 id="Arbiter.UserData" class="hdr pkg hdr-method"><a href="#Arbiter.UserData" title="permalink">»</a>&nbsp;func (a *Arbiter) UserData() interface{} <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Arbiter) UserData() interface{}</pre>
			
		</span>
	

	
	<h1 id="Array" class="hdr pkg hdr-type"><a href="#Array" title="permalink">»</a>&nbsp;type Array <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Array C.cpArray</pre>
		
	</span>

	
	

	
	

	
	<h1 id="BB" class="hdr pkg hdr-type"><a href="#BB" title="permalink">»</a>&nbsp;type BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type BB C.cpBB</pre>
		<p>
Chipmunk&#39;s axis-aligned 2D bounding box type. (left, bottom, right, top)
</p>

	</span>

	
	
		<h1 id="BBNew" class="hdr pkg hdr-function"><a href="#BBNew" title="permalink">»</a>&nbsp;func BBNew(l, b, r, t float64) BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func BBNew(l, b, r, t float64) BB</pre>
			<p>
Convenience constructor for BB structs.
</p>

		</span>
	
		<h1 id="BBNewForCircle" class="hdr pkg hdr-function"><a href="#BBNewForCircle" title="permalink">»</a>&nbsp;func BBNewForCircle(p Vect, r float64) BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func BBNewForCircle(p Vect, r float64) BB</pre>
			<p>
Constructs a BB for a circle with the given position and radius.
</p>

		</span>
	
		<h1 id="BBNewForExtents" class="hdr pkg hdr-function"><a href="#BBNewForExtents" title="permalink">»</a>&nbsp;func BBNewForExtents(c Vect, hw, hh float64) BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func BBNewForExtents(c Vect, hw, hh float64) BB</pre>
			<p>
Constructs a BB centered on a point with the given extents (half sizes).
</p>

		</span>
	

	
	
		
		<h1 id="BB.Area" class="hdr pkg hdr-method"><a href="#BB.Area" title="permalink">»</a>&nbsp;func (bb BB) Area() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bb BB) Area() float64</pre>
			<p>
Returns the area of the bounding box.
</p>

		</span>
	
		
		<h1 id="BB.Center" class="hdr pkg hdr-method"><a href="#BB.Center" title="permalink">»</a>&nbsp;func (bb BB) Center() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bb BB) Center() Vect</pre>
			<p>
Returns the center of a bounding box.
</p>

		</span>
	
		
		<h1 id="BB.ClampVect" class="hdr pkg hdr-method"><a href="#BB.ClampVect" title="permalink">»</a>&nbsp;func (bb BB) ClampVect(v Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bb BB) ClampVect(v Vect) Vect</pre>
			<p>
Clamp a vector to a bounding box.
</p>

		</span>
	
		
		<h1 id="BB.ContainsBB" class="hdr pkg hdr-method"><a href="#BB.ContainsBB" title="permalink">»</a>&nbsp;func (bb BB) ContainsBB(other BB) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bb BB) ContainsBB(other BB) bool</pre>
			<p>
Returns true if  other lies completely within bb.
</p>

		</span>
	
		
		<h1 id="BB.ContainsVect" class="hdr pkg hdr-method"><a href="#BB.ContainsVect" title="permalink">»</a>&nbsp;func (bb BB) ContainsVect(v Vect) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bb BB) ContainsVect(v Vect) bool</pre>
			<p>
Returns true if bb contains v.
</p>

		</span>
	
		
		<h1 id="BB.Expand" class="hdr pkg hdr-method"><a href="#BB.Expand" title="permalink">»</a>&nbsp;func (bb BB) Expand(v Vect) BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bb BB) Expand(v Vect) BB</pre>
			<p>
Returns a bounding box that holds both bb and v.
</p>

		</span>
	
		
		<h1 id="BB.Intersects" class="hdr pkg hdr-method"><a href="#BB.Intersects" title="permalink">»</a>&nbsp;func (a BB) Intersects(b BB) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a BB) Intersects(b BB) bool</pre>
			<p>
Returns true if a and b intersect.
</p>

		</span>
	
		
		<h1 id="BB.IntersectsSegment" class="hdr pkg hdr-method"><a href="#BB.IntersectsSegment" title="permalink">»</a>&nbsp;func (bb BB) IntersectsSegment(a, b Vect) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bb BB) IntersectsSegment(a, b Vect) bool</pre>
			<p>
Return true if the bounding box intersects the line segment with ends  a and  b.
</p>

		</span>
	
		
		<h1 id="BB.Merge" class="hdr pkg hdr-method"><a href="#BB.Merge" title="permalink">»</a>&nbsp;func (a BB) Merge(b BB) BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a BB) Merge(b BB) BB</pre>
			<p>
Returns a bounding box that holds both bounding boxes.
</p>

		</span>
	
		
		<h1 id="BB.MergedArea" class="hdr pkg hdr-method"><a href="#BB.MergedArea" title="permalink">»</a>&nbsp;func (a BB) MergedArea(b BB) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a BB) MergedArea(b BB) float64</pre>
			<p>
Merges a and b and returns the area of the merged bounding box.
</p>

		</span>
	
		
		<h1 id="BB.SegmentQuery" class="hdr pkg hdr-method"><a href="#BB.SegmentQuery" title="permalink">»</a>&nbsp;func (bb BB) SegmentQuery(a, b Vect) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bb BB) SegmentQuery(a, b Vect) float64</pre>
			<p>
Returns the fraction along the segment query the BB is hit. Returns
INFINITY if it doesn&#39;t hit.
</p>

		</span>
	
		
		<h1 id="BB.WrapVect" class="hdr pkg hdr-method"><a href="#BB.WrapVect" title="permalink">»</a>&nbsp;func (bb BB) WrapVect(v Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bb BB) WrapVect(v Vect) Vect</pre>
			<p>
Wrap a vector to a bounding box.
</p>

		</span>
	

	
	<h1 id="Bitmask" class="hdr pkg hdr-type"><a href="#Bitmask" title="permalink">»</a>&nbsp;type Bitmask <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Bitmask C.cpBitmask</pre>
		<p>
Type used for cpShapeFilter category and mask.
</p>

	</span>

	
	

	
	

	
	<h1 id="Body" class="hdr pkg hdr-type"><a href="#Body" title="permalink">»</a>&nbsp;type Body <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Body struct {
	// contains filtered or unexported fields
}</pre>
		
	</span>

	
	
		<h1 id="BodyNew" class="hdr pkg hdr-function"><a href="#BodyNew" title="permalink">»</a>&nbsp;func BodyNew(mass, moment float64) *Body <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func BodyNew(mass, moment float64) *Body</pre>
			<p>
Allocate and initialize a Body.
</p>

		</span>
	
		<h1 id="BodyNewKinematic" class="hdr pkg hdr-function"><a href="#BodyNewKinematic" title="permalink">»</a>&nbsp;func BodyNewKinematic() *Body <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func BodyNewKinematic() *Body</pre>
			<p>
Allocate and initialize a Body, and set it as a kinematic body.
</p>

		</span>
	
		<h1 id="BodyNewStatic" class="hdr pkg hdr-function"><a href="#BodyNewStatic" title="permalink">»</a>&nbsp;func BodyNewStatic() *Body <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func BodyNewStatic() *Body</pre>
			<p>
Allocate and initialize a cpBody, and set it as a static body.
</p>

		</span>
	

	
	
		
		<h1 id="Body.Activate" class="hdr pkg hdr-method"><a href="#Body.Activate" title="permalink">»</a>&nbsp;func (b *Body) Activate() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Activate()</pre>
			<p>
Wake up a sleeping or idle body.
</p>

		</span>
	
		
		<h1 id="Body.ActivateStatic" class="hdr pkg hdr-method"><a href="#Body.ActivateStatic" title="permalink">»</a>&nbsp;func (b *Body) ActivateStatic(filter *Shape) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) ActivateStatic(filter *Shape)</pre>
			<p>
Wake up any sleeping or idle bodies touching a static body.
</p>

		</span>
	
		
		<h1 id="Body.Angle" class="hdr pkg hdr-method"><a href="#Body.Angle" title="permalink">»</a>&nbsp;func (b *Body) Angle() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Angle() float64</pre>
			<p>
Get the angle of the body.
</p>

		</span>
	
		
		<h1 id="Body.AngularVelocity" class="hdr pkg hdr-method"><a href="#Body.AngularVelocity" title="permalink">»</a>&nbsp;func (b *Body) AngularVelocity() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) AngularVelocity() float64</pre>
			<p>
Get the angular velocity of the body.
</p>

		</span>
	
		
		<h1 id="Body.ApplyForceAtLocalPoint" class="hdr pkg hdr-method"><a href="#Body.ApplyForceAtLocalPoint" title="permalink">»</a>&nbsp;func (b *Body) ApplyForceAtLocalPoint(force, point Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) ApplyForceAtLocalPoint(force, point Vect)</pre>
			<p>
Apply a force to a body. Both the force and point are expressed in body local coordinates.
</p>

		</span>
	
		
		<h1 id="Body.ApplyForceAtWorldPoint" class="hdr pkg hdr-method"><a href="#Body.ApplyForceAtWorldPoint" title="permalink">»</a>&nbsp;func (b *Body) ApplyForceAtWorldPoint(force, point Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) ApplyForceAtWorldPoint(force, point Vect)</pre>
			<p>
Apply a force to a body. Both the force and point are expressed in world coordinates.
</p>

		</span>
	
		
		<h1 id="Body.ApplyImpulseAtLocalPoint" class="hdr pkg hdr-method"><a href="#Body.ApplyImpulseAtLocalPoint" title="permalink">»</a>&nbsp;func (b *Body) ApplyImpulseAtLocalPoint(impulse, point Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) ApplyImpulseAtLocalPoint(impulse, point Vect)</pre>
			<p>
Apply an impulse to a body. Both the impulse and point are expressed in body local coordinates.
</p>

		</span>
	
		
		<h1 id="Body.ApplyImpulseAtWorldPoint" class="hdr pkg hdr-method"><a href="#Body.ApplyImpulseAtWorldPoint" title="permalink">»</a>&nbsp;func (b *Body) ApplyImpulseAtWorldPoint(impulse, point Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) ApplyImpulseAtWorldPoint(impulse, point Vect)</pre>
			<p>
Apply an impulse to a body. Both the impulse and point are expressed in world coordinates.
</p>

		</span>
	
		
		<h1 id="Body.BoxShapeNew" class="hdr pkg hdr-method"><a href="#Body.BoxShapeNew" title="permalink">»</a>&nbsp;func (b *Body) BoxShapeNew(width, height, radius float64) *Shape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) BoxShapeNew(width, height, radius float64) *Shape</pre>
			<p>
Allocate and initialize a box shaped polygon shape.
</p>

		</span>
	
		
		<h1 id="Body.BoxShapeNew2" class="hdr pkg hdr-method"><a href="#Body.BoxShapeNew2" title="permalink">»</a>&nbsp;func (b *Body) BoxShapeNew2(box BB, radius float64) *Shape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) BoxShapeNew2(box BB, radius float64) *Shape</pre>
			<p>
Allocate and initialize an offset box shaped polygon shape.
</p>

		</span>
	
		
		<h1 id="Body.CenterOfGravity" class="hdr pkg hdr-method"><a href="#Body.CenterOfGravity" title="permalink">»</a>&nbsp;func (b *Body) CenterOfGravity() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) CenterOfGravity() Vect</pre>
			<p>
Get the offset of the center of gravity in body local coordinates.
</p>

		</span>
	
		
		<h1 id="Body.CircleShapeNew" class="hdr pkg hdr-method"><a href="#Body.CircleShapeNew" title="permalink">»</a>&nbsp;func (b *Body) CircleShapeNew(radius float64, offset Vect) *Shape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) CircleShapeNew(radius float64, offset Vect) *Shape</pre>
			<p>
Allocate and initialize a circle shape.
</p>

		</span>
	
		
		<h1 id="Body.EachArbiter" class="hdr pkg hdr-method"><a href="#Body.EachArbiter" title="permalink">»</a>&nbsp;func (b *Body) EachArbiter(f func(b *Body, a *Arbiter)) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) EachArbiter(f func(b *Body, a *Arbiter))</pre>
			<p>
Returns a slice of all arbiters that are currently active on the body.
</p>

		</span>
	
		
		<h1 id="Body.EachConstraint" class="hdr pkg hdr-method"><a href="#Body.EachConstraint" title="permalink">»</a>&nbsp;func (b *Body) EachConstraint(f func(b *Body, c *Constraint)) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) EachConstraint(f func(b *Body, c *Constraint))</pre>
			<p>
Returns a slice of all contraints attached to the body and added to the space.
</p>

		</span>
	
		
		<h1 id="Body.EachShape" class="hdr pkg hdr-method"><a href="#Body.EachShape" title="permalink">»</a>&nbsp;func (b *Body) EachShape(f func(b *Body, s *Shape)) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) EachShape(f func(b *Body, s *Shape))</pre>
			<p>
Returns a slice of all shapes attached to the body and added to the space.
</p>

		</span>
	
		
		<h1 id="Body.Force" class="hdr pkg hdr-method"><a href="#Body.Force" title="permalink">»</a>&nbsp;func (b *Body) Force() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Force() Vect</pre>
			<p>
Get the force applied to the body for the next time step.
</p>

		</span>
	
		
		<h1 id="Body.Free" class="hdr pkg hdr-method"><a href="#Body.Free" title="permalink">»</a>&nbsp;func (b *Body) Free() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Free()</pre>
			<p>
Free is deprecated. Do not use it, it is no-op.
</p>

		</span>
	
		
		<h1 id="Body.IsSleeping" class="hdr pkg hdr-method"><a href="#Body.IsSleeping" title="permalink">»</a>&nbsp;func (b *Body) IsSleeping() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) IsSleeping() bool</pre>
			<p>
Returns true if the body is sleeping.
</p>

		</span>
	
		
		<h1 id="Body.KineticEnergy" class="hdr pkg hdr-method"><a href="#Body.KineticEnergy" title="permalink">»</a>&nbsp;func (b *Body) KineticEnergy() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) KineticEnergy() float64</pre>
			<p>
Get the amount of kinetic energy contained by the body.
</p>

		</span>
	
		
		<h1 id="Body.LocalToWorld" class="hdr pkg hdr-method"><a href="#Body.LocalToWorld" title="permalink">»</a>&nbsp;func (b *Body) LocalToWorld(point Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) LocalToWorld(point Vect) Vect</pre>
			<p>
Convert body relative/local coordinates to absolute/world coordinates.
</p>

		</span>
	
		
		<h1 id="Body.Mass" class="hdr pkg hdr-method"><a href="#Body.Mass" title="permalink">»</a>&nbsp;func (b *Body) Mass() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Mass() float64</pre>
			<p>
Get the mass of the body.
</p>

		</span>
	
		
		<h1 id="Body.Moment" class="hdr pkg hdr-method"><a href="#Body.Moment" title="permalink">»</a>&nbsp;func (b *Body) Moment() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Moment() float64</pre>
			<p>
Get the moment of inertia of the body.
</p>

		</span>
	
		
		<h1 id="Body.PolyShapeNew" class="hdr pkg hdr-method"><a href="#Body.PolyShapeNew" title="permalink">»</a>&nbsp;func (b *Body) PolyShapeNew(verts []Vect, transform Transform, radius float64) *Shape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) PolyShapeNew(verts []Vect, transform Transform, radius float64) *Shape</pre>
			<p>
Allocate and initialize a polygon shape with rounded corners.
</p>
<p>
A convex hull will be created from the vertexes.
</p>

		</span>
	
		
		<h1 id="Body.Position" class="hdr pkg hdr-method"><a href="#Body.Position" title="permalink">»</a>&nbsp;func (b *Body) Position() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Position() Vect</pre>
			<p>
Get the position of a body.
</p>

		</span>
	
		
		<h1 id="Body.Rotation" class="hdr pkg hdr-method"><a href="#Body.Rotation" title="permalink">»</a>&nbsp;func (b *Body) Rotation() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Rotation() Vect</pre>
			<p>
Get the rotation vector of the body. (The x basis vector of it&#39;s transform.)
</p>

		</span>
	
		
		<h1 id="Body.SegmentShapeNew" class="hdr pkg hdr-method"><a href="#Body.SegmentShapeNew" title="permalink">»</a>&nbsp;func (bd *Body) SegmentShapeNew(a, b Vect, radius float64) *Shape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (bd *Body) SegmentShapeNew(a, b Vect, radius float64) *Shape</pre>
			<p>
Allocate and initialize a segment shape.
</p>

		</span>
	
		
		<h1 id="Body.SetAngle" class="hdr pkg hdr-method"><a href="#Body.SetAngle" title="permalink">»</a>&nbsp;func (b *Body) SetAngle(a float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetAngle(a float64)</pre>
			<p>
Set the angle of a body.
</p>

		</span>
	
		
		<h1 id="Body.SetAngularVelocity" class="hdr pkg hdr-method"><a href="#Body.SetAngularVelocity" title="permalink">»</a>&nbsp;func (b *Body) SetAngularVelocity(angularVelocity float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetAngularVelocity(angularVelocity float64)</pre>
			<p>
Set the angular velocity of the body.
</p>

		</span>
	
		
		<h1 id="Body.SetCenterOfGravity" class="hdr pkg hdr-method"><a href="#Body.SetCenterOfGravity" title="permalink">»</a>&nbsp;func (b *Body) SetCenterOfGravity(cog Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetCenterOfGravity(cog Vect)</pre>
			<p>
Set the offset of the center of gravity in body local coordinates.
</p>

		</span>
	
		
		<h1 id="Body.SetForce" class="hdr pkg hdr-method"><a href="#Body.SetForce" title="permalink">»</a>&nbsp;func (b *Body) SetForce(force Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetForce(force Vect)</pre>
			<p>
Set the force applied to the body for the next time step.
</p>

		</span>
	
		
		<h1 id="Body.SetMass" class="hdr pkg hdr-method"><a href="#Body.SetMass" title="permalink">»</a>&nbsp;func (b *Body) SetMass(m float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetMass(m float64)</pre>
			<p>
Set the mass of the body.
</p>

		</span>
	
		
		<h1 id="Body.SetMoment" class="hdr pkg hdr-method"><a href="#Body.SetMoment" title="permalink">»</a>&nbsp;func (b *Body) SetMoment(i float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetMoment(i float64)</pre>
			<p>
Set the moment of inertia of the body.
</p>

		</span>
	
		
		<h1 id="Body.SetPosition" class="hdr pkg hdr-method"><a href="#Body.SetPosition" title="permalink">»</a>&nbsp;func (b *Body) SetPosition(pos Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetPosition(pos Vect)</pre>
			<p>
Set the position of the body.
</p>

		</span>
	
		
		<h1 id="Body.SetPositionUpdateFunc" class="hdr pkg hdr-method"><a href="#Body.SetPositionUpdateFunc" title="permalink">»</a>&nbsp;func (b *Body) SetPositionUpdateFunc(f BodyPositionFunc) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetPositionUpdateFunc(f BodyPositionFunc)</pre>
			<p>
Set the callback used to update a body&#39;s position.
</p>
<p>
NOTE: It&#39;s not generally recommended to override this.
</p>

		</span>
	
		
		<h1 id="Body.SetTorque" class="hdr pkg hdr-method"><a href="#Body.SetTorque" title="permalink">»</a>&nbsp;func (b *Body) SetTorque(torque float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetTorque(torque float64)</pre>
			<p>
Set the torque applied to the body for the next time step.
</p>

		</span>
	
		
		<h1 id="Body.SetType" class="hdr pkg hdr-method"><a href="#Body.SetType" title="permalink">»</a>&nbsp;func (b *Body) SetType(t BodyType) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetType(t BodyType)</pre>
			<p>
Set the type of the body.
</p>

		</span>
	
		
		<h1 id="Body.SetUserData" class="hdr pkg hdr-method"><a href="#Body.SetUserData" title="permalink">»</a>&nbsp;func (b *Body) SetUserData(userData interface{}) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetUserData(userData interface{})</pre>
			<p>
Set the user data interface assigned to the body.
</p>

		</span>
	
		
		<h1 id="Body.SetVelocity" class="hdr pkg hdr-method"><a href="#Body.SetVelocity" title="permalink">»</a>&nbsp;func (b *Body) SetVelocity(velocity Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetVelocity(velocity Vect)</pre>
			<p>
Set the velocity of the body.
</p>

		</span>
	
		
		<h1 id="Body.SetVelocityUpdateFunc" class="hdr pkg hdr-method"><a href="#Body.SetVelocityUpdateFunc" title="permalink">»</a>&nbsp;func (b *Body) SetVelocityUpdateFunc(f BodyVelocityFunc) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SetVelocityUpdateFunc(f BodyVelocityFunc)</pre>
			<p>
Set the callback used to update a body&#39;s velocity.
</p>

		</span>
	
		
		<h1 id="Body.Sleep" class="hdr pkg hdr-method"><a href="#Body.Sleep" title="permalink">»</a>&nbsp;func (b *Body) Sleep() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Sleep()</pre>
			<p>
Force a body to fall asleep immediately.
</p>

		</span>
	
		
		<h1 id="Body.SleepWithGroup" class="hdr pkg hdr-method"><a href="#Body.SleepWithGroup" title="permalink">»</a>&nbsp;func (b *Body) SleepWithGroup(group *Body) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) SleepWithGroup(group *Body)</pre>
			<p>
Force a body to fall asleep immediately along with other bodies in a group.
</p>

		</span>
	
		
		<h1 id="Body.Space" class="hdr pkg hdr-method"><a href="#Body.Space" title="permalink">»</a>&nbsp;func (b *Body) Space() *Space <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Space() *Space</pre>
			<p>
Get the space this body is added to.
</p>

		</span>
	
		
		<h1 id="Body.Torque" class="hdr pkg hdr-method"><a href="#Body.Torque" title="permalink">»</a>&nbsp;func (b *Body) Torque() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Torque() float64</pre>
			<p>
Get the torque applied to the body for the next time step.
</p>

		</span>
	
		
		<h1 id="Body.Type" class="hdr pkg hdr-method"><a href="#Body.Type" title="permalink">»</a>&nbsp;func (b *Body) Type() BodyType <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Type() BodyType</pre>
			<p>
Get the type of the body.
</p>

		</span>
	
		
		<h1 id="Body.UserData" class="hdr pkg hdr-method"><a href="#Body.UserData" title="permalink">»</a>&nbsp;func (b *Body) UserData() interface{} <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) UserData() interface{}</pre>
			<p>
Get the user data interface assigned to the body.
</p>

		</span>
	
		
		<h1 id="Body.Velocity" class="hdr pkg hdr-method"><a href="#Body.Velocity" title="permalink">»</a>&nbsp;func (b *Body) Velocity() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) Velocity() Vect</pre>
			<p>
Get the velocity of the body.
</p>

		</span>
	
		
		<h1 id="Body.VelocityAtLocalPoint" class="hdr pkg hdr-method"><a href="#Body.VelocityAtLocalPoint" title="permalink">»</a>&nbsp;func (b *Body) VelocityAtLocalPoint(point Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) VelocityAtLocalPoint(point Vect) Vect</pre>
			<p>
Get the velocity on a body (in world units) at a point on the body in local coordinates.
</p>

		</span>
	
		
		<h1 id="Body.VelocityAtWorldPoint" class="hdr pkg hdr-method"><a href="#Body.VelocityAtWorldPoint" title="permalink">»</a>&nbsp;func (b *Body) VelocityAtWorldPoint(point Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) VelocityAtWorldPoint(point Vect) Vect</pre>
			<p>
Get the velocity on a body (in world units) at a point on the body in world coordinates.
</p>

		</span>
	
		
		<h1 id="Body.WorldToLocal" class="hdr pkg hdr-method"><a href="#Body.WorldToLocal" title="permalink">»</a>&nbsp;func (b *Body) WorldToLocal(point Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (b *Body) WorldToLocal(point Vect) Vect</pre>
			<p>
Convert body absolute/world coordinates to  relative/local coordinates.
</p>

		</span>
	

	
	<h1 id="BodyPositionFunc" class="hdr pkg hdr-type"><a href="#BodyPositionFunc" title="permalink">»</a>&nbsp;type BodyPositionFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type BodyPositionFunc func(body *Body, dt float64)</pre>
		<p>
Rigid body position update function type.
</p>

	</span>

	
	

	
	

	
	<h1 id="BodyType" class="hdr pkg hdr-type"><a href="#BodyType" title="permalink">»</a>&nbsp;type BodyType <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type BodyType int</pre>
		<p>
Chipmunk&#39;s rigid body type. Rigid bodies hold the physical properties of an object like
it&#39;s mass, and position and velocity of it&#39;s center of gravity. They don&#39;t have an shape on their own.
They are given a shape by creating collision shapes (cpShape) that point to the body.
</p>

	</span>

	
	

	
	

	
	<h1 id="BodyVelocityFunc" class="hdr pkg hdr-type"><a href="#BodyVelocityFunc" title="permalink">»</a>&nbsp;type BodyVelocityFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type BodyVelocityFunc func(body *Body, gravity Vect, damping, dt float64)</pre>
		<p>
Rigid body velocity update function type.
</p>

	</span>

	
	

	
	

	
	<h1 id="CircleShape" class="hdr pkg hdr-type"><a href="#CircleShape" title="permalink">»</a>&nbsp;type CircleShape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CircleShape C.cpCircleShape</pre>
		
	</span>

	
	

	
	

	
	<h1 id="CollisionBeginFunc" class="hdr pkg hdr-type"><a href="#CollisionBeginFunc" title="permalink">»</a>&nbsp;type CollisionBeginFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CollisionBeginFunc func(arb *Arbiter, space *Space, userData interface{}) bool</pre>
		<p>
Collision begin event function callback type.
</p>
<p>
Returning false from a begin callback causes the collision to be ignored
until the the separate callback is called when the objects stop
colliding.
</p>

	</span>

	
	

	
	

	
	<h1 id="CollisionHandler" class="hdr pkg hdr-type"><a href="#CollisionHandler" title="permalink">»</a>&nbsp;type CollisionHandler <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CollisionHandler struct {
	TypeA, TypeB	CollisionType
	BeginFunc	CollisionBeginFunc
	PreSolveFunc	CollisionPreSolveFunc
	PostSolveFunc	CollisionPostSolveFunc
	SeparateFunc	CollisionSeparateFunc
	UserData	interface{}
}</pre>
		
	</span>

	
	

	
	

	
	<h1 id="CollisionID" class="hdr pkg hdr-type"><a href="#CollisionID" title="permalink">»</a>&nbsp;type CollisionID <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CollisionID C.cpCollisionID</pre>
		<p>
Type used internally to cache colliding object info for cpCollideShapes().
Should be at least 32 bits.
</p>

	</span>

	
	

	
	

	
	<h1 id="CollisionPostSolveFunc" class="hdr pkg hdr-type"><a href="#CollisionPostSolveFunc" title="permalink">»</a>&nbsp;type CollisionPostSolveFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CollisionPostSolveFunc func(arb *Arbiter, space *Space, userData interface{})</pre>
		<p>
Collision post-solve event function callback type.
</p>

	</span>

	
	

	
	

	
	<h1 id="CollisionPreSolveFunc" class="hdr pkg hdr-type"><a href="#CollisionPreSolveFunc" title="permalink">»</a>&nbsp;type CollisionPreSolveFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CollisionPreSolveFunc func(arb *Arbiter, space *Space, userData interface{}) bool</pre>
		<p>
Collision pre-solve event function callback type.
</p>
<p>
Returning false from a pre-step callback causes the collision to be
ignored until the next step.
</p>

	</span>

	
	

	
	

	
	<h1 id="CollisionSeparateFunc" class="hdr pkg hdr-type"><a href="#CollisionSeparateFunc" title="permalink">»</a>&nbsp;type CollisionSeparateFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CollisionSeparateFunc func(arb *Arbiter, space *Space, userData interface{})</pre>
		<p>
Collision separate event function callback type.
</p>

	</span>

	
	

	
	

	
	<h1 id="CollisionType" class="hdr pkg hdr-type"><a href="#CollisionType" title="permalink">»</a>&nbsp;type CollisionType <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type CollisionType C.cpCollisionType</pre>
		<p>
Type used for cpSpace.collision_type.
</p>

	</span>

	
	

	
	

	
	<h1 id="Constraint" class="hdr pkg hdr-type"><a href="#Constraint" title="permalink">»</a>&nbsp;type Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Constraint struct {
	// contains filtered or unexported fields
}</pre>
		
	</span>

	
	
		<h1 id="DampedRotarySpringNew" class="hdr pkg hdr-function"><a href="#DampedRotarySpringNew" title="permalink">»</a>&nbsp;func DampedRotarySpringNew(a, b *Body, restAngle, stiffness, damping float64) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func DampedRotarySpringNew(a, b *Body, restAngle, stiffness, damping float64) *Constraint</pre>
			<p>
Allocate and initialize a damped rotary spring.
</p>

		</span>
	
		<h1 id="DampedSpringNew" class="hdr pkg hdr-function"><a href="#DampedSpringNew" title="permalink">»</a>&nbsp;func DampedSpringNew(a, b *Body, anchorA, anchorB Vect, restLength, stiffness, damping float64) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func DampedSpringNew(a, b *Body, anchorA, anchorB Vect, restLength, stiffness, damping float64) *Constraint</pre>
			<p>
Allocate and initialize a damped spring.
</p>

		</span>
	
		<h1 id="GearJointNew" class="hdr pkg hdr-function"><a href="#GearJointNew" title="permalink">»</a>&nbsp;func GearJointNew(a, b *Body, phase, ratio float64) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func GearJointNew(a, b *Body, phase, ratio float64) *Constraint</pre>
			<p>
Allocate and initialize a gear joint.
</p>

		</span>
	
		<h1 id="GrooveJointNew" class="hdr pkg hdr-function"><a href="#GrooveJointNew" title="permalink">»</a>&nbsp;func GrooveJointNew(a, b *Body, grooveA, grooveB, anchorB Vect) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func GrooveJointNew(a, b *Body, grooveA, grooveB, anchorB Vect) *Constraint</pre>
			<p>
Allocate and initialize a groove joint.
</p>

		</span>
	
		<h1 id="PinJointNew" class="hdr pkg hdr-function"><a href="#PinJointNew" title="permalink">»</a>&nbsp;func PinJointNew(a, b *Body, anchorA, anchorB Vect) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func PinJointNew(a, b *Body, anchorA, anchorB Vect) *Constraint</pre>
			<p>
Allocate and initialize a pin joint.
</p>

		</span>
	
		<h1 id="PivotJointNew" class="hdr pkg hdr-function"><a href="#PivotJointNew" title="permalink">»</a>&nbsp;func PivotJointNew(a, b *Body, pivot Vect) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func PivotJointNew(a, b *Body, pivot Vect) *Constraint</pre>
			<p>
Allocate and initialize a pivot joint.
</p>

		</span>
	
		<h1 id="PivotJointNew2" class="hdr pkg hdr-function"><a href="#PivotJointNew2" title="permalink">»</a>&nbsp;func PivotJointNew2(a, b *Body, anchorA, anchorB Vect) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func PivotJointNew2(a, b *Body, anchorA, anchorB Vect) *Constraint</pre>
			<p>
Allocate and initialize a pivot joint with specific anchors.
</p>

		</span>
	
		<h1 id="RatchetJointNew" class="hdr pkg hdr-function"><a href="#RatchetJointNew" title="permalink">»</a>&nbsp;func RatchetJointNew(a, b *Body, phase, ratchet float64) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func RatchetJointNew(a, b *Body, phase, ratchet float64) *Constraint</pre>
			<p>
Allocate and initialize a ratchet joint.
</p>

		</span>
	
		<h1 id="RotaryLimitJointNew" class="hdr pkg hdr-function"><a href="#RotaryLimitJointNew" title="permalink">»</a>&nbsp;func RotaryLimitJointNew(a, b *Body, min, max float64) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func RotaryLimitJointNew(a, b *Body, min, max float64) *Constraint</pre>
			<p>
Allocate and initialize a damped rotary limit joint.
</p>

		</span>
	
		<h1 id="SimpleMotorNew" class="hdr pkg hdr-function"><a href="#SimpleMotorNew" title="permalink">»</a>&nbsp;func SimpleMotorNew(a, b *Body, rate float64) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func SimpleMotorNew(a, b *Body, rate float64) *Constraint</pre>
			<p>
Allocate and initialize a simple motor.
</p>

		</span>
	
		<h1 id="SlideJointNew" class="hdr pkg hdr-function"><a href="#SlideJointNew" title="permalink">»</a>&nbsp;func SlideJointNew(a, b *Body, anchorA, anchorB Vect, min, max float64) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func SlideJointNew(a, b *Body, anchorA, anchorB Vect, min, max float64) *Constraint</pre>
			<p>
Allocate and initialize a slide joint.
</p>

		</span>
	

	
	
		
		<h1 id="Constraint.BodyA" class="hdr pkg hdr-method"><a href="#Constraint.BodyA" title="permalink">»</a>&nbsp;func (c *Constraint) BodyA() *Body <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) BodyA() *Body</pre>
			<p>
Get the first body the constraint is attached to.
</p>

		</span>
	
		
		<h1 id="Constraint.BodyB" class="hdr pkg hdr-method"><a href="#Constraint.BodyB" title="permalink">»</a>&nbsp;func (c *Constraint) BodyB() *Body <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) BodyB() *Body</pre>
			<p>
Get the second body the constraint is attached to.
</p>

		</span>
	
		
		<h1 id="Constraint.CollideBodies" class="hdr pkg hdr-method"><a href="#Constraint.CollideBodies" title="permalink">»</a>&nbsp;func (c *Constraint) CollideBodies() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) CollideBodies() bool</pre>
			<p>
Get if the two bodies connected by the constraint are allowed to collide or not.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedRotarySpringDamping" class="hdr pkg hdr-method"><a href="#Constraint.DampedRotarySpringDamping" title="permalink">»</a>&nbsp;func (c *Constraint) DampedRotarySpringDamping() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedRotarySpringDamping() float64</pre>
			<p>
Get the damping of the spring.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedRotarySpringRestAngle" class="hdr pkg hdr-method"><a href="#Constraint.DampedRotarySpringRestAngle" title="permalink">»</a>&nbsp;func (c *Constraint) DampedRotarySpringRestAngle() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedRotarySpringRestAngle() float64</pre>
			<p>
Get the rest length of the spring.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedRotarySpringSetDamping" class="hdr pkg hdr-method"><a href="#Constraint.DampedRotarySpringSetDamping" title="permalink">»</a>&nbsp;func (c *Constraint) DampedRotarySpringSetDamping(damping float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedRotarySpringSetDamping(damping float64)</pre>
			<p>
Set the damping of the spring.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedRotarySpringSetStiffness" class="hdr pkg hdr-method"><a href="#Constraint.DampedRotarySpringSetStiffness" title="permalink">»</a>&nbsp;func (c *Constraint) DampedRotarySpringSetStiffness(stiffness float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedRotarySpringSetStiffness(stiffness float64)</pre>
			<p>
Set the stiffness of the spring in force/distance.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedRotarySpringSetTorqueFunc" class="hdr pkg hdr-method"><a href="#Constraint.DampedRotarySpringSetTorqueFunc" title="permalink">»</a>&nbsp;func (c *Constraint) DampedRotarySpringSetTorqueFunc(f func(spring *Constraint, relativeAngle float64) float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedRotarySpringSetTorqueFunc(f func(spring *Constraint, relativeAngle float64) float64)</pre>
			<p>
Set the damping rotary spring torque callback function.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedRotarySpringStiffness" class="hdr pkg hdr-method"><a href="#Constraint.DampedRotarySpringStiffness" title="permalink">»</a>&nbsp;func (c *Constraint) DampedRotarySpringStiffness() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedRotarySpringStiffness() float64</pre>
			<p>
Get the stiffness of the spring in force/distance.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedRotarySpringTorqueFunc" class="hdr pkg hdr-method"><a href="#Constraint.DampedRotarySpringTorqueFunc" title="permalink">»</a>&nbsp;func (c *Constraint) DampedRotarySpringTorqueFunc() func(spring *Constraint, relativeAngle float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedRotarySpringTorqueFunc() func(spring *Constraint, relativeAngle float64) float64</pre>
			<p>
Get the damping rotary spring torque callback function.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringAnchorA" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringAnchorA" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringAnchorA() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringAnchorA() Vect</pre>
			<p>
Get the location of the first anchor relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringAnchorB() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringAnchorB() Vect</pre>
			<p>
Get the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringDamping" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringDamping" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringDamping() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringDamping() float64</pre>
			<p>
Get the damping of the spring.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringForceFunc" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringForceFunc" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringForceFunc() func(spring *Constraint, dist float64) float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringForceFunc() func(spring *Constraint, dist float64) float64</pre>
			<p>
Get the damping rotary spring torque callback function.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringRestLength" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringRestLength" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringRestLength() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringRestLength() float64</pre>
			<p>
Get the rest length of the spring.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringSetAnchorA" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringSetAnchorA" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringSetAnchorA(anchorA Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringSetAnchorA(anchorA Vect)</pre>
			<p>
Set the location of the first anchor relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringSetAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringSetAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringSetAnchorB(anchorA Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringSetAnchorB(anchorA Vect)</pre>
			<p>
Set the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringSetDamping" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringSetDamping" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringSetDamping(damping float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringSetDamping(damping float64)</pre>
			<p>
Set the damping of the spring.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringSetForceFunc" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringSetForceFunc" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringSetForceFunc(f func(spring *Constraint, dist float64) float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringSetForceFunc(f func(spring *Constraint, dist float64) float64)</pre>
			<p>
Set the damping spring force callback function.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringSetRestLength" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringSetRestLength" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringSetRestLength(restLength float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringSetRestLength(restLength float64)</pre>
			<p>
Set the rest length of the spring.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringSetStiffness" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringSetStiffness" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringSetStiffness(stiffness float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringSetStiffness(stiffness float64)</pre>
			<p>
Set the stiffness of the spring in force/distance.
</p>

		</span>
	
		
		<h1 id="Constraint.DampedSpringStiffness" class="hdr pkg hdr-method"><a href="#Constraint.DampedSpringStiffness" title="permalink">»</a>&nbsp;func (c *Constraint) DampedSpringStiffness() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) DampedSpringStiffness() float64</pre>
			<p>
Get the stiffness of the spring in force/distance.
</p>

		</span>
	
		
		<h1 id="Constraint.ErrorBias" class="hdr pkg hdr-method"><a href="#Constraint.ErrorBias" title="permalink">»</a>&nbsp;func (c *Constraint) ErrorBias() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) ErrorBias() float64</pre>
			<p>
Get rate at which joint error is corrected.
</p>

		</span>
	
		
		<h1 id="Constraint.Free" class="hdr pkg hdr-method"><a href="#Constraint.Free" title="permalink">»</a>&nbsp;func (c *Constraint) Free() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) Free()</pre>
			<p>
Free is deprecated. Do not use it, it is no-op.
</p>

		</span>
	
		
		<h1 id="Constraint.GearJointPhase" class="hdr pkg hdr-method"><a href="#Constraint.GearJointPhase" title="permalink">»</a>&nbsp;func (c *Constraint) GearJointPhase() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GearJointPhase() float64</pre>
			<p>
Get the phase offset of the gears.
</p>

		</span>
	
		
		<h1 id="Constraint.GearJointRatio" class="hdr pkg hdr-method"><a href="#Constraint.GearJointRatio" title="permalink">»</a>&nbsp;func (c *Constraint) GearJointRatio() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GearJointRatio() float64</pre>
			<p>
Get the angular distance of each ratchet.
</p>

		</span>
	
		
		<h1 id="Constraint.GearJointSetPhase" class="hdr pkg hdr-method"><a href="#Constraint.GearJointSetPhase" title="permalink">»</a>&nbsp;func (c *Constraint) GearJointSetPhase(phase float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GearJointSetPhase(phase float64)</pre>
			<p>
Set the phase offset of the gears.
</p>

		</span>
	
		
		<h1 id="Constraint.GearJointSetRatio" class="hdr pkg hdr-method"><a href="#Constraint.GearJointSetRatio" title="permalink">»</a>&nbsp;func (c *Constraint) GearJointSetRatio(ratio float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GearJointSetRatio(ratio float64)</pre>
			<p>
Set the ratio of a gear joint.
</p>

		</span>
	
		
		<h1 id="Constraint.GrooveJointAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.GrooveJointAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) GrooveJointAnchorB() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GrooveJointAnchorB() Vect</pre>
			<p>
Get the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.GrooveJointGrooveA" class="hdr pkg hdr-method"><a href="#Constraint.GrooveJointGrooveA" title="permalink">»</a>&nbsp;func (c *Constraint) GrooveJointGrooveA() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GrooveJointGrooveA() Vect</pre>
			<p>
Get the first endpoint of the groove relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.GrooveJointGrooveB" class="hdr pkg hdr-method"><a href="#Constraint.GrooveJointGrooveB" title="permalink">»</a>&nbsp;func (c *Constraint) GrooveJointGrooveB() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GrooveJointGrooveB() Vect</pre>
			<p>
Get the first endpoint of the groove relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.GrooveJointSetAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.GrooveJointSetAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) GrooveJointSetAnchorB(grooveB Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GrooveJointSetAnchorB(grooveB Vect)</pre>
			<p>
Set the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.GrooveJointSetGrooveA" class="hdr pkg hdr-method"><a href="#Constraint.GrooveJointSetGrooveA" title="permalink">»</a>&nbsp;func (c *Constraint) GrooveJointSetGrooveA(grooveA Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GrooveJointSetGrooveA(grooveA Vect)</pre>
			<p>
Set the first endpoint of the groove relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.GrooveJointSetGrooveB" class="hdr pkg hdr-method"><a href="#Constraint.GrooveJointSetGrooveB" title="permalink">»</a>&nbsp;func (c *Constraint) GrooveJointSetGrooveB(grooveB Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) GrooveJointSetGrooveB(grooveB Vect)</pre>
			<p>
Set the first endpoint of the groove relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.Impulse" class="hdr pkg hdr-method"><a href="#Constraint.Impulse" title="permalink">»</a>&nbsp;func (c *Constraint) Impulse() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) Impulse() float64</pre>
			<p>
Get the last impulse applied by this constraint.
</p>

		</span>
	
		
		<h1 id="Constraint.IsDampedRotarySpring" class="hdr pkg hdr-method"><a href="#Constraint.IsDampedRotarySpring" title="permalink">»</a>&nbsp;func (c *Constraint) IsDampedRotarySpring() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsDampedRotarySpring() bool</pre>
			<p>
Check if a constraint is a damped rotary spring.
</p>

		</span>
	
		
		<h1 id="Constraint.IsDampedSpring" class="hdr pkg hdr-method"><a href="#Constraint.IsDampedSpring" title="permalink">»</a>&nbsp;func (c *Constraint) IsDampedSpring() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsDampedSpring() bool</pre>
			<p>
Check if a constraint is a damped spring.
</p>

		</span>
	
		
		<h1 id="Constraint.IsGearJoint" class="hdr pkg hdr-method"><a href="#Constraint.IsGearJoint" title="permalink">»</a>&nbsp;func (c *Constraint) IsGearJoint() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsGearJoint() bool</pre>
			<p>
Check if a constraint is a ratchet joint.
</p>

		</span>
	
		
		<h1 id="Constraint.IsGrooveJoint" class="hdr pkg hdr-method"><a href="#Constraint.IsGrooveJoint" title="permalink">»</a>&nbsp;func (c *Constraint) IsGrooveJoint() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsGrooveJoint() bool</pre>
			<p>
Check if a constraint is a groove joint.
</p>

		</span>
	
		
		<h1 id="Constraint.IsPinJoint" class="hdr pkg hdr-method"><a href="#Constraint.IsPinJoint" title="permalink">»</a>&nbsp;func (c *Constraint) IsPinJoint() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsPinJoint() bool</pre>
			<p>
Check if a constraint is a pin joint.
</p>

		</span>
	
		
		<h1 id="Constraint.IsPivotJoint" class="hdr pkg hdr-method"><a href="#Constraint.IsPivotJoint" title="permalink">»</a>&nbsp;func (c *Constraint) IsPivotJoint() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsPivotJoint() bool</pre>
			<p>
Check if a constraint is a pivot joint.
</p>

		</span>
	
		
		<h1 id="Constraint.IsRatchetJoint" class="hdr pkg hdr-method"><a href="#Constraint.IsRatchetJoint" title="permalink">»</a>&nbsp;func (c *Constraint) IsRatchetJoint() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsRatchetJoint() bool</pre>
			<p>
Check if a constraint is a ratchet joint.
</p>

		</span>
	
		
		<h1 id="Constraint.IsRotaryLimitJoint" class="hdr pkg hdr-method"><a href="#Constraint.IsRotaryLimitJoint" title="permalink">»</a>&nbsp;func (c *Constraint) IsRotaryLimitJoint() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsRotaryLimitJoint() bool</pre>
			<p>
Check if a constraint is a rotary limit joint.
</p>

		</span>
	
		
		<h1 id="Constraint.IsSimpleMotor" class="hdr pkg hdr-method"><a href="#Constraint.IsSimpleMotor" title="permalink">»</a>&nbsp;func (c *Constraint) IsSimpleMotor() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsSimpleMotor() bool</pre>
			<p>
Check if a constraint is a simple motor.
</p>

		</span>
	
		
		<h1 id="Constraint.IsSlideJoint" class="hdr pkg hdr-method"><a href="#Constraint.IsSlideJoint" title="permalink">»</a>&nbsp;func (c *Constraint) IsSlideJoint() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) IsSlideJoint() bool</pre>
			<p>
Check if a constraint is a slide joint.
</p>

		</span>
	
		
		<h1 id="Constraint.MaxBias" class="hdr pkg hdr-method"><a href="#Constraint.MaxBias" title="permalink">»</a>&nbsp;func (c *Constraint) MaxBias() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) MaxBias() float64</pre>
			<p>
Get the maximum rate at which joint error is corrected.
</p>

		</span>
	
		
		<h1 id="Constraint.MaxForce" class="hdr pkg hdr-method"><a href="#Constraint.MaxForce" title="permalink">»</a>&nbsp;func (c *Constraint) MaxForce() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) MaxForce() float64</pre>
			<p>
Get the maximum force that this constraint is allowed to use.
</p>

		</span>
	
		
		<h1 id="Constraint.PinJointAnchorA" class="hdr pkg hdr-method"><a href="#Constraint.PinJointAnchorA" title="permalink">»</a>&nbsp;func (c *Constraint) PinJointAnchorA() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PinJointAnchorA() Vect</pre>
			<p>
Get the location of the first anchor relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.PinJointAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.PinJointAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) PinJointAnchorB() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PinJointAnchorB() Vect</pre>
			<p>
Get the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.PinJointDist" class="hdr pkg hdr-method"><a href="#Constraint.PinJointDist" title="permalink">»</a>&nbsp;func (c *Constraint) PinJointDist() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PinJointDist() float64</pre>
			<p>
Get the distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.PinJointSetAnchorA" class="hdr pkg hdr-method"><a href="#Constraint.PinJointSetAnchorA" title="permalink">»</a>&nbsp;func (c *Constraint) PinJointSetAnchorA(anchorA Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PinJointSetAnchorA(anchorA Vect)</pre>
			<p>
Set the location of the first anchor relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.PinJointSetAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.PinJointSetAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) PinJointSetAnchorB(anchorB Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PinJointSetAnchorB(anchorB Vect)</pre>
			<p>
Set the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.PinJointSetDist" class="hdr pkg hdr-method"><a href="#Constraint.PinJointSetDist" title="permalink">»</a>&nbsp;func (c *Constraint) PinJointSetDist(dist float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PinJointSetDist(dist float64)</pre>
			<p>
Set the distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.PivotJointAnchorA" class="hdr pkg hdr-method"><a href="#Constraint.PivotJointAnchorA" title="permalink">»</a>&nbsp;func (c *Constraint) PivotJointAnchorA() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PivotJointAnchorA() Vect</pre>
			<p>
Get the location of the first anchor relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.PivotJointAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.PivotJointAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) PivotJointAnchorB() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PivotJointAnchorB() Vect</pre>
			<p>
Get the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.PivotJointSetAnchorA" class="hdr pkg hdr-method"><a href="#Constraint.PivotJointSetAnchorA" title="permalink">»</a>&nbsp;func (c *Constraint) PivotJointSetAnchorA(anchorA Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PivotJointSetAnchorA(anchorA Vect)</pre>
			<p>
Set the location of the first anchor relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.PivotJointSetAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.PivotJointSetAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) PivotJointSetAnchorB(anchorB Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PivotJointSetAnchorB(anchorB Vect)</pre>
			<p>
Set the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.PostSolveFunc" class="hdr pkg hdr-method"><a href="#Constraint.PostSolveFunc" title="permalink">»</a>&nbsp;func (c *Constraint) PostSolveFunc() func(*Constraint, *Space) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PostSolveFunc() func(*Constraint, *Space)</pre>
			<p>
Get the post-solve function that is called before the solver runs.
</p>

		</span>
	
		
		<h1 id="Constraint.PreSolveFunc" class="hdr pkg hdr-method"><a href="#Constraint.PreSolveFunc" title="permalink">»</a>&nbsp;func (c *Constraint) PreSolveFunc() func(*Constraint, *Space) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) PreSolveFunc() func(*Constraint, *Space)</pre>
			<p>
Get the pre-solve function that is called before the solver runs.
</p>

		</span>
	
		
		<h1 id="Constraint.RatchetJointAngle" class="hdr pkg hdr-method"><a href="#Constraint.RatchetJointAngle" title="permalink">»</a>&nbsp;func (c *Constraint) RatchetJointAngle() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RatchetJointAngle() float64</pre>
			<p>
Get the angle of the current ratchet tooth.
</p>

		</span>
	
		
		<h1 id="Constraint.RatchetJointPhase" class="hdr pkg hdr-method"><a href="#Constraint.RatchetJointPhase" title="permalink">»</a>&nbsp;func (c *Constraint) RatchetJointPhase() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RatchetJointPhase() float64</pre>
			<p>
Get the phase offset of the ratchet.
</p>

		</span>
	
		
		<h1 id="Constraint.RatchetJointRatchet" class="hdr pkg hdr-method"><a href="#Constraint.RatchetJointRatchet" title="permalink">»</a>&nbsp;func (c *Constraint) RatchetJointRatchet() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RatchetJointRatchet() float64</pre>
			<p>
Get the angular distance of each ratchet.
</p>

		</span>
	
		
		<h1 id="Constraint.RatchetJointSetAngle" class="hdr pkg hdr-method"><a href="#Constraint.RatchetJointSetAngle" title="permalink">»</a>&nbsp;func (c *Constraint) RatchetJointSetAngle(angle float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RatchetJointSetAngle(angle float64)</pre>
			<p>
Set the angle of the current ratchet tooth.
</p>

		</span>
	
		
		<h1 id="Constraint.RatchetJointSetPhase" class="hdr pkg hdr-method"><a href="#Constraint.RatchetJointSetPhase" title="permalink">»</a>&nbsp;func (c *Constraint) RatchetJointSetPhase(phase float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RatchetJointSetPhase(phase float64)</pre>
			<p>
Get the phase offset of the ratchet.
</p>

		</span>
	
		
		<h1 id="Constraint.RatchetJointSetRatchet" class="hdr pkg hdr-method"><a href="#Constraint.RatchetJointSetRatchet" title="permalink">»</a>&nbsp;func (c *Constraint) RatchetJointSetRatchet(ratchet float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RatchetJointSetRatchet(ratchet float64)</pre>
			<p>
Set the angular distance of each ratchet.
</p>

		</span>
	
		
		<h1 id="Constraint.RotaryLimitJointMax" class="hdr pkg hdr-method"><a href="#Constraint.RotaryLimitJointMax" title="permalink">»</a>&nbsp;func (c *Constraint) RotaryLimitJointMax() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RotaryLimitJointMax() float64</pre>
			<p>
Get the maximum distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.RotaryLimitJointMin" class="hdr pkg hdr-method"><a href="#Constraint.RotaryLimitJointMin" title="permalink">»</a>&nbsp;func (c *Constraint) RotaryLimitJointMin() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RotaryLimitJointMin() float64</pre>
			<p>
Get the minimum distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.RotaryLimitJointSetMax" class="hdr pkg hdr-method"><a href="#Constraint.RotaryLimitJointSetMax" title="permalink">»</a>&nbsp;func (c *Constraint) RotaryLimitJointSetMax(max float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RotaryLimitJointSetMax(max float64)</pre>
			<p>
Set the maximum distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.RotaryLimitJointSetMin" class="hdr pkg hdr-method"><a href="#Constraint.RotaryLimitJointSetMin" title="permalink">»</a>&nbsp;func (c *Constraint) RotaryLimitJointSetMin(min float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RotaryLimitJointSetMin(min float64)</pre>
			<p>
Set the minimum distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.RotarySpringSetRestAngle" class="hdr pkg hdr-method"><a href="#Constraint.RotarySpringSetRestAngle" title="permalink">»</a>&nbsp;func (c *Constraint) RotarySpringSetRestAngle(restAngle float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) RotarySpringSetRestAngle(restAngle float64)</pre>
			<p>
Set the rest length of the spring.
</p>

		</span>
	
		
		<h1 id="Constraint.SetCollideBodies" class="hdr pkg hdr-method"><a href="#Constraint.SetCollideBodies" title="permalink">»</a>&nbsp;func (c *Constraint) SetCollideBodies(collideBodies bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SetCollideBodies(collideBodies bool)</pre>
			<p>
Set if the two bodies connected by the constraint are allowed to collide or not. (defaults to cpFalse)
</p>

		</span>
	
		
		<h1 id="Constraint.SetErrorBias" class="hdr pkg hdr-method"><a href="#Constraint.SetErrorBias" title="permalink">»</a>&nbsp;func (c *Constraint) SetErrorBias(errorBias float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SetErrorBias(errorBias float64)</pre>
			<p>
Set rate at which joint error is corrected.
</p>
<p>
Defaults to pow(1.0 - 0.1, 60.0) meaning that it will
correct 10% of the error every 1/60th of a second.
</p>

		</span>
	
		
		<h1 id="Constraint.SetMaxBias" class="hdr pkg hdr-method"><a href="#Constraint.SetMaxBias" title="permalink">»</a>&nbsp;func (c *Constraint) SetMaxBias(maxBias float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SetMaxBias(maxBias float64)</pre>
			<p>
Set the maximum rate at which joint error is corrected. (defaults to INFINITY)
</p>

		</span>
	
		
		<h1 id="Constraint.SetMaxForce" class="hdr pkg hdr-method"><a href="#Constraint.SetMaxForce" title="permalink">»</a>&nbsp;func (c *Constraint) SetMaxForce(maxForce float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SetMaxForce(maxForce float64)</pre>
			<p>
Set the maximum force that this constraint is allowed to use. (defaults to INFINITY)
</p>

		</span>
	
		
		<h1 id="Constraint.SetPostSolveFunc" class="hdr pkg hdr-method"><a href="#Constraint.SetPostSolveFunc" title="permalink">»</a>&nbsp;func (c *Constraint) SetPostSolveFunc(f func(*Constraint, *Space)) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SetPostSolveFunc(f func(*Constraint, *Space))</pre>
			<p>
Set the post-solve function that is called before the solver runs.
</p>

		</span>
	
		
		<h1 id="Constraint.SetPreSolveFunc" class="hdr pkg hdr-method"><a href="#Constraint.SetPreSolveFunc" title="permalink">»</a>&nbsp;func (c *Constraint) SetPreSolveFunc(f func(*Constraint, *Space)) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SetPreSolveFunc(f func(*Constraint, *Space))</pre>
			<p>
Set the pre-solve function that is called before the solver runs.
</p>

		</span>
	
		
		<h1 id="Constraint.SetUserData" class="hdr pkg hdr-method"><a href="#Constraint.SetUserData" title="permalink">»</a>&nbsp;func (c *Constraint) SetUserData(i interface{}) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SetUserData(i interface{})</pre>
			<p>
Set the user definable data pointer for this constraint
</p>

		</span>
	
		
		<h1 id="Constraint.SimpleMotorRate" class="hdr pkg hdr-method"><a href="#Constraint.SimpleMotorRate" title="permalink">»</a>&nbsp;func (c *Constraint) SimpleMotorRate() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SimpleMotorRate() float64</pre>
			<p>
Get the rate of the motor.
</p>

		</span>
	
		
		<h1 id="Constraint.SimpleMotorSetRate" class="hdr pkg hdr-method"><a href="#Constraint.SimpleMotorSetRate" title="permalink">»</a>&nbsp;func (c *Constraint) SimpleMotorSetRate(rate float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SimpleMotorSetRate(rate float64)</pre>
			<p>
Set the rate of the motor.
</p>

		</span>
	
		
		<h1 id="Constraint.SlideJointAnchorA" class="hdr pkg hdr-method"><a href="#Constraint.SlideJointAnchorA" title="permalink">»</a>&nbsp;func (c *Constraint) SlideJointAnchorA() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SlideJointAnchorA() Vect</pre>
			<p>
Get the location of the first anchor relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.SlideJointAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.SlideJointAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) SlideJointAnchorB() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SlideJointAnchorB() Vect</pre>
			<p>
Get the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.SlideJointMax" class="hdr pkg hdr-method"><a href="#Constraint.SlideJointMax" title="permalink">»</a>&nbsp;func (c *Constraint) SlideJointMax() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SlideJointMax() float64</pre>
			<p>
Get the maximum distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.SlideJointMin" class="hdr pkg hdr-method"><a href="#Constraint.SlideJointMin" title="permalink">»</a>&nbsp;func (c *Constraint) SlideJointMin() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SlideJointMin() float64</pre>
			<p>
Get the minimum distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.SlideJointSetAnchorA" class="hdr pkg hdr-method"><a href="#Constraint.SlideJointSetAnchorA" title="permalink">»</a>&nbsp;func (c *Constraint) SlideJointSetAnchorA(anchorA Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SlideJointSetAnchorA(anchorA Vect)</pre>
			<p>
Set the location of the first anchor relative to the first body.
</p>

		</span>
	
		
		<h1 id="Constraint.SlideJointSetAnchorB" class="hdr pkg hdr-method"><a href="#Constraint.SlideJointSetAnchorB" title="permalink">»</a>&nbsp;func (c *Constraint) SlideJointSetAnchorB(anchorB Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SlideJointSetAnchorB(anchorB Vect)</pre>
			<p>
Set the location of the second anchor relative to the second body.
</p>

		</span>
	
		
		<h1 id="Constraint.SlideJointSetMax" class="hdr pkg hdr-method"><a href="#Constraint.SlideJointSetMax" title="permalink">»</a>&nbsp;func (c *Constraint) SlideJointSetMax(max float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SlideJointSetMax(max float64)</pre>
			<p>
Set the maximum distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.SlideJointSetMin" class="hdr pkg hdr-method"><a href="#Constraint.SlideJointSetMin" title="permalink">»</a>&nbsp;func (c *Constraint) SlideJointSetMin(min float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) SlideJointSetMin(min float64)</pre>
			<p>
Set the minimum distance the joint will maintain between the two anchors.
</p>

		</span>
	
		
		<h1 id="Constraint.Space" class="hdr pkg hdr-method"><a href="#Constraint.Space" title="permalink">»</a>&nbsp;func (c *Constraint) Space() *Space <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) Space() *Space</pre>
			<p>
Get the Space this constraint is added to.
</p>

		</span>
	
		
		<h1 id="Constraint.UserData" class="hdr pkg hdr-method"><a href="#Constraint.UserData" title="permalink">»</a>&nbsp;func (c *Constraint) UserData() interface{} <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (c *Constraint) UserData() interface{}</pre>
			<p>
Get the user definable data pointer for this constraint
</p>

		</span>
	

	
	<h1 id="ConstraintPostSolveFunc" class="hdr pkg hdr-type"><a href="#ConstraintPostSolveFunc" title="permalink">»</a>&nbsp;type ConstraintPostSolveFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ConstraintPostSolveFunc func(c *Constraint, space *Space)</pre>
		<p>
Callback function type that gets called after solving a joint.
</p>

	</span>

	
	

	
	

	
	<h1 id="ConstraintPreSolveFunc" class="hdr pkg hdr-type"><a href="#ConstraintPreSolveFunc" title="permalink">»</a>&nbsp;type ConstraintPreSolveFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ConstraintPreSolveFunc func(c *Constraint, space *Space)</pre>
		<p>
Callback function type that gets called before solving a joint.
</p>

	</span>

	
	

	
	

	
	<h1 id="ContactBufferHeader" class="hdr pkg hdr-type"><a href="#ContactBufferHeader" title="permalink">»</a>&nbsp;type ContactBufferHeader <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ContactBufferHeader C.cpContactBufferHeader</pre>
		
	</span>

	
	

	
	

	
	<h1 id="ContactPoint" class="hdr pkg hdr-type"><a href="#ContactPoint" title="permalink">»</a>&nbsp;type ContactPoint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ContactPoint struct {
	// The position of the contact on the surface of each shape.
	Point1, Point2	Vect

	// Penetration distance of the two shapes. Overlapping means it will be
	// negative.
	//
	// This value is calculated as Vdot(Vsub(point2, point1), normal) and is
	// ignored by arbiter.SetContactPointSet().
	Distance	float64
}</pre>
		
	</span>

	
	

	
	

	
	<h1 id="ContactPointSet" class="hdr pkg hdr-type"><a href="#ContactPointSet" title="permalink">»</a>&nbsp;type ContactPointSet <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ContactPointSet struct {
	// The number of contact points in the set.
	Count	Int

	// The normal of the collision.
	Normal	Vect

	// The array of contact points.
	Points	[MAX_CONTACTS_PER_ARBITER]ContactPoint
}</pre>
		<p>
A struct that wraps up the important collision data for an arbiter.
</p>

	</span>

	
	

	
	

	
	<h1 id="DampedRotarySpring" class="hdr pkg hdr-type"><a href="#DampedRotarySpring" title="permalink">»</a>&nbsp;type DampedRotarySpring <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type DampedRotarySpring C.cpDampedRotarySpring</pre>
		
	</span>

	
	

	
	

	
	<h1 id="DampedSpring" class="hdr pkg hdr-type"><a href="#DampedSpring" title="permalink">»</a>&nbsp;type DampedSpring <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type DampedSpring C.cpDampedSpring</pre>
		
	</span>

	
	

	
	

	
	<h1 id="DataPointer" class="hdr pkg hdr-type"><a href="#DataPointer" title="permalink">»</a>&nbsp;type DataPointer <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type DataPointer C.cpDataPointer</pre>
		<p>
Type used for user data pointers.
</p>

	</span>

	
	

	
	

	
	<h1 id="GearJoint" class="hdr pkg hdr-type"><a href="#GearJoint" title="permalink">»</a>&nbsp;type GearJoint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type GearJoint C.cpGearJoint</pre>
		
	</span>

	
	

	
	

	
	<h1 id="GrooveJoint" class="hdr pkg hdr-type"><a href="#GrooveJoint" title="permalink">»</a>&nbsp;type GrooveJoint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type GrooveJoint C.cpGrooveJoint</pre>
		
	</span>

	
	

	
	

	
	<h1 id="Group" class="hdr pkg hdr-type"><a href="#Group" title="permalink">»</a>&nbsp;type Group <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Group C.cpGroup</pre>
		<p>
Type used for cpShape.group.
</p>

	</span>

	
	

	
	

	
	<h1 id="HashSet" class="hdr pkg hdr-type"><a href="#HashSet" title="permalink">»</a>&nbsp;type HashSet <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type HashSet C.cpHashSet</pre>
		
	</span>

	
	

	
	

	
	<h1 id="HashValue" class="hdr pkg hdr-type"><a href="#HashValue" title="permalink">»</a>&nbsp;type HashValue <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type HashValue C.cpHashValue</pre>
		<p>
Hash value type.
</p>

	</span>

	
	

	
	

	
	<h1 id="Int" class="hdr pkg hdr-type"><a href="#Int" title="permalink">»</a>&nbsp;type Int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Int C.int</pre>
		
	</span>

	
	

	
	

	
	<h1 id="Mat2x2" class="hdr pkg hdr-type"><a href="#Mat2x2" title="permalink">»</a>&nbsp;type Mat2x2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Mat2x2 C.cpMat2x2</pre>
		<p>
Row major [[a, b][c d]]
</p>

	</span>

	
	
		<h1 id="Mat2x2New" class="hdr pkg hdr-function"><a href="#Mat2x2New" title="permalink">»</a>&nbsp;func Mat2x2New(a, b, c, d float64) Mat2x2 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Mat2x2New(a, b, c, d float64) Mat2x2</pre>
			
		</span>
	

	
	
		
		<h1 id="Mat2x2.Transform" class="hdr pkg hdr-method"><a href="#Mat2x2.Transform" title="permalink">»</a>&nbsp;func (m Mat2x2) Transform(v Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (m Mat2x2) Transform(v Vect) Vect</pre>
			
		</span>
	

	
	<h1 id="PinJoint" class="hdr pkg hdr-type"><a href="#PinJoint" title="permalink">»</a>&nbsp;type PinJoint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PinJoint C.cpPinJoint</pre>
		
	</span>

	
	

	
	

	
	<h1 id="PivotJoint" class="hdr pkg hdr-type"><a href="#PivotJoint" title="permalink">»</a>&nbsp;type PivotJoint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PivotJoint C.cpPivotJoint</pre>
		
	</span>

	
	

	
	

	
	<h1 id="PointQueryInfo" class="hdr pkg hdr-type"><a href="#PointQueryInfo" title="permalink">»</a>&nbsp;type PointQueryInfo <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PointQueryInfo struct {
	// The nearest shape, nil if no shape was within range.
	Shape	*Shape

	// The closest point on the shape&#39;s surface. (in world space coordinates)
	Point	Vect

	// The distance to the point. The distance is negative if the point is
	// inside the shape.
	Distance	float64

	// The gradient of the signed distance function.
	//
	// The same as info.p/info.d, but accurate even for very small values of
	// info.d.
	Gradient	Vect
}</pre>
		<p>
Nearest point query info struct.
</p>

	</span>

	
	

	
	

	
	<h1 id="PolyShape" class="hdr pkg hdr-type"><a href="#PolyShape" title="permalink">»</a>&nbsp;type PolyShape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type PolyShape C.cpPolyShape</pre>
		
	</span>

	
	

	
	

	
	<h1 id="RatchetJoint" class="hdr pkg hdr-type"><a href="#RatchetJoint" title="permalink">»</a>&nbsp;type RatchetJoint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type RatchetJoint C.cpRatchetJoint</pre>
		
	</span>

	
	

	
	

	
	<h1 id="RotaryLimitJoint" class="hdr pkg hdr-type"><a href="#RotaryLimitJoint" title="permalink">»</a>&nbsp;type RotaryLimitJoint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type RotaryLimitJoint C.cpRotaryLimitJoint</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SegmentQueryInfo" class="hdr pkg hdr-type"><a href="#SegmentQueryInfo" title="permalink">»</a>&nbsp;type SegmentQueryInfo <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SegmentQueryInfo struct {
	// The shape that was hit, nil if no collision occured.
	Shape	*Shape

	// The point of impact.
	Point	Vect

	// The normal of the surface hit.
	Normal	Vect

	// The normalized distance along the query segment in the range [0, 1].
	Alpha	float64
}</pre>
		<p>
Segment query info struct.
</p>

	</span>

	
	

	
	

	
	<h1 id="SegmentShape" class="hdr pkg hdr-type"><a href="#SegmentShape" title="permalink">»</a>&nbsp;type SegmentShape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SegmentShape C.cpSegmentShape</pre>
		
	</span>

	
	

	
	

	
	<h1 id="Shape" class="hdr pkg hdr-type"><a href="#Shape" title="permalink">»</a>&nbsp;type Shape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Shape struct {
	// contains filtered or unexported fields
}</pre>
		<p>
The Shape struct defines the shape of a rigid body.
</p>

	</span>

	
	

	
	
		
		<h1 id="Shape.Area" class="hdr pkg hdr-method"><a href="#Shape.Area" title="permalink">»</a>&nbsp;func (s *Shape) Area() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Area() float64</pre>
			<p>
Get the calculated area of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.BB" class="hdr pkg hdr-method"><a href="#Shape.BB" title="permalink">»</a>&nbsp;func (s *Shape) BB() BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) BB() BB</pre>
			<p>
Get the bounding box that contains the shape given it&#39;s current position and angle.
</p>

		</span>
	
		
		<h1 id="Shape.Body" class="hdr pkg hdr-method"><a href="#Shape.Body" title="permalink">»</a>&nbsp;func (s *Shape) Body() *Body <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Body() *Body</pre>
			<p>
The cpBody this shape is connected to.
</p>

		</span>
	
		
		<h1 id="Shape.CacheBB" class="hdr pkg hdr-method"><a href="#Shape.CacheBB" title="permalink">»</a>&nbsp;func (s *Shape) CacheBB() BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) CacheBB() BB</pre>
			<p>
Update, cache and return the bounding box of a shape based on the body it&#39;s
attached to.
</p>

		</span>
	
		
		<h1 id="Shape.CenterOfGravity" class="hdr pkg hdr-method"><a href="#Shape.CenterOfGravity" title="permalink">»</a>&nbsp;func (s *Shape) CenterOfGravity() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) CenterOfGravity() Vect</pre>
			<p>
Get the centroid of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.CircleOffset" class="hdr pkg hdr-method"><a href="#Shape.CircleOffset" title="permalink">»</a>&nbsp;func (s *Shape) CircleOffset() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) CircleOffset() Vect</pre>
			<p>
Get the offset of a circle shape.
</p>

		</span>
	
		
		<h1 id="Shape.CircleRadius" class="hdr pkg hdr-method"><a href="#Shape.CircleRadius" title="permalink">»</a>&nbsp;func (s *Shape) CircleRadius() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) CircleRadius() float64</pre>
			<p>
Get the radius of a circle shape.
</p>

		</span>
	
		
		<h1 id="Shape.CircleShapeSetOffset" class="hdr pkg hdr-method"><a href="#Shape.CircleShapeSetOffset" title="permalink">»</a>&nbsp;func (shape *Shape) CircleShapeSetOffset(offset Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (shape *Shape) CircleShapeSetOffset(offset Vect)</pre>
			<p>
Set the offset of a circle shape.
</p>
<p>
This function is used for mutating collision shapes. Chipmunk does not have
any way to get velocity information on changing shapes, so the results will
be unrealistic. This function is considered &#39;unsafe&#39; by Chipmunk.
</p>

		</span>
	
		
		<h1 id="Shape.CircleShapeSetRadius" class="hdr pkg hdr-method"><a href="#Shape.CircleShapeSetRadius" title="permalink">»</a>&nbsp;func (shape *Shape) CircleShapeSetRadius(radius float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (shape *Shape) CircleShapeSetRadius(radius float64)</pre>
			<p>
Set the radius of a circle shape.
</p>
<p>
This function is used for mutating collision shapes. Chipmunk does not have
any way to get velocity information on changing shapes, so the results will
be unrealistic. This function is considered &#39;unsafe&#39; by Chipmunk.
</p>

		</span>
	
		
		<h1 id="Shape.CollisionType" class="hdr pkg hdr-method"><a href="#Shape.CollisionType" title="permalink">»</a>&nbsp;func (s *Shape) CollisionType() CollisionType <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) CollisionType() CollisionType</pre>
			<p>
Get the collision type of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.Density" class="hdr pkg hdr-method"><a href="#Shape.Density" title="permalink">»</a>&nbsp;func (s *Shape) Density() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Density() float64</pre>
			<p>
Get the density of the shape if you are having Chipmunk calculate mass properties for you.
</p>

		</span>
	
		
		<h1 id="Shape.Elasticity" class="hdr pkg hdr-method"><a href="#Shape.Elasticity" title="permalink">»</a>&nbsp;func (s *Shape) Elasticity() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Elasticity() float64</pre>
			<p>
Get the elasticity of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.Filter" class="hdr pkg hdr-method"><a href="#Shape.Filter" title="permalink">»</a>&nbsp;func (s *Shape) Filter() ShapeFilter <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Filter() ShapeFilter</pre>
			<p>
Get the collision filtering parameters of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.Free" class="hdr pkg hdr-method"><a href="#Shape.Free" title="permalink">»</a>&nbsp;func (s *Shape) Free() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Free()</pre>
			<p>
Free is deprecated. Do not use it, it is no-op.
</p>

		</span>
	
		
		<h1 id="Shape.Friction" class="hdr pkg hdr-method"><a href="#Shape.Friction" title="permalink">»</a>&nbsp;func (s *Shape) Friction() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Friction() float64</pre>
			<p>
Get the friction of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.Mass" class="hdr pkg hdr-method"><a href="#Shape.Mass" title="permalink">»</a>&nbsp;func (s *Shape) Mass() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Mass() float64</pre>
			<p>
Get the mass of the shape if you are having Chipmunk calculate mass properties for you.
</p>

		</span>
	
		
		<h1 id="Shape.Moment" class="hdr pkg hdr-method"><a href="#Shape.Moment" title="permalink">»</a>&nbsp;func (s *Shape) Moment() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Moment() float64</pre>
			<p>
Get the calculated moment of inertia for this shape.
</p>

		</span>
	
		
		<h1 id="Shape.PointQuery" class="hdr pkg hdr-method"><a href="#Shape.PointQuery" title="permalink">»</a>&nbsp;func (s *Shape) PointQuery(p Vect) (out *PointQueryInfo, d float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) PointQuery(p Vect) (out *PointQueryInfo, d float64)</pre>
			<p>
Perform a nearest point query. It finds the closest point on the surface of
shape to a specific point.
</p>
<p>
The value returned is the distance between the points. A negative distance
means the point is inside the shape.
</p>

		</span>
	
		
		<h1 id="Shape.PolyCount" class="hdr pkg hdr-method"><a href="#Shape.PolyCount" title="permalink">»</a>&nbsp;func (s *Shape) PolyCount() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) PolyCount() int</pre>
			<p>
Get the number of verts in a polygon shape.
</p>

		</span>
	
		
		<h1 id="Shape.PolyRadius" class="hdr pkg hdr-method"><a href="#Shape.PolyRadius" title="permalink">»</a>&nbsp;func (s *Shape) PolyRadius() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) PolyRadius() float64</pre>
			<p>
Get the radius of a polygon shape.
</p>

		</span>
	
		
		<h1 id="Shape.PolyShapeSetRadius" class="hdr pkg hdr-method"><a href="#Shape.PolyShapeSetRadius" title="permalink">»</a>&nbsp;func (shape *Shape) PolyShapeSetRadius(radius float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (shape *Shape) PolyShapeSetRadius(radius float64)</pre>
			<p>
Set the radius of a poly shape.
</p>
<p>
This function is used for mutating collision shapes. Chipmunk does not have
any way to get velocity information on changing shapes, so the results will
be unrealistic. This function is considered &#39;unsafe&#39; by Chipmunk.
</p>

		</span>
	
		
		<h1 id="Shape.PolyShapeSetVerts" class="hdr pkg hdr-method"><a href="#Shape.PolyShapeSetVerts" title="permalink">»</a>&nbsp;func (shape *Shape) PolyShapeSetVerts(verts []Vect, transform Transform) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (shape *Shape) PolyShapeSetVerts(verts []Vect, transform Transform)</pre>
			<p>
Set the vertexes of a poly shape.
</p>
<p>
This function is used for mutating collision shapes. Chipmunk does not have
any way to get velocity information on changing shapes, so the results will
be unrealistic. This function is considered &#39;unsafe&#39; by Chipmunk.
</p>

		</span>
	
		
		<h1 id="Shape.PolyShapeSetVertsRaw" class="hdr pkg hdr-method"><a href="#Shape.PolyShapeSetVertsRaw" title="permalink">»</a>&nbsp;func (shape *Shape) PolyShapeSetVertsRaw(verts []Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (shape *Shape) PolyShapeSetVertsRaw(verts []Vect)</pre>
			<p>
Set the vertexes of a poly shape.
</p>
<p>
This function is used for mutating collision shapes. Chipmunk does not have
any way to get velocity information on changing shapes, so the results will
be unrealistic. This function is considered &#39;unsafe&#39; by Chipmunk.
</p>

		</span>
	
		
		<h1 id="Shape.PolyVert" class="hdr pkg hdr-method"><a href="#Shape.PolyVert" title="permalink">»</a>&nbsp;func (s *Shape) PolyVert(index int) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) PolyVert(index int) Vect</pre>
			<p>
Get the ith vertex of a polygon shape.
</p>

		</span>
	
		
		<h1 id="Shape.SegmentA" class="hdr pkg hdr-method"><a href="#Shape.SegmentA" title="permalink">»</a>&nbsp;func (s *Shape) SegmentA() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SegmentA() Vect</pre>
			<p>
Get the first endpoint of a segment shape.
</p>

		</span>
	
		
		<h1 id="Shape.SegmentB" class="hdr pkg hdr-method"><a href="#Shape.SegmentB" title="permalink">»</a>&nbsp;func (s *Shape) SegmentB() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SegmentB() Vect</pre>
			<p>
Get the second endpoint of a segment shape.
</p>

		</span>
	
		
		<h1 id="Shape.SegmentNormal" class="hdr pkg hdr-method"><a href="#Shape.SegmentNormal" title="permalink">»</a>&nbsp;func (s *Shape) SegmentNormal() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SegmentNormal() Vect</pre>
			<p>
Get the normal of a segment shape.
</p>

		</span>
	
		
		<h1 id="Shape.SegmentQuery" class="hdr pkg hdr-method"><a href="#Shape.SegmentQuery" title="permalink">»</a>&nbsp;func (s *Shape) SegmentQuery(a, b Vect, radius float64) (info *SegmentQueryInfo, ret bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SegmentQuery(a, b Vect, radius float64) (info *SegmentQueryInfo, ret bool)</pre>
			<p>
Perform a segment query against a shape.
</p>

		</span>
	
		
		<h1 id="Shape.SegmentRadius" class="hdr pkg hdr-method"><a href="#Shape.SegmentRadius" title="permalink">»</a>&nbsp;func (s *Shape) SegmentRadius() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SegmentRadius() float64</pre>
			<p>
Get the first endpoint of a segment shape.
</p>

		</span>
	
		
		<h1 id="Shape.SegmentSetNeighbors" class="hdr pkg hdr-method"><a href="#Shape.SegmentSetNeighbors" title="permalink">»</a>&nbsp;func (s *Shape) SegmentSetNeighbors(prev, next Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SegmentSetNeighbors(prev, next Vect)</pre>
			<p>
Let Chipmunk know about the geometry of adjacent segments to avoid colliding with endcaps.
</p>

		</span>
	
		
		<h1 id="Shape.SegmentShapeSetEndpoints" class="hdr pkg hdr-method"><a href="#Shape.SegmentShapeSetEndpoints" title="permalink">»</a>&nbsp;func (shape *Shape) SegmentShapeSetEndpoints(a, b Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (shape *Shape) SegmentShapeSetEndpoints(a, b Vect)</pre>
			<p>
Set the endpoints of a segment shape.
</p>
<p>
This function is used for mutating collision shapes. Chipmunk does not have
any way to get velocity information on changing shapes, so the results will
be unrealistic. This function is considered &#39;unsafe&#39; by Chipmunk.
</p>

		</span>
	
		
		<h1 id="Shape.SegmentShapeSetRadius" class="hdr pkg hdr-method"><a href="#Shape.SegmentShapeSetRadius" title="permalink">»</a>&nbsp;func (shape *Shape) SegmentShapeSetRadius(radius float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (shape *Shape) SegmentShapeSetRadius(radius float64)</pre>
			<p>
Set the radius of a segment shape.
</p>
<p>
This function is used for mutating collision shapes. Chipmunk does not have
any way to get velocity information on changing shapes, so the results will
be unrealistic. This function is considered &#39;unsafe&#39; by Chipmunk.
</p>

		</span>
	
		
		<h1 id="Shape.Sensor" class="hdr pkg hdr-method"><a href="#Shape.Sensor" title="permalink">»</a>&nbsp;func (s *Shape) Sensor() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Sensor() bool</pre>
			<p>
Get if the shape is set to be a sensor or not.
</p>

		</span>
	
		
		<h1 id="Shape.SetBody" class="hdr pkg hdr-method"><a href="#Shape.SetBody" title="permalink">»</a>&nbsp;func (s *Shape) SetBody(b *Body) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetBody(b *Body)</pre>
			<p>
Set the cpBody this shape is connected to.
</p>
<p>
Can only be used if the shape is not currently added to a space.
</p>

		</span>
	
		
		<h1 id="Shape.SetCollisionType" class="hdr pkg hdr-method"><a href="#Shape.SetCollisionType" title="permalink">»</a>&nbsp;func (s *Shape) SetCollisionType(collisionType CollisionType) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetCollisionType(collisionType CollisionType)</pre>
			<p>
Set the collision type of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.SetDensity" class="hdr pkg hdr-method"><a href="#Shape.SetDensity" title="permalink">»</a>&nbsp;func (s *Shape) SetDensity(density float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetDensity(density float64)</pre>
			<p>
Set the density  of this shape to have Chipmunk calculate mass properties for you.
</p>

		</span>
	
		
		<h1 id="Shape.SetElasticity" class="hdr pkg hdr-method"><a href="#Shape.SetElasticity" title="permalink">»</a>&nbsp;func (s *Shape) SetElasticity(elasticity float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetElasticity(elasticity float64)</pre>
			<p>
Set the elasticity of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.SetFilter" class="hdr pkg hdr-method"><a href="#Shape.SetFilter" title="permalink">»</a>&nbsp;func (s *Shape) SetFilter(filter ShapeFilter) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetFilter(filter ShapeFilter)</pre>
			<p>
Set the collision filtering parameters of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.SetFriction" class="hdr pkg hdr-method"><a href="#Shape.SetFriction" title="permalink">»</a>&nbsp;func (s *Shape) SetFriction(friction float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetFriction(friction float64)</pre>
			<p>
Set the friction of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.SetMass" class="hdr pkg hdr-method"><a href="#Shape.SetMass" title="permalink">»</a>&nbsp;func (s *Shape) SetMass(mass float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetMass(mass float64)</pre>
			<p>
Set the mass of this shape to have Chipmunk calculate mass properties for you.
</p>

		</span>
	
		
		<h1 id="Shape.SetSensor" class="hdr pkg hdr-method"><a href="#Shape.SetSensor" title="permalink">»</a>&nbsp;func (s *Shape) SetSensor(sensor bool) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetSensor(sensor bool)</pre>
			<p>
Set if the shape is a sensor or not.
</p>

		</span>
	
		
		<h1 id="Shape.SetSurfaceVelocity" class="hdr pkg hdr-method"><a href="#Shape.SetSurfaceVelocity" title="permalink">»</a>&nbsp;func (s *Shape) SetSurfaceVelocity(surfaceVelocity Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetSurfaceVelocity(surfaceVelocity Vect)</pre>
			<p>
Set the surface velocity of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.SetUserData" class="hdr pkg hdr-method"><a href="#Shape.SetUserData" title="permalink">»</a>&nbsp;func (s *Shape) SetUserData(i interface{}) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SetUserData(i interface{})</pre>
			<p>
Set the user definable data pointer of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.ShapesCollide" class="hdr pkg hdr-method"><a href="#Shape.ShapesCollide" title="permalink">»</a>&nbsp;func (a *Shape) ShapesCollide(b *Shape) ContactPointSet <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (a *Shape) ShapesCollide(b *Shape) ContactPointSet</pre>
			<p>
Return contact information about two shapes.
</p>

		</span>
	
		
		<h1 id="Shape.Space" class="hdr pkg hdr-method"><a href="#Shape.Space" title="permalink">»</a>&nbsp;func (s *Shape) Space() *Space <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Space() *Space</pre>
			<p>
The cpSpace this body is added to.
</p>

		</span>
	
		
		<h1 id="Shape.SurfaceVelocity" class="hdr pkg hdr-method"><a href="#Shape.SurfaceVelocity" title="permalink">»</a>&nbsp;func (s *Shape) SurfaceVelocity() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) SurfaceVelocity() Vect</pre>
			<p>
Get the surface velocity of this shape.
</p>

		</span>
	
		
		<h1 id="Shape.Update" class="hdr pkg hdr-method"><a href="#Shape.Update" title="permalink">»</a>&nbsp;func (s *Shape) Update(transform Transform) BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) Update(transform Transform) BB</pre>
			<p>
Update, cache and return the bounding box of a shape with an explicit transformation.
</p>

		</span>
	
		
		<h1 id="Shape.UserData" class="hdr pkg hdr-method"><a href="#Shape.UserData" title="permalink">»</a>&nbsp;func (s *Shape) UserData() interface{} <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Shape) UserData() interface{}</pre>
			<p>
Get the user definable data interface of this shape.
</p>

		</span>
	

	
	<h1 id="ShapeFilter" class="hdr pkg hdr-type"><a href="#ShapeFilter" title="permalink">»</a>&nbsp;type ShapeFilter <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type ShapeFilter struct {
	Group		Group
	Categories	Bitmask
	Mask		Bitmask
}</pre>
		
	</span>

	
	
		<h1 id="ShapeFilterNew" class="hdr pkg hdr-function"><a href="#ShapeFilterNew" title="permalink">»</a>&nbsp;func ShapeFilterNew(group Group, categories, mask Bitmask) ShapeFilter <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func ShapeFilterNew(group Group, categories, mask Bitmask) ShapeFilter</pre>
			
		</span>
	

	
	

	
	<h1 id="SimpleMotorJoint" class="hdr pkg hdr-type"><a href="#SimpleMotorJoint" title="permalink">»</a>&nbsp;type SimpleMotorJoint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SimpleMotorJoint C.cpSimpleMotorJoint</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SlideJoint" class="hdr pkg hdr-type"><a href="#SlideJoint" title="permalink">»</a>&nbsp;type SlideJoint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SlideJoint C.cpSlideJoint</pre>
		
	</span>

	
	

	
	

	
	<h1 id="Space" class="hdr pkg hdr-type"><a href="#Space" title="permalink">»</a>&nbsp;type Space <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Space struct {
	// contains filtered or unexported fields
}</pre>
		
	</span>

	
	
		<h1 id="SpaceNew" class="hdr pkg hdr-function"><a href="#SpaceNew" title="permalink">»</a>&nbsp;func SpaceNew() *Space <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func SpaceNew() *Space</pre>
			<p>
Allocate and initialize a cpSpace.
</p>

		</span>
	

	
	
		
		<h1 id="Space.AddBody" class="hdr pkg hdr-method"><a href="#Space.AddBody" title="permalink">»</a>&nbsp;func (s *Space) AddBody(body *Body) *Body <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) AddBody(body *Body) *Body</pre>
			<p>
Add a rigid body to the simulation.
</p>

		</span>
	
		
		<h1 id="Space.AddCollisionHandler" class="hdr pkg hdr-method"><a href="#Space.AddCollisionHandler" title="permalink">»</a>&nbsp;func (s *Space) AddCollisionHandler(a, b CollisionType, handler *CollisionHandler) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) AddCollisionHandler(a, b CollisionType, handler *CollisionHandler)</pre>
			
		</span>
	
		
		<h1 id="Space.AddConstraint" class="hdr pkg hdr-method"><a href="#Space.AddConstraint" title="permalink">»</a>&nbsp;func (s *Space) AddConstraint(constraint *Constraint) *Constraint <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) AddConstraint(constraint *Constraint) *Constraint</pre>
			<p>
Add a constraint to the simulation.
</p>

		</span>
	
		
		<h1 id="Space.AddDefaultCollisionHandler" class="hdr pkg hdr-method"><a href="#Space.AddDefaultCollisionHandler" title="permalink">»</a>&nbsp;func (s *Space) AddDefaultCollisionHandler() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) AddDefaultCollisionHandler()</pre>
			
		</span>
	
		
		<h1 id="Space.AddPostStepCallback" class="hdr pkg hdr-method"><a href="#Space.AddPostStepCallback" title="permalink">»</a>&nbsp;func (s *Space) AddPostStepCallback(f func()) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) AddPostStepCallback(f func())</pre>
			<p>
Schedule a post-step callback to be called when space.Step() finishes.
</p>

		</span>
	
		
		<h1 id="Space.AddShape" class="hdr pkg hdr-method"><a href="#Space.AddShape" title="permalink">»</a>&nbsp;func (s *Space) AddShape(shape *Shape) *Shape <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) AddShape(shape *Shape) *Shape</pre>
			<p>
Add a collision shape to the simulation.
</p>
<p>
If the shape is attached to a static body, it will be added as a static shape.
</p>

		</span>
	
		
		<h1 id="Space.AddWildcardHandler" class="hdr pkg hdr-method"><a href="#Space.AddWildcardHandler" title="permalink">»</a>&nbsp;func (s *Space) AddWildcardHandler(t CollisionType, handler *CollisionHandler) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) AddWildcardHandler(t CollisionType, handler *CollisionHandler)</pre>
			
		</span>
	
		
		<h1 id="Space.BBQuery" class="hdr pkg hdr-method"><a href="#Space.BBQuery" title="permalink">»</a>&nbsp;func (s *Space) BBQuery(bb BB, filter ShapeFilter, f SpaceBBQueryFunc, data interface{}) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) BBQuery(bb BB, filter ShapeFilter, f SpaceBBQueryFunc, data interface{})</pre>
			<p>
Perform a fast rectangle query on the space calling  func for each shape found.
</p>
<p>
Only the shape&#39;s bounding boxes are checked for overlap, not their full shape.
</p>

		</span>
	
		
		<h1 id="Space.CollisionBias" class="hdr pkg hdr-method"><a href="#Space.CollisionBias" title="permalink">»</a>&nbsp;func (s *Space) CollisionBias() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) CollisionBias() float64</pre>
			<p>
Determines how fast overlapping shapes are pushed apart.
Expressed as a fraction of the error remaining after each second.
Defaults to pow(1.0 - 0.1, 60.0) meaning that Chipmunk fixes 10% of overlap each frame at 60Hz.
</p>

		</span>
	
		
		<h1 id="Space.CollisionPersistence" class="hdr pkg hdr-method"><a href="#Space.CollisionPersistence" title="permalink">»</a>&nbsp;func (s *Space) CollisionPersistence() Timestamp <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) CollisionPersistence() Timestamp</pre>
			<p>
Number of frames that contact information should persist.
</p>
<p>
Defaults to 3. There is probably never a reason to change this value.
</p>

		</span>
	
		
		<h1 id="Space.CollisionSlop" class="hdr pkg hdr-method"><a href="#Space.CollisionSlop" title="permalink">»</a>&nbsp;func (s *Space) CollisionSlop() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) CollisionSlop() float64</pre>
			<p>
Amount of encouraged penetration between colliding shapes.
</p>
<p>
Used to reduce oscillating contacts and keep the collision cache warm.
</p>
<p>
Defaults to 0.1. If you have poor simulation quality,
increase this number as much as possible without allowing visible amounts of overlap.
</p>

		</span>
	
		
		<h1 id="Space.ContainsBody" class="hdr pkg hdr-method"><a href="#Space.ContainsBody" title="permalink">»</a>&nbsp;func (s *Space) ContainsBody(body *Body) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) ContainsBody(body *Body) bool</pre>
			<p>
Test if a rigid body has been added to the space.
</p>

		</span>
	
		
		<h1 id="Space.ContainsConstraint" class="hdr pkg hdr-method"><a href="#Space.ContainsConstraint" title="permalink">»</a>&nbsp;func (s *Space) ContainsConstraint(constraint *Constraint) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) ContainsConstraint(constraint *Constraint) bool</pre>
			<p>
Test if a constraint has been added to the space.
</p>

		</span>
	
		
		<h1 id="Space.ContainsShape" class="hdr pkg hdr-method"><a href="#Space.ContainsShape" title="permalink">»</a>&nbsp;func (s *Space) ContainsShape(shape *Shape) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) ContainsShape(shape *Shape) bool</pre>
			<p>
Test if a collision shape has been added to the space.
</p>

		</span>
	
		
		<h1 id="Space.CurrentTimeStep" class="hdr pkg hdr-method"><a href="#Space.CurrentTimeStep" title="permalink">»</a>&nbsp;func (s *Space) CurrentTimeStep() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) CurrentTimeStep() float64</pre>
			<p>
Returns the current (or most recent) time step used with the given space.
Useful from callbacks if your time step is not a compile-time global.
</p>

		</span>
	
		
		<h1 id="Space.Damping" class="hdr pkg hdr-method"><a href="#Space.Damping" title="permalink">»</a>&nbsp;func (s *Space) Damping() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) Damping() float64</pre>
			<p>
Damping rate expressed as the fraction of velocity bodies retain each second.
</p>
<p>
A value of 0.9 would mean that each body&#39;s velocity will drop 10% per second.
</p>
<p>
The default value is 1.0, meaning no damping is applied.
</p>
<p>
This damping value is different than those of cpDampedSpring and cpDampedRotarySpring.
</p>

		</span>
	
		
		<h1 id="Space.DebugDraw" class="hdr pkg hdr-method"><a href="#Space.DebugDraw" title="permalink">»</a>&nbsp;func (s *Space) DebugDraw(options *SpaceDebugDrawOptions) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) DebugDraw(options *SpaceDebugDrawOptions)</pre>
			<p>
DebugDraw draws the space using the debug draw options (which includes
callbacks for performing the actual drawing). All options fields are
entirely optional (callbacks may be nil, etc).
</p>
<p>
options.Data is arbitrary user data fed into the callbacks (this is just for
a 1:1 mapping of chipmunks API, in Go you can just use a closure and access
the data itself not storing it inside options.Data).
</p>

		</span>
	
		
		<h1 id="Space.EachBody" class="hdr pkg hdr-method"><a href="#Space.EachBody" title="permalink">»</a>&nbsp;func (s *Space) EachBody(space *Space, f func(b *Body)) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) EachBody(space *Space, f func(b *Body))</pre>
			<p>
Space/body iterator callback function type.
</p>

		</span>
	
		
		<h1 id="Space.EachConstraint" class="hdr pkg hdr-method"><a href="#Space.EachConstraint" title="permalink">»</a>&nbsp;func (s *Space) EachConstraint(space *Space, f func(c *Constraint)) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) EachConstraint(space *Space, f func(c *Constraint))</pre>
			<p>
Call f for each shape in the space.
</p>

		</span>
	
		
		<h1 id="Space.EachShape" class="hdr pkg hdr-method"><a href="#Space.EachShape" title="permalink">»</a>&nbsp;func (s *Space) EachShape(space *Space, f func(s *Shape)) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) EachShape(space *Space, f func(s *Shape))</pre>
			<p>
Call f for each shape in the space.
</p>

		</span>
	
		
		<h1 id="Space.Free" class="hdr pkg hdr-method"><a href="#Space.Free" title="permalink">»</a>&nbsp;func (s *Space) Free() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) Free()</pre>
			<p>
Free is deprecated. Do not use it, it is no-op.
</p>

		</span>
	
		
		<h1 id="Space.Gravity" class="hdr pkg hdr-method"><a href="#Space.Gravity" title="permalink">»</a>&nbsp;func (s *Space) Gravity() Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) Gravity() Vect</pre>
			<p>
Gravity to pass to rigid bodies when integrating velocity.
</p>

		</span>
	
		
		<h1 id="Space.IdleSpeedThreshold" class="hdr pkg hdr-method"><a href="#Space.IdleSpeedThreshold" title="permalink">»</a>&nbsp;func (s *Space) IdleSpeedThreshold() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) IdleSpeedThreshold() float64</pre>
			<p>
Speed threshold for a body to be considered idle.
</p>
<p>
The default value of 0 means to let the space guess a good threshold based
on gravity.
</p>

		</span>
	
		
		<h1 id="Space.IsLocked" class="hdr pkg hdr-method"><a href="#Space.IsLocked" title="permalink">»</a>&nbsp;func (s *Space) IsLocked() bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) IsLocked() bool</pre>
			<p>
returns true from inside a callback when objects cannot be added/removed.
</p>

		</span>
	
		
		<h1 id="Space.Iterations" class="hdr pkg hdr-method"><a href="#Space.Iterations" title="permalink">»</a>&nbsp;func (s *Space) Iterations() int <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) Iterations() int</pre>
			<p>
Number of iterations to use in the impulse solver to solve contacts and
other constraints.
</p>

		</span>
	
		
		<h1 id="Space.PointQuery" class="hdr pkg hdr-method"><a href="#Space.PointQuery" title="permalink">»</a>&nbsp;func (s *Space) PointQuery(point Vect, maxDistance float64, filter ShapeFilter, f SpacePointQueryFunc, data interface{}) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) PointQuery(point Vect, maxDistance float64, filter ShapeFilter, f SpacePointQueryFunc, data interface{})</pre>
			<p>
Query the space at a point and call f for each shape found.
</p>

		</span>
	
		
		<h1 id="Space.PointQueryNearest" class="hdr pkg hdr-method"><a href="#Space.PointQueryNearest" title="permalink">»</a>&nbsp;func (s *Space) PointQueryNearest(point Vect, maxDistance float64, filter ShapeFilter) (shape *Shape, out *PointQueryInfo) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) PointQueryNearest(point Vect, maxDistance float64, filter ShapeFilter) (shape *Shape, out *PointQueryInfo)</pre>
			<p>
Query the space at a point and return the nearest shape found. Returns NULL if no shapes were found.
</p>

		</span>
	
		
		<h1 id="Space.ReindexShape" class="hdr pkg hdr-method"><a href="#Space.ReindexShape" title="permalink">»</a>&nbsp;func (s *Space) ReindexShape(shape *Shape) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) ReindexShape(shape *Shape)</pre>
			<p>
Update the collision detection data for a specific shape in the space.
</p>

		</span>
	
		
		<h1 id="Space.ReindexShapesForBody" class="hdr pkg hdr-method"><a href="#Space.ReindexShapesForBody" title="permalink">»</a>&nbsp;func (s *Space) ReindexShapesForBody(body *Body) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) ReindexShapesForBody(body *Body)</pre>
			<p>
Update the collision detection data for all shapes attached to a body.
</p>

		</span>
	
		
		<h1 id="Space.ReindexStatic" class="hdr pkg hdr-method"><a href="#Space.ReindexStatic" title="permalink">»</a>&nbsp;func (s *Space) ReindexStatic() <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) ReindexStatic()</pre>
			<p>
Update the collision detection info for the static shapes in the space.
</p>

		</span>
	
		
		<h1 id="Space.RemoveBody" class="hdr pkg hdr-method"><a href="#Space.RemoveBody" title="permalink">»</a>&nbsp;func (s *Space) RemoveBody(body *Body) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) RemoveBody(body *Body)</pre>
			<p>
Remove a rigid body from the simulation.
</p>

		</span>
	
		
		<h1 id="Space.RemoveConstraint" class="hdr pkg hdr-method"><a href="#Space.RemoveConstraint" title="permalink">»</a>&nbsp;func (s *Space) RemoveConstraint(constraint *Constraint) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) RemoveConstraint(constraint *Constraint)</pre>
			<p>
Remove a constraint from the simulation.
</p>

		</span>
	
		
		<h1 id="Space.RemoveShape" class="hdr pkg hdr-method"><a href="#Space.RemoveShape" title="permalink">»</a>&nbsp;func (s *Space) RemoveShape(shape *Shape) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) RemoveShape(shape *Shape)</pre>
			<p>
Remove a collision shape from the simulation.
</p>

		</span>
	
		
		<h1 id="Space.SegmentQuery" class="hdr pkg hdr-method"><a href="#Space.SegmentQuery" title="permalink">»</a>&nbsp;func (s *Space) SegmentQuery(start, end Vect, radius float64, filter ShapeFilter, f SpaceSegmentQueryFunc, data interface{}) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SegmentQuery(start, end Vect, radius float64, filter ShapeFilter, f SpaceSegmentQueryFunc, data interface{})</pre>
			<p>
Perform a directed line segment query (like a raycast) against the space
calling f for each shape intersected.
</p>

		</span>
	
		
		<h1 id="Space.SegmentQueryFirst" class="hdr pkg hdr-method"><a href="#Space.SegmentQueryFirst" title="permalink">»</a>&nbsp;func (s *Space) SegmentQueryFirst(start, end Vect, radius float64, filter ShapeFilter) (shape *Shape, out *SegmentQueryInfo) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SegmentQueryFirst(start, end Vect, radius float64, filter ShapeFilter) (shape *Shape, out *SegmentQueryInfo)</pre>
			<p>
Perform a directed line segment query (like a raycast) against the space and return the first shape hit. Returns NULL if no shapes were hit.
</p>

		</span>
	
		
		<h1 id="Space.SetCollisionBias" class="hdr pkg hdr-method"><a href="#Space.SetCollisionBias" title="permalink">»</a>&nbsp;func (s *Space) SetCollisionBias(collisionBias float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SetCollisionBias(collisionBias float64)</pre>
			
		</span>
	
		
		<h1 id="Space.SetCollisionPersistence" class="hdr pkg hdr-method"><a href="#Space.SetCollisionPersistence" title="permalink">»</a>&nbsp;func (s *Space) SetCollisionPersistence(collisionPersistence Timestamp) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SetCollisionPersistence(collisionPersistence Timestamp)</pre>
			
		</span>
	
		
		<h1 id="Space.SetCollisionSlop" class="hdr pkg hdr-method"><a href="#Space.SetCollisionSlop" title="permalink">»</a>&nbsp;func (s *Space) SetCollisionSlop(collisionSlop float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SetCollisionSlop(collisionSlop float64)</pre>
			
		</span>
	
		
		<h1 id="Space.SetDamping" class="hdr pkg hdr-method"><a href="#Space.SetDamping" title="permalink">»</a>&nbsp;func (s *Space) SetDamping(damping float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SetDamping(damping float64)</pre>
			
		</span>
	
		
		<h1 id="Space.SetGravity" class="hdr pkg hdr-method"><a href="#Space.SetGravity" title="permalink">»</a>&nbsp;func (s *Space) SetGravity(gravity Vect) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SetGravity(gravity Vect)</pre>
			
		</span>
	
		
		<h1 id="Space.SetIdleSpeedThreshold" class="hdr pkg hdr-method"><a href="#Space.SetIdleSpeedThreshold" title="permalink">»</a>&nbsp;func (s *Space) SetIdleSpeedThreshold(idleSpeedThreshold float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SetIdleSpeedThreshold(idleSpeedThreshold float64)</pre>
			
		</span>
	
		
		<h1 id="Space.SetIterations" class="hdr pkg hdr-method"><a href="#Space.SetIterations" title="permalink">»</a>&nbsp;func (s *Space) SetIterations(iterations int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SetIterations(iterations int)</pre>
			
		</span>
	
		
		<h1 id="Space.SetSleepTimeThreshold" class="hdr pkg hdr-method"><a href="#Space.SetSleepTimeThreshold" title="permalink">»</a>&nbsp;func (s *Space) SetSleepTimeThreshold(sleepTimeThreshold float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SetSleepTimeThreshold(sleepTimeThreshold float64)</pre>
			
		</span>
	
		
		<h1 id="Space.SetUserData" class="hdr pkg hdr-method"><a href="#Space.SetUserData" title="permalink">»</a>&nbsp;func (s *Space) SetUserData(i interface{}) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SetUserData(i interface{})</pre>
			
		</span>
	
		
		<h1 id="Space.ShapeQuery" class="hdr pkg hdr-method"><a href="#Space.ShapeQuery" title="permalink">»</a>&nbsp;func (s *Space) ShapeQuery(shape *Shape, f SpaceShapeQueryFunc, data interface{}) bool <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) ShapeQuery(shape *Shape, f SpaceShapeQueryFunc, data interface{}) bool</pre>
			<p>
Query a space for any shapes overlapping the given shape and call  func for each shape found.
</p>

		</span>
	
		
		<h1 id="Space.SleepTimeThreshold" class="hdr pkg hdr-method"><a href="#Space.SleepTimeThreshold" title="permalink">»</a>&nbsp;func (s *Space) SleepTimeThreshold() float64 <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) SleepTimeThreshold() float64</pre>
			<p>
Time a group of bodies must remain idle in order to fall asleep.
</p>
<p>
Enabling sleeping also implicitly enables the the contact graph.
</p>
<p>
The default value of INFINITY disables the sleeping algorithm.
</p>

		</span>
	
		
		<h1 id="Space.StaticBody" class="hdr pkg hdr-method"><a href="#Space.StaticBody" title="permalink">»</a>&nbsp;func (s *Space) StaticBody() *Body <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) StaticBody() *Body</pre>
			<p>
The Space provided static body for a given cpSpace.
</p>
<p>
This is merely provided for convenience and you are not required to use it.
</p>

		</span>
	
		
		<h1 id="Space.Step" class="hdr pkg hdr-method"><a href="#Space.Step" title="permalink">»</a>&nbsp;func (s *Space) Step(dt float64) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) Step(dt float64)</pre>
			<p>
Step the space forward in time by dt.
</p>

		</span>
	
		
		<h1 id="Space.UseSpatialHash" class="hdr pkg hdr-method"><a href="#Space.UseSpatialHash" title="permalink">»</a>&nbsp;func (s *Space) UseSpatialHash(dim float64, count int) <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) UseSpatialHash(dim float64, count int)</pre>
			<p>
Switch the space to use a spatial has as it&#39;s spatial index.
</p>

		</span>
	
		
		<h1 id="Space.UserData" class="hdr pkg hdr-method"><a href="#Space.UserData" title="permalink">»</a>&nbsp;func (s *Space) UserData() interface{} <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (s *Space) UserData() interface{}</pre>
			<p>
User definable data interface.
</p>
<p>
Generally this points to your game&#39;s controller or game state
class so you can access it when given a cpSpace reference in a callback.
</p>

		</span>
	

	
	<h1 id="SpaceArbiterApplyImpulseFunc" class="hdr pkg hdr-type"><a href="#SpaceArbiterApplyImpulseFunc" title="permalink">»</a>&nbsp;type SpaceArbiterApplyImpulseFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceArbiterApplyImpulseFunc func(arb *Arbiter)</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpaceBBQueryFunc" class="hdr pkg hdr-type"><a href="#SpaceBBQueryFunc" title="permalink">»</a>&nbsp;type SpaceBBQueryFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceBBQueryFunc func(shape *Shape, data interface{})</pre>
		<p>
Rectangle Query callback function type.
</p>

	</span>

	
	

	
	

	
	<h1 id="SpaceDebugColor" class="hdr pkg hdr-type"><a href="#SpaceDebugColor" title="permalink">»</a>&nbsp;type SpaceDebugColor <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceDebugColor C.cpSpaceDebugColor</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpaceDebugDrawCircleImpl" class="hdr pkg hdr-type"><a href="#SpaceDebugDrawCircleImpl" title="permalink">»</a>&nbsp;type SpaceDebugDrawCircleImpl <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceDebugDrawCircleImpl func(pos Vect, angle, radius float64, outlineColor, fillColor SpaceDebugColor, data interface{})</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpaceDebugDrawColorForShapeImpl" class="hdr pkg hdr-type"><a href="#SpaceDebugDrawColorForShapeImpl" title="permalink">»</a>&nbsp;type SpaceDebugDrawColorForShapeImpl <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceDebugDrawColorForShapeImpl func(shape *Shape, data interface{}) SpaceDebugColor</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpaceDebugDrawDotImpl" class="hdr pkg hdr-type"><a href="#SpaceDebugDrawDotImpl" title="permalink">»</a>&nbsp;type SpaceDebugDrawDotImpl <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceDebugDrawDotImpl func(size float64, pos Vect, color SpaceDebugColor, data interface{})</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpaceDebugDrawFatSegmentImpl" class="hdr pkg hdr-type"><a href="#SpaceDebugDrawFatSegmentImpl" title="permalink">»</a>&nbsp;type SpaceDebugDrawFatSegmentImpl <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceDebugDrawFatSegmentImpl func(a, b Vect, radius float64, outlineColor, fillColor SpaceDebugColor, data interface{})</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpaceDebugDrawFlags" class="hdr pkg hdr-type"><a href="#SpaceDebugDrawFlags" title="permalink">»</a>&nbsp;type SpaceDebugDrawFlags <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceDebugDrawFlags int</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpaceDebugDrawOptions" class="hdr pkg hdr-type"><a href="#SpaceDebugDrawOptions" title="permalink">»</a>&nbsp;type SpaceDebugDrawOptions <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceDebugDrawOptions struct {
	DrawCircle	SpaceDebugDrawCircleImpl
	DrawSegment	SpaceDebugDrawSegmentImpl
	DrawFatSegment	SpaceDebugDrawFatSegmentImpl
	DrawPolygon	SpaceDebugDrawPolygonImpl
	DrawDot		SpaceDebugDrawDotImpl

	ColorForShape	SpaceDebugDrawColorForShapeImpl

	Flags			SpaceDebugDrawFlags
	ShapeOutlineColor	SpaceDebugColor
	ConstraintColor		SpaceDebugColor
	CollisionPointColor	SpaceDebugColor

	Data	interface{}
}</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpaceDebugDrawPolygonImpl" class="hdr pkg hdr-type"><a href="#SpaceDebugDrawPolygonImpl" title="permalink">»</a>&nbsp;type SpaceDebugDrawPolygonImpl <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceDebugDrawPolygonImpl func(verts []Vect, radius float64, outlineColor, fillColor SpaceDebugColor, data interface{})</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpaceDebugDrawSegmentImpl" class="hdr pkg hdr-type"><a href="#SpaceDebugDrawSegmentImpl" title="permalink">»</a>&nbsp;type SpaceDebugDrawSegmentImpl <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceDebugDrawSegmentImpl func(a, b Vect, color SpaceDebugColor, data interface{})</pre>
		
	</span>

	
	

	
	

	
	<h1 id="SpacePointQueryFunc" class="hdr pkg hdr-type"><a href="#SpacePointQueryFunc" title="permalink">»</a>&nbsp;type SpacePointQueryFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpacePointQueryFunc func(shape *Shape, point Vect, distance float64, gradient Vect, data interface{})</pre>
		<p>
Nearest point query callback function type.
</p>

	</span>

	
	

	
	

	
	<h1 id="SpaceSegmentQueryFunc" class="hdr pkg hdr-type"><a href="#SpaceSegmentQueryFunc" title="permalink">»</a>&nbsp;type SpaceSegmentQueryFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceSegmentQueryFunc func(shape *Shape, point, normal Vect, alpha float64, data interface{})</pre>
		<p>
Nearest point query callback function type.
</p>

	</span>

	
	

	
	

	
	<h1 id="SpaceShapeQueryFunc" class="hdr pkg hdr-type"><a href="#SpaceShapeQueryFunc" title="permalink">»</a>&nbsp;type SpaceShapeQueryFunc <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type SpaceShapeQueryFunc func(shape *Shape, points *ContactPointSet, data interface{})</pre>
		<p>
Shape query callback function type.
</p>

	</span>

	
	

	
	

	
	<h1 id="Timestamp" class="hdr pkg hdr-type"><a href="#Timestamp" title="permalink">»</a>&nbsp;type Timestamp <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Timestamp C.cpTimestamp</pre>
		<p>
Type used for various timestamps in Chipmunk.
</p>

	</span>

	
	

	
	

	
	<h1 id="Transform" class="hdr pkg hdr-type"><a href="#Transform" title="permalink">»</a>&nbsp;type Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Transform C.cpTransform</pre>
		<p>
Column major affine transform.
</p>

	</span>

	
	
		<h1 id="TransformAxialScale" class="hdr pkg hdr-function"><a href="#TransformAxialScale" title="permalink">»</a>&nbsp;func TransformAxialScale(axis, pivot Vect, scale float64) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func TransformAxialScale(axis, pivot Vect, scale float64) Transform</pre>
			
		</span>
	
		<h1 id="TransformBoneScale" class="hdr pkg hdr-function"><a href="#TransformBoneScale" title="permalink">»</a>&nbsp;func TransformBoneScale(v0, v1 Vect) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func TransformBoneScale(v0, v1 Vect) Transform</pre>
			
		</span>
	
		<h1 id="TransformNew" class="hdr pkg hdr-function"><a href="#TransformNew" title="permalink">»</a>&nbsp;func TransformNew(a, b, c, d, tx, ty float64) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func TransformNew(a, b, c, d, tx, ty float64) Transform</pre>
			<p>
Construct a new transform matrix.
</p>
<p>
(a, b) is the x basis vector.
</p>
<p>
(c, d) is the y basis vector.
</p>
<p>
(tx, ty) is the translation.
</p>

		</span>
	
		<h1 id="TransformNewTranspose" class="hdr pkg hdr-function"><a href="#TransformNewTranspose" title="permalink">»</a>&nbsp;func TransformNewTranspose(a, c, tx, b, d, ty float64) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func TransformNewTranspose(a, c, tx, b, d, ty float64) Transform</pre>
			<p>
Construct a new transform matrix in transposed order.
</p>

		</span>
	
		<h1 id="TransformOrtho" class="hdr pkg hdr-function"><a href="#TransformOrtho" title="permalink">»</a>&nbsp;func TransformOrtho(bb BB) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func TransformOrtho(bb BB) Transform</pre>
			
		</span>
	
		<h1 id="TransformRigid" class="hdr pkg hdr-function"><a href="#TransformRigid" title="permalink">»</a>&nbsp;func TransformRigid(translate Vect, radians float64) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func TransformRigid(translate Vect, radians float64) Transform</pre>
			<p>
Create a rigid transformation matrix. (translation + rotation)
</p>

		</span>
	
		<h1 id="TransformRotate" class="hdr pkg hdr-function"><a href="#TransformRotate" title="permalink">»</a>&nbsp;func TransformRotate(radians float64) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func TransformRotate(radians float64) Transform</pre>
			<p>
Create a rotation matrix.
</p>

		</span>
	
		<h1 id="TransformScale" class="hdr pkg hdr-function"><a href="#TransformScale" title="permalink">»</a>&nbsp;func TransformScale(scaleX, scaleY float64) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func TransformScale(scaleX, scaleY float64) Transform</pre>
			<p>
Create a scale matrix.
</p>

		</span>
	
		<h1 id="TransformTranslate" class="hdr pkg hdr-function"><a href="#TransformTranslate" title="permalink">»</a>&nbsp;func TransformTranslate(translate Vect) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func TransformTranslate(translate Vect) Transform</pre>
			<p>
Create a translation matrix.
</p>

		</span>
	

	
	
		
		<h1 id="Transform.BB" class="hdr pkg hdr-method"><a href="#Transform.BB" title="permalink">»</a>&nbsp;func (t Transform) BB(bb BB) BB <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t Transform) BB(bb BB) BB</pre>
			<p>
Transform a BB.
</p>

		</span>
	
		
		<h1 id="Transform.Inverse" class="hdr pkg hdr-method"><a href="#Transform.Inverse" title="permalink">»</a>&nbsp;func (t Transform) Inverse() Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t Transform) Inverse() Transform</pre>
			<p>
Get the inverse of a transform matrix.
</p>

		</span>
	
		
		<h1 id="Transform.Mult" class="hdr pkg hdr-method"><a href="#Transform.Mult" title="permalink">»</a>&nbsp;func (t1 Transform) Mult(t2 Transform) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t1 Transform) Mult(t2 Transform) Transform</pre>
			<p>
Multiply two transformation matrices.
</p>

		</span>
	
		
		<h1 id="Transform.Point" class="hdr pkg hdr-method"><a href="#Transform.Point" title="permalink">»</a>&nbsp;func (t Transform) Point(p Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t Transform) Point(p Vect) Vect</pre>
			<p>
Transform an absolute point. (i.e. a vertex)
</p>

		</span>
	
		
		<h1 id="Transform.RigidInverse" class="hdr pkg hdr-method"><a href="#Transform.RigidInverse" title="permalink">»</a>&nbsp;func (t Transform) RigidInverse() Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t Transform) RigidInverse() Transform</pre>
			<p>
Fast inverse of a rigid transformation matrix.
</p>

		</span>
	
		
		<h1 id="Transform.Vect" class="hdr pkg hdr-method"><a href="#Transform.Vect" title="permalink">»</a>&nbsp;func (t Transform) Vect(v Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (t Transform) Vect(v Vect) Vect</pre>
			<p>
Transform a vector (i.e. a normal)
</p>

		</span>
	
		
		<h1 id="Transform.Wrap" class="hdr pkg hdr-method"><a href="#Transform.Wrap" title="permalink">»</a>&nbsp;func (outer Transform) Wrap(inner Transform) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (outer Transform) Wrap(inner Transform) Transform</pre>
			
		</span>
	
		
		<h1 id="Transform.WrapInverse" class="hdr pkg hdr-method"><a href="#Transform.WrapInverse" title="permalink">»</a>&nbsp;func (outer Transform) WrapInverse(inner Transform) Transform <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg method">
			<pre>func (outer Transform) WrapInverse(inner Transform) Transform</pre>
			
		</span>
	

	
	<h1 id="Vect" class="hdr pkg hdr-type"><a href="#Vect" title="permalink">»</a>&nbsp;type Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg type">
		<pre>type Vect C.cpVect</pre>
		<p>
Chipmunk&#39;s 2D vector type.
</p>

	</span>

	
	
		<h1 id="CentroidForPoly" class="hdr pkg hdr-function"><a href="#CentroidForPoly" title="permalink">»</a>&nbsp;func CentroidForPoly(verts []Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func CentroidForPoly(verts []Vect) Vect</pre>
			<p>
Calculate the natural centroid of a polygon.
</p>

		</span>
	
		<h1 id="ClosetPointOnSegment" class="hdr pkg hdr-function"><a href="#ClosetPointOnSegment" title="permalink">»</a>&nbsp;func ClosetPointOnSegment(p, a, b Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func ClosetPointOnSegment(p, a, b Vect) Vect</pre>
			<p>
Returns the closest point on the line segment ab, to the point p.
</p>

		</span>
	
		<h1 id="V" class="hdr pkg hdr-function"><a href="#V" title="permalink">»</a>&nbsp;func V(x, y float64) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func V(x, y float64) Vect</pre>
			<p>
Convenience constructor for cpVect structs.
</p>

		</span>
	
		<h1 id="Vadd" class="hdr pkg hdr-function"><a href="#Vadd" title="permalink">»</a>&nbsp;func Vadd(v1, v2 Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vadd(v1, v2 Vect) Vect</pre>
			<p>
Add two vectors
</p>

		</span>
	
		<h1 id="Vdot" class="hdr pkg hdr-function"><a href="#Vdot" title="permalink">»</a>&nbsp;func Vdot(v1, v2 Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vdot(v1, v2 Vect) Vect</pre>
			<p>
Vector dot product.
</p>

		</span>
	
		<h1 id="Vforangle" class="hdr pkg hdr-function"><a href="#Vforangle" title="permalink">»</a>&nbsp;func Vforangle(a float64) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vforangle(a float64) Vect</pre>
			<p>
Returns the unit length vector for the given angle (in radians).
</p>

		</span>
	
		<h1 id="Vlerp" class="hdr pkg hdr-function"><a href="#Vlerp" title="permalink">»</a>&nbsp;func Vlerp(v1, v2 Vect, t float64) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vlerp(v1, v2 Vect, t float64) Vect</pre>
			<p>
Linearly interpolate between v1 and v2.
</p>

		</span>
	
		<h1 id="Vlerpconst" class="hdr pkg hdr-function"><a href="#Vlerpconst" title="permalink">»</a>&nbsp;func Vlerpconst(v1, v2 Vect, d float64) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vlerpconst(v1, v2 Vect, d float64) Vect</pre>
			<p>
Linearly interpolate between v1 towards v2 by distance d.
</p>

		</span>
	
		<h1 id="Vmult" class="hdr pkg hdr-function"><a href="#Vmult" title="permalink">»</a>&nbsp;func Vmult(v Vect, s float64) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vmult(v Vect, s float64) Vect</pre>
			<p>
Scalar multiplication.
</p>

		</span>
	
		<h1 id="Vneg" class="hdr pkg hdr-function"><a href="#Vneg" title="permalink">»</a>&nbsp;func Vneg(v Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vneg(v Vect) Vect</pre>
			<p>
Negate a vector.
</p>

		</span>
	
		<h1 id="Vnormalize" class="hdr pkg hdr-function"><a href="#Vnormalize" title="permalink">»</a>&nbsp;func Vnormalize(v Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vnormalize(v Vect) Vect</pre>
			<p>
Returns a normalized copy of v.
</p>

		</span>
	
		<h1 id="Vperp" class="hdr pkg hdr-function"><a href="#Vperp" title="permalink">»</a>&nbsp;func Vperp(v Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vperp(v Vect) Vect</pre>
			<p>
Returns a perpendicular vector. (90 degree rotation)
</p>

		</span>
	
		<h1 id="Vproject" class="hdr pkg hdr-function"><a href="#Vproject" title="permalink">»</a>&nbsp;func Vproject(v1, v2 Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vproject(v1, v2 Vect) Vect</pre>
			<p>
Returns the vector projection of v1 onto v2.
</p>

		</span>
	
		<h1 id="Vrotate" class="hdr pkg hdr-function"><a href="#Vrotate" title="permalink">»</a>&nbsp;func Vrotate(v1, v2 Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vrotate(v1, v2 Vect) Vect</pre>
			<p>
Uses complex number multiplication to rotate v1 by v2. Scaling will occur if
v1 is not a unit vector.
</p>

		</span>
	
		<h1 id="Vrperp" class="hdr pkg hdr-function"><a href="#Vrperp" title="permalink">»</a>&nbsp;func Vrperp(v Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vrperp(v Vect) Vect</pre>
			<p>
Returns a perpendicular vector. (-90 degree rotation)
</p>

		</span>
	
		<h1 id="Vslerp" class="hdr pkg hdr-function"><a href="#Vslerp" title="permalink">»</a>&nbsp;func Vslerp(v1, v2 Vect, t float64) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vslerp(v1, v2 Vect, t float64) Vect</pre>
			<p>
Spherical linearly interpolate between v1 and v2.
</p>

		</span>
	
		<h1 id="Vslerpconst" class="hdr pkg hdr-function"><a href="#Vslerpconst" title="permalink">»</a>&nbsp;func Vslerpconst(v1, v2 Vect, a float64) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vslerpconst(v1, v2 Vect, a float64) Vect</pre>
			<p>
Spherical linearly interpolate between v1 towards v2 by no more than angle a
radians
</p>

		</span>
	
		<h1 id="Vsub" class="hdr pkg hdr-function"><a href="#Vsub" title="permalink">»</a>&nbsp;func Vsub(v1, v2 Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vsub(v1, v2 Vect) Vect</pre>
			<p>
Subtract two vectors.
</p>

		</span>
	
		<h1 id="Vunrotate" class="hdr pkg hdr-function"><a href="#Vunrotate" title="permalink">»</a>&nbsp;func Vunrotate(v1, v2 Vect) Vect <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg function">
			<pre>func Vunrotate(v1, v2 Vect) Vect</pre>
			<p>
Inverse of Vrotate().
</p>

		</span>
	

	
	



<h1 id="package-files" class="hdr pkg hdr-files"><a href="#package-files" title="permalink">»</a>&nbsp;Package Files <span class="toplink">(<a href="#top">top</a>)</span></h1>
<span class="section pkg files">
	<p>
	<a href="https:/github.com/azul3d/native-cp/blob/dev/arbiter.go" title="view source">arbiter.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/bb.go" title="view source">bb.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/body.go" title="view source">body.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/chipmunk.go" title="view source">chipmunk.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/constraint.go" title="view source">constraint.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/dampedrotaryspring.go" title="view source">dampedrotaryspring.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/dampedspring.go" title="view source">dampedspring.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/gearjoint.go" title="view source">gearjoint.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/groovejoint.go" title="view source">groovejoint.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/pinjoint.go" title="view source">pinjoint.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/pivotjoint.go" title="view source">pivotjoint.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/polyshape.go" title="view source">polyshape.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/ratchetjoint.go" title="view source">ratchetjoint.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/rotarylimitjoint.go" title="view source">rotarylimitjoint.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/shape.go" title="view source">shape.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/simplemotor.go" title="view source">simplemotor.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/slicejoint.go" title="view source">slicejoint.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/space.go" title="view source">space.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/spatialindex.go" title="view source">spatialindex.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/transform.go" title="view source">transform.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/typescompat.go" title="view source">typescompat.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/unsafe.go" title="view source">unsafe.go</a>
	
	<a href="https:/github.com/azul3d/native-cp/blob/dev/vect.go" title="view source">vect.go</a>
	</p>

	<h2><span class="linkarea">(<a href="#" id="tagged-files-toggle">show tagged files</a>)</span></h2>
	<span id="tagged-files">
		<h2>386 Files</h2>
		<p>
		<a href="https:/github.com/azul3d/native-cp/blob/dev/types_386.go" title="view source">types_386.go</a>
		</p>
	
		<h2>Amd64 Files</h2>
		<p>
		<a href="https:/github.com/azul3d/native-cp/blob/dev/types_amd64.go" title="view source">types_amd64.go</a>
		</p>
	
		<h2>Cgodefs Files</h2>
		<p>
		<a href="https:/github.com/azul3d/native-cp/blob/dev/types_cgodefs.go" title="view source">types_cgodefs.go</a>
		</p>
	
		<h2>Test Files</h2>
		<p>
		<a href="https:/github.com/azul3d/native-cp/blob/dev/body_test.go" title="view source">body_test.go</a>
		
		<a href="https:/github.com/azul3d/native-cp/blob/dev/debugdraw_test.go" title="view source">debugdraw_test.go</a>
		</p>
	</span>
</span>


<script>
$(function() {
	$("#tagged-files").slideUp();
	var toggle = true;
	$("#tagged-files-toggle").click(function(event) {
		event.preventDefault();
		toggle = !toggle;
		if(toggle) {
			$("#tagged-files").slideUp();
			$("#tagged-files-toggle").html("show tagged files");
		} else {
			$("#tagged-files").slideDown();
			$("#tagged-files-toggle").html("hide tagged files");
		}
	});
});
</script>

	</div>
</div>


<div id="footer">
	<div>© 2014 The Azul3D Authors, All Rights Reserved.</div>
	<div>Unless noted otherwise, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code is licensed under a BSD license.</div>
</div>


<script>
$(document).ready(function() {
	$("body").css("opacity", 0);

	 
	var ValidIpAddressRegex = "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$";
	var redirect = window.location.hostname != 'azul3d.org';
	if(location.hostname == "localhost" || location.hostname.search(ValidIpAddressRegex) != -1) {
		
		
		redirect = false;
	}
	if(redirect){
	    window.top.location.href = 'http://azul3d.org'; 
	}
});

$(window).ready(function() {
	var fadeIn = function(self, delay) {
		self.css("opacity", 0).delay(delay).animate({opacity: 1}, "slow");
	}

	var fromSameSite = document.referrer.indexOf(location.protocol + "//" + location.host) === 0;


	
	
	var longPage = $(document).height() > $(window).height() * 3;
	if(fromSameSite || longPage) {
		fadeIn($("body"), 10);
	} else {
		var workingIndex = 0;
		var speed = 75;
		$("#content").children().each(function(index) {
			fadeIn($(this), 1000 + (speed * workingIndex));
			workingIndex++;
			if($(this).hasClass("list")) {
				$(this).children().each(function(index) {
					fadeIn($(this), 1000 + (speed * workingIndex));
					workingIndex++;
				});
			}
		});

		var w = $("#shortbar").width();
		$("#shortbar").css({
			right: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			right: "0px",
			opacity: 1
			}, "slow");

		var w = $("#navigation").width();
		$("#navigation").css({
			left: -w-1 + "px",
			opacity: 0
		}).delay(10).animate({
			left: "0px",
			opacity: 1
			}, "slow");

		fadeIn($("#logo"), 10);
		fadeIn($("body"), 10);
	}
})
</script>
	</body>
</html>



